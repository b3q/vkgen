// Code generated by vkgen; DO NOT EDIT.

package generated

// AccountBan.
//
// https://vk.com/dev/account.ban
type AccountBan struct {
	OwnerID int64
}

func (req AccountBan) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// AccountChangePassword.
//
// Changes a user password after access is successfully restored with the [vk.com/dev/auth.restore|auth.restore] method.
//
// https://vk.com/dev/account.changePassword
type AccountChangePassword struct {
	RestoreSid         string // Session id received after the [vk.com/dev/auth.restore|auth.restore] method is executed. (If the password is changed right after the access was restored)
	ChangePasswordHash string // Hash received after a successful OAuth authorization with a code got by SMS. (If the password is changed right after the access was restored)
	OldPassword        string // Current user password.
	NewPassword        string // New password that will be set as a current
}

func (req AccountChangePassword) params() Params {
	params := make(Params)
	if req.RestoreSid != "" {
		params["restore_sid"] = req.RestoreSid
	}
	if req.ChangePasswordHash != "" {
		params["change_password_hash"] = req.ChangePasswordHash
	}
	if req.OldPassword != "" {
		params["old_password"] = req.OldPassword
	}
	if req.NewPassword != "" {
		params["new_password"] = req.NewPassword
	}
	return params
}

// AccountGetActiveOffers.
//
// Returns a list of active ads (offers) which executed by the user will bring him/her respective number of votes to his balance in the application.
//
// https://vk.com/dev/account.getActiveOffers
type AccountGetActiveOffers struct {
	Offset int64
	Count  int64 // Number of results to return.
}

func (req AccountGetActiveOffers) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// AccountGetAppPermissions.
//
// Gets settings of the user in this application.
//
// https://vk.com/dev/account.getAppPermissions
type AccountGetAppPermissions struct {
	UserID int64 // User ID whose settings information shall be got. By default: current user.
}

func (req AccountGetAppPermissions) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// AccountGetBanned.
//
// Returns a user's blacklist.
//
// https://vk.com/dev/account.getBanned
type AccountGetBanned struct {
	Offset int64 // Offset needed to return a specific subset of results.
	Count  int64 // Number of results to return.
}

func (req AccountGetBanned) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// AccountGetCounters.
//
// Returns non-null values of user counters.
//
// https://vk.com/dev/account.getCounters
type AccountGetCounters struct {
	Filter []string // Counters to be returned.
}

func (req AccountGetCounters) params() Params {
	params := make(Params)
	if len(req.Filter) > 0 {
		params["filter"] = req.Filter
	}
	return params
}

// AccountGetInfo.
//
// Returns current account info.
//
// https://vk.com/dev/account.getInfo
type AccountGetInfo struct {
	Fields []string // Fields to return. Possible values: *'country' — user country,, *'https_required' — is "HTTPS only" option enabled,, *'own_posts_default' — is "Show my posts only" option is enabled,, *'no_wall_replies' — are wall replies disabled or not,, *'intro' — is intro passed by user or not,, *'lang' — user language. By default: all.
}

func (req AccountGetInfo) params() Params {
	params := make(Params)
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// AccountGetProfileInfo.
//
// Returns the current account info.
//
// https://vk.com/dev/account.getProfileInfo
type AccountGetProfileInfo struct {
}

func (req AccountGetProfileInfo) params() Params {
	params := make(Params)
	return params
}

// AccountGetPushSettings.
//
// Gets settings of push notifications.
//
// https://vk.com/dev/account.getPushSettings
type AccountGetPushSettings struct {
	DeviceID string // Unique device ID.
}

func (req AccountGetPushSettings) params() Params {
	params := make(Params)
	if req.DeviceID != "" {
		params["device_id"] = req.DeviceID
	}
	return params
}

// AccountRegisterDevice.
//
// Subscribes an iOS/Android/Windows Phone-based device to receive push notifications
//
// https://vk.com/dev/account.registerDevice
type AccountRegisterDevice struct {
	Token         string // Device token used to send notifications. (for mpns, the token shall be URL for sending of notifications)
	DeviceModel   string // String name of device model.
	DeviceYear    int64  // Device year.
	DeviceID      string // Unique device ID.
	SystemVersion string // String version of device operating system.
	Settings      string // Push settings in a [vk.com/dev/push_settings|special format].
	Sandbox       bool
}

func (req AccountRegisterDevice) params() Params {
	params := make(Params)
	if req.Token != "" {
		params["token"] = req.Token
	}
	if req.DeviceModel != "" {
		params["device_model"] = req.DeviceModel
	}
	if req.DeviceYear != 0 {
		params["device_year"] = req.DeviceYear
	}
	if req.DeviceID != "" {
		params["device_id"] = req.DeviceID
	}
	if req.SystemVersion != "" {
		params["system_version"] = req.SystemVersion
	}
	if req.Settings != "" {
		params["settings"] = req.Settings
	}
	if req.Sandbox {
		params["sandbox"] = req.Sandbox
	}
	return params
}

// AccountSaveProfileInfo.
//
// Edits current profile info.
//
// https://vk.com/dev/account.saveProfileInfo
type AccountSaveProfileInfo struct {
	FirstName         string // User first name.
	LastName          string // User last name.
	MaidenName        string // User maiden name (female only)
	ScreenName        string // User screen name.
	CancelRequestID   int64  // ID of the name change request to be canceled. If this parameter is sent, all the others are ignored.
	Sex               int64  // User sex. Possible values: , * '1' – female,, * '2' – male.
	Relation          int64  // User relationship status. Possible values: , * '1' – single,, * '2' – in a relationship,, * '3' – engaged,, * '4' – married,, * '5' – it's complicated,, * '6' – actively searching,, * '7' – in love,, * '0' – not specified.
	RelationPartnerID int64  // ID of the relationship partner.
	Bdate             string // User birth date, format: DD.MM.YYYY.
	BdateVisibility   int64  // Birth date visibility. Returned values: , * '1' – show birth date,, * '2' – show only month and day,, * '0' – hide birth date.
	HomeTown          string // User home town.
	CountryID         int64  // User country.
	CityID            int64  // User city.
	Status            string // Status text.
}

func (req AccountSaveProfileInfo) params() Params {
	params := make(Params)
	if req.FirstName != "" {
		params["first_name"] = req.FirstName
	}
	if req.LastName != "" {
		params["last_name"] = req.LastName
	}
	if req.MaidenName != "" {
		params["maiden_name"] = req.MaidenName
	}
	if req.ScreenName != "" {
		params["screen_name"] = req.ScreenName
	}
	if req.CancelRequestID != 0 {
		params["cancel_request_id"] = req.CancelRequestID
	}
	if req.Sex != 0 {
		params["sex"] = req.Sex
	}
	if req.Relation != 0 {
		params["relation"] = req.Relation
	}
	if req.RelationPartnerID != 0 {
		params["relation_partner_id"] = req.RelationPartnerID
	}
	if req.Bdate != "" {
		params["bdate"] = req.Bdate
	}
	if req.BdateVisibility != 0 {
		params["bdate_visibility"] = req.BdateVisibility
	}
	if req.HomeTown != "" {
		params["home_town"] = req.HomeTown
	}
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.Status != "" {
		params["status"] = req.Status
	}
	return params
}

// AccountSetInfo.
//
// Allows to edit the current account info.
//
// https://vk.com/dev/account.setInfo
type AccountSetInfo struct {
	Name  string // Setting name.
	Value string // Setting value.
}

func (req AccountSetInfo) params() Params {
	params := make(Params)
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Value != "" {
		params["value"] = req.Value
	}
	return params
}

// AccountSetNameInMenu.
//
// Sets an application screen name (up to 17 characters), that is shown to the user in the left menu.
//
// https://vk.com/dev/account.setNameInMenu
type AccountSetNameInMenu struct {
	UserID int64  // User ID.
	Name   string // Application screen name.
}

func (req AccountSetNameInMenu) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	return params
}

// AccountSetOffline.
//
// Marks a current user as offline.
//
// https://vk.com/dev/account.setOffline
type AccountSetOffline struct {
}

func (req AccountSetOffline) params() Params {
	params := make(Params)
	return params
}

// AccountSetOnline.
//
// Marks the current user as online for 15 minutes.
//
// https://vk.com/dev/account.setOnline
type AccountSetOnline struct {
	Voip bool // '1' if videocalls are available for current device.
}

func (req AccountSetOnline) params() Params {
	params := make(Params)
	if req.Voip {
		params["voip"] = req.Voip
	}
	return params
}

// AccountSetPushSettings.
//
// Change push settings.
//
// https://vk.com/dev/account.setPushSettings
type AccountSetPushSettings struct {
	DeviceID string   // Unique device ID.
	Settings string   // Push settings in a [vk.com/dev/push_settings|special format].
	Key      string   // Notification key.
	Value    []string // New value for the key in a [vk.com/dev/push_settings|special format].
}

func (req AccountSetPushSettings) params() Params {
	params := make(Params)
	if req.DeviceID != "" {
		params["device_id"] = req.DeviceID
	}
	if req.Settings != "" {
		params["settings"] = req.Settings
	}
	if req.Key != "" {
		params["key"] = req.Key
	}
	if len(req.Value) > 0 {
		params["value"] = req.Value
	}
	return params
}

// AccountSetSilenceMode.
//
// Mutes push notifications for the set period of time.
//
// https://vk.com/dev/account.setSilenceMode
type AccountSetSilenceMode struct {
	DeviceID string // Unique device ID.
	Time     int64  // Time in seconds for what notifications should be disabled. '-1' to disable forever.
	PeerID   int64  // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
	Sound    int64  // '1' — to enable sound in this dialog, '0' — to disable sound. Only if 'peer_id' contains user or community ID.
}

func (req AccountSetSilenceMode) params() Params {
	params := make(Params)
	if req.DeviceID != "" {
		params["device_id"] = req.DeviceID
	}
	if req.Time != 0 {
		params["time"] = req.Time
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Sound != 0 {
		params["sound"] = req.Sound
	}
	return params
}

// AccountUnban.
//
// https://vk.com/dev/account.unban
type AccountUnban struct {
	OwnerID int64
}

func (req AccountUnban) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// AccountUnregisterDevice.
//
// Unsubscribes a device from push notifications.
//
// https://vk.com/dev/account.unregisterDevice
type AccountUnregisterDevice struct {
	DeviceID string // Unique device ID.
	Sandbox  bool
}

func (req AccountUnregisterDevice) params() Params {
	params := make(Params)
	if req.DeviceID != "" {
		params["device_id"] = req.DeviceID
	}
	if req.Sandbox {
		params["sandbox"] = req.Sandbox
	}
	return params
}

// AdsAddOfficeUsers.
//
// Adds managers and/or supervisors to advertising account.
//
// https://vk.com/dev/ads.addOfficeUsers
type AdsAddOfficeUsers struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe added managers. Description of 'user_specification' objects see below.
}

func (req AdsAddOfficeUsers) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsCheckLink.
//
// Allows to check the ad link.
//
// https://vk.com/dev/ads.checkLink
type AdsCheckLink struct {
	AccountID  int64  // Advertising account ID.
	LinkType   string // Object type: *'community' — community,, *'post' — community post,, *'application' — VK application,, *'video' — video,, *'site' — external site.
	LinkURL    string // Object URL.
	CampaignID int64  // Campaign ID
}

func (req AdsCheckLink) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.LinkType != "" {
		params["link_type"] = req.LinkType
	}
	if req.LinkURL != "" {
		params["link_url"] = req.LinkURL
	}
	if req.CampaignID != 0 {
		params["campaign_id"] = req.CampaignID
	}
	return params
}

// AdsCreateAds.
//
// Creates ads.
//
// https://vk.com/dev/ads.createAds
type AdsCreateAds struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe created ads. Description of 'ad_specification' objects see below.
}

func (req AdsCreateAds) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsCreateCampaigns.
//
// Creates advertising campaigns.
//
// https://vk.com/dev/ads.createCampaigns
type AdsCreateCampaigns struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe created campaigns. Description of 'campaign_specification' objects see below.
}

func (req AdsCreateCampaigns) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsCreateClients.
//
// Creates clients of an advertising agency.
//
// https://vk.com/dev/ads.createClients
type AdsCreateClients struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe created campaigns. Description of 'client_specification' objects see below.
}

func (req AdsCreateClients) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsCreateTargetGroup.
//
// Creates a group to re-target ads for users who visited advertiser's site (viewed information about the product, registered, etc.).
//
// https://vk.com/dev/ads.createTargetGroup
type AdsCreateTargetGroup struct {
	AccountID        int64  // Advertising account ID.
	ClientID         int64  // 'Only for advertising agencies.', ID of the client with the advertising account where the group will be created.
	Name             string // Name of the target group — a string up to 64 characters long.
	Lifetime         int64  // 'For groups with auditory created with pixel code only.', , Number of days after that users will be automatically removed from the group.
	TargetPixelID    int64
	TargetPixelRules string
}

func (req AdsCreateTargetGroup) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Lifetime != 0 {
		params["lifetime"] = req.Lifetime
	}
	if req.TargetPixelID != 0 {
		params["target_pixel_id"] = req.TargetPixelID
	}
	if req.TargetPixelRules != "" {
		params["target_pixel_rules"] = req.TargetPixelRules
	}
	return params
}

// AdsDeleteAds.
//
// Archives ads.
//
// https://vk.com/dev/ads.deleteAds
type AdsDeleteAds struct {
	AccountID int64  // Advertising account ID.
	IDs       string // Serialized JSON array with ad IDs.
}

func (req AdsDeleteAds) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	return params
}

// AdsDeleteCampaigns.
//
// Archives advertising campaigns.
//
// https://vk.com/dev/ads.deleteCampaigns
type AdsDeleteCampaigns struct {
	AccountID int64  // Advertising account ID.
	IDs       string // Serialized JSON array with IDs of deleted campaigns.
}

func (req AdsDeleteCampaigns) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	return params
}

// AdsDeleteClients.
//
// Archives clients of an advertising agency.
//
// https://vk.com/dev/ads.deleteClients
type AdsDeleteClients struct {
	AccountID int64  // Advertising account ID.
	IDs       string // Serialized JSON array with IDs of deleted clients.
}

func (req AdsDeleteClients) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	return params
}

// AdsDeleteTargetGroup.
//
// Deletes a retarget group.
//
// https://vk.com/dev/ads.deleteTargetGroup
type AdsDeleteTargetGroup struct {
	AccountID     int64 // Advertising account ID.
	ClientID      int64 // 'Only for advertising agencies.' , ID of the client with the advertising account where the group will be created.
	TargetGroupID int64 // Group ID.
}

func (req AdsDeleteTargetGroup) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.TargetGroupID != 0 {
		params["target_group_id"] = req.TargetGroupID
	}
	return params
}

// AdsGetAccounts.
//
// Returns a list of advertising accounts.
//
// https://vk.com/dev/ads.getAccounts
type AdsGetAccounts struct {
}

func (req AdsGetAccounts) params() Params {
	params := make(Params)
	return params
}

// AdsGetAds.
//
// Returns number of ads.
//
// https://vk.com/dev/ads.getAds
type AdsGetAds struct {
	AccountID      int64  // Advertising account ID.
	AdIDs          string // Filter by ads. Serialized JSON array with ad IDs. If the parameter is null, all ads will be shown.
	CampaignIDs    string // Filter by advertising campaigns. Serialized JSON array with campaign IDs. If the parameter is null, ads of all campaigns will be shown.
	ClientID       int64  // 'Available and required for advertising agencies.' ID of the client ads are retrieved from.
	IncludeDeleted bool   // Flag that specifies whether archived ads shall be shown: *0 — show only active ads,, *1 — show all ads.
	OnlyDeleted    bool   // Flag that specifies whether to show only archived ads: *0 — show all ads,, *1 — show only archived ads. Available when include_deleted flag is *1
	Limit          int64  // Limit of number of returned ads. Used only if ad_ids parameter is null, and 'campaign_ids' parameter contains ID of only one campaign.
	Offset         int64  // Offset. Used in the same cases as 'limit' parameter.
}

func (req AdsGetAds) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.AdIDs != "" {
		params["ad_ids"] = req.AdIDs
	}
	if req.CampaignIDs != "" {
		params["campaign_ids"] = req.CampaignIDs
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.IncludeDeleted {
		params["include_deleted"] = req.IncludeDeleted
	}
	if req.OnlyDeleted {
		params["only_deleted"] = req.OnlyDeleted
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// AdsGetAdsLayout.
//
// Returns descriptions of ad layouts.
//
// https://vk.com/dev/ads.getAdsLayout
type AdsGetAdsLayout struct {
	AccountID      int64  // Advertising account ID.
	AdIDs          string // Filter by ads. Serialized JSON array with ad IDs. If the parameter is null, all ads will be shown.
	CampaignIDs    string // Filter by advertising campaigns. Serialized JSON array with campaign IDs. If the parameter is null, ads of all campaigns will be shown.
	ClientID       int64  // 'For advertising agencies.' ID of the client ads are retrieved from.
	IncludeDeleted bool   // Flag that specifies whether archived ads shall be shown. *0 — show only active ads,, *1 — show all ads.
	Limit          int64  // Limit of number of returned ads. Used only if 'ad_ids' parameter is null, and 'campaign_ids' parameter contains ID of only one campaign.
	Offset         int64  // Offset. Used in the same cases as 'limit' parameter.
}

func (req AdsGetAdsLayout) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.AdIDs != "" {
		params["ad_ids"] = req.AdIDs
	}
	if req.CampaignIDs != "" {
		params["campaign_ids"] = req.CampaignIDs
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.IncludeDeleted {
		params["include_deleted"] = req.IncludeDeleted
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// AdsGetAdsTargeting.
//
// Returns ad targeting parameters.
//
// https://vk.com/dev/ads.getAdsTargeting
type AdsGetAdsTargeting struct {
	AccountID      int64  // Advertising account ID.
	AdIDs          string // Filter by ads. Serialized JSON array with ad IDs. If the parameter is null, all ads will be shown.
	CampaignIDs    string // Filter by advertising campaigns. Serialized JSON array with campaign IDs. If the parameter is null, ads of all campaigns will be shown.
	ClientID       int64  // 'For advertising agencies.' ID of the client ads are retrieved from.
	IncludeDeleted bool   // flag that specifies whether archived ads shall be shown: *0 — show only active ads,, *1 — show all ads.
	Limit          int64  // Limit of number of returned ads. Used only if 'ad_ids' parameter is null, and 'campaign_ids' parameter contains ID of only one campaign.
	Offset         int64  // Offset needed to return a specific subset of results.
}

func (req AdsGetAdsTargeting) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.AdIDs != "" {
		params["ad_ids"] = req.AdIDs
	}
	if req.CampaignIDs != "" {
		params["campaign_ids"] = req.CampaignIDs
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.IncludeDeleted {
		params["include_deleted"] = req.IncludeDeleted
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// AdsGetBudget.
//
// Returns current budget of the advertising account.
//
// https://vk.com/dev/ads.getBudget
type AdsGetBudget struct {
	AccountID int64 // Advertising account ID.
}

func (req AdsGetBudget) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	return params
}

// AdsGetCampaigns.
//
// Returns a list of campaigns in an advertising account.
//
// https://vk.com/dev/ads.getCampaigns
type AdsGetCampaigns struct {
	AccountID      int64  // Advertising account ID.
	ClientID       int64  // 'For advertising agencies'. ID of the client advertising campaigns are retrieved from.
	IncludeDeleted bool   // Flag that specifies whether archived ads shall be shown. *0 — show only active campaigns,, *1 — show all campaigns.
	CampaignIDs    string // Filter of advertising campaigns to show. Serialized JSON array with campaign IDs. Only campaigns that exist in 'campaign_ids' and belong to the specified advertising account will be shown. If the parameter is null, all campaigns will be shown.
	Fields         []string
}

func (req AdsGetCampaigns) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.IncludeDeleted {
		params["include_deleted"] = req.IncludeDeleted
	}
	if req.CampaignIDs != "" {
		params["campaign_ids"] = req.CampaignIDs
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// AdsGetCategories.
//
// Returns a list of possible ad categories.
//
// https://vk.com/dev/ads.getCategories
type AdsGetCategories struct {
	Lang string // Language. The full list of supported languages is [vk.com/dev/api_requests|here].
}

func (req AdsGetCategories) params() Params {
	params := make(Params)
	if req.Lang != "" {
		params["lang"] = req.Lang
	}
	return params
}

// AdsGetClients.
//
// Returns a list of advertising agency's clients.
//
// https://vk.com/dev/ads.getClients
type AdsGetClients struct {
	AccountID int64 // Advertising account ID.
}

func (req AdsGetClients) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	return params
}

// AdsGetDemographics.
//
// Returns demographics for ads or campaigns.
//
// https://vk.com/dev/ads.getDemographics
type AdsGetDemographics struct {
	AccountID int64  // Advertising account ID.
	IDsType   string // Type of requested objects listed in 'ids' parameter: *ad — ads,, *campaign — campaigns.
	IDs       string // IDs requested ads or campaigns, separated with a comma, depending on the value set in 'ids_type'. Maximum 2000 objects.
	Period    string // Data grouping by dates: *day — statistics by days,, *month — statistics by months,, *overall — overall statistics. 'date_from' and 'date_to' parameters set temporary limits.
	DateFrom  string // Date to show statistics from. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — day it was created on,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — month it was created in,, *overall: 0.
	DateTo    string // Date to show statistics to. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — current day,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — current month,, *overall: 0.
}

func (req AdsGetDemographics) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDsType != "" {
		params["ids_type"] = req.IDsType
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	if req.Period != "" {
		params["period"] = req.Period
	}
	if req.DateFrom != "" {
		params["date_from"] = req.DateFrom
	}
	if req.DateTo != "" {
		params["date_to"] = req.DateTo
	}
	return params
}

// AdsGetFloodStats.
//
// Returns information about current state of a counter — number of remaining runs of methods and time to the next counter nulling in seconds.
//
// https://vk.com/dev/ads.getFloodStats
type AdsGetFloodStats struct {
	AccountID int64 // Advertising account ID.
}

func (req AdsGetFloodStats) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	return params
}

// AdsGetLookalikeRequests.
//
// https://vk.com/dev/ads.getLookalikeRequests
type AdsGetLookalikeRequests struct {
	AccountID   int64
	ClientID    int64
	RequestsIDs string
	Offset      int64
	Limit       int64
	SortBy      string
}

func (req AdsGetLookalikeRequests) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.RequestsIDs != "" {
		params["requests_ids"] = req.RequestsIDs
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	if req.SortBy != "" {
		params["sort_by"] = req.SortBy
	}
	return params
}

// AdsGetMusicians.
//
// https://vk.com/dev/ads.getMusicians
type AdsGetMusicians struct {
	ArtistName string
}

func (req AdsGetMusicians) params() Params {
	params := make(Params)
	if req.ArtistName != "" {
		params["artist_name"] = req.ArtistName
	}
	return params
}

// AdsGetOfficeUsers.
//
// Returns a list of managers and supervisors of advertising account.
//
// https://vk.com/dev/ads.getOfficeUsers
type AdsGetOfficeUsers struct {
	AccountID int64 // Advertising account ID.
}

func (req AdsGetOfficeUsers) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	return params
}

// AdsGetPostsReach.
//
// Returns detailed statistics of promoted posts reach from campaigns and ads.
//
// https://vk.com/dev/ads.getPostsReach
type AdsGetPostsReach struct {
	AccountID int64  // Advertising account ID.
	IDsType   string // Type of requested objects listed in 'ids' parameter: *ad — ads,, *campaign — campaigns.
	IDs       string // IDs requested ads or campaigns, separated with a comma, depending on the value set in 'ids_type'. Maximum 100 objects.
}

func (req AdsGetPostsReach) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDsType != "" {
		params["ids_type"] = req.IDsType
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	return params
}

// AdsGetRejectionReason.
//
// Returns a reason of ad rejection for pre-moderation.
//
// https://vk.com/dev/ads.getRejectionReason
type AdsGetRejectionReason struct {
	AccountID int64 // Advertising account ID.
	AdID      int64 // Ad ID.
}

func (req AdsGetRejectionReason) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.AdID != 0 {
		params["ad_id"] = req.AdID
	}
	return params
}

// AdsGetStatistics.
//
// Returns statistics of performance indicators for ads, campaigns, clients or the whole account.
//
// https://vk.com/dev/ads.getStatistics
type AdsGetStatistics struct {
	AccountID   int64    // Advertising account ID.
	IDsType     string   // Type of requested objects listed in 'ids' parameter: *ad — ads,, *campaign — campaigns,, *client — clients,, *office — account.
	IDs         string   // IDs requested ads, campaigns, clients or account, separated with a comma, depending on the value set in 'ids_type'. Maximum 2000 objects.
	Period      string   // Data grouping by dates: *day — statistics by days,, *month — statistics by months,, *overall — overall statistics. 'date_from' and 'date_to' parameters set temporary limits.
	DateFrom    string   // Date to show statistics from. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — day it was created on,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — month it was created in,, *overall: 0.
	DateTo      string   // Date to show statistics to. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — current day,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — current month,, *overall: 0.
	StatsFields []string // Additional fields to add to statistics
}

func (req AdsGetStatistics) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDsType != "" {
		params["ids_type"] = req.IDsType
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	if req.Period != "" {
		params["period"] = req.Period
	}
	if req.DateFrom != "" {
		params["date_from"] = req.DateFrom
	}
	if req.DateTo != "" {
		params["date_to"] = req.DateTo
	}
	if len(req.StatsFields) > 0 {
		params["stats_fields"] = req.StatsFields
	}
	return params
}

// AdsGetSuggestions.
//
// Returns a set of auto-suggestions for various targeting parameters.
//
// https://vk.com/dev/ads.getSuggestions
type AdsGetSuggestions struct {
	Section string // Section, suggestions are retrieved in. Available values: *countries — request of a list of countries. If q is not set or blank, a short list of countries is shown. Otherwise, a full list of countries is shown. *regions — requested list of regions. 'country' parameter is required. *cities — requested list of cities. 'country' parameter is required. *districts — requested list of districts. 'cities' parameter is required. *stations — requested list of subway stations. 'cities' parameter is required. *streets — requested list of streets. 'cities' parameter is required. *schools — requested list of educational organizations. 'cities' parameter is required. *interests — requested list of interests. *positions — requested list of positions (professions). *group_types — requested list of group types. *religions — requested list of religious commitments. *browsers — requested list of browsers and mobile devices.
	IDs     string // Objects IDs separated by commas. If the parameter is passed, 'q, country, cities' should not be passed.
	Q       string // Filter-line of the request (for countries, regions, cities, streets, schools, interests, positions).
	Country int64  // ID of the country objects are searched in.
	Cities  string // IDs of cities where objects are searched in, separated with a comma.
	Lang    string // Language of the returned string values. Supported languages: *ru — Russian,, *ua — Ukrainian,, *en — English.
}

func (req AdsGetSuggestions) params() Params {
	params := make(Params)
	if req.Section != "" {
		params["section"] = req.Section
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Country != 0 {
		params["country"] = req.Country
	}
	if req.Cities != "" {
		params["cities"] = req.Cities
	}
	if req.Lang != "" {
		params["lang"] = req.Lang
	}
	return params
}

// AdsGetTargetGroups.
//
// Returns a list of target groups.
//
// https://vk.com/dev/ads.getTargetGroups
type AdsGetTargetGroups struct {
	AccountID int64 // Advertising account ID.
	ClientID  int64 // 'Only for advertising agencies.', ID of the client with the advertising account where the group will be created.
	Extended  bool  // '1' — to return pixel code.
}

func (req AdsGetTargetGroups) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// AdsGetTargetingStats.
//
// Returns the size of targeting audience, and also recommended values for CPC and CPM.
//
// https://vk.com/dev/ads.getTargetingStats
type AdsGetTargetingStats struct {
	AccountID             int64 // Advertising account ID.
	ClientID              int64
	Criteria              string // Serialized JSON object that describes targeting parameters. Description of 'criteria' object see below.
	AdID                  int64  // ID of an ad which targeting parameters shall be analyzed.
	AdFormat              int64  // Ad format. Possible values: *'1' — image and text,, *'2' — big image,, *'3' — exclusive format,, *'4' — community, square image,, *'7' — special app format,, *'8' — special community format,, *'9' — post in community,, *'10' — app board.
	AdPlatform            string // Platforms to use for ad showing. Possible values: (for 'ad_format' = '1'), *'0' — VK and partner sites,, *'1' — VK only. (for 'ad_format' = '9'), *'all' — all platforms,, *'desktop' — desktop version,, *'mobile' — mobile version and apps.
	AdPlatformNoWall      string
	AdPlatformNoAdNetwork string
	LinkURL               string // URL for the advertised object.
	LinkDomain            string // Domain of the advertised object.
	NeedPrecise           bool   // Additionally return recommended cpc and cpm to reach 5,10..95 percents of audience.
}

func (req AdsGetTargetingStats) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.Criteria != "" {
		params["criteria"] = req.Criteria
	}
	if req.AdID != 0 {
		params["ad_id"] = req.AdID
	}
	if req.AdFormat != 0 {
		params["ad_format"] = req.AdFormat
	}
	if req.AdPlatform != "" {
		params["ad_platform"] = req.AdPlatform
	}
	if req.AdPlatformNoWall != "" {
		params["ad_platform_no_wall"] = req.AdPlatformNoWall
	}
	if req.AdPlatformNoAdNetwork != "" {
		params["ad_platform_no_ad_network"] = req.AdPlatformNoAdNetwork
	}
	if req.LinkURL != "" {
		params["link_url"] = req.LinkURL
	}
	if req.LinkDomain != "" {
		params["link_domain"] = req.LinkDomain
	}
	if req.NeedPrecise {
		params["need_precise"] = req.NeedPrecise
	}
	return params
}

// AdsGetUploadURL.
//
// Returns URL to upload an ad photo to.
//
// https://vk.com/dev/ads.getUploadURL
type AdsGetUploadURL struct {
	AdFormat int64 // Ad format: *1 — image and text,, *2 — big image,, *3 — exclusive format,, *4 — community, square image,, *7 — special app format.
	Icon     int64
}

func (req AdsGetUploadURL) params() Params {
	params := make(Params)
	if req.AdFormat != 0 {
		params["ad_format"] = req.AdFormat
	}
	if req.Icon != 0 {
		params["icon"] = req.Icon
	}
	return params
}

// AdsGetVideoUploadURL.
//
// Returns URL to upload an ad video to.
//
// https://vk.com/dev/ads.getVideoUploadURL
type AdsGetVideoUploadURL struct {
}

func (req AdsGetVideoUploadURL) params() Params {
	params := make(Params)
	return params
}

// AdsImportTargetContacts.
//
// Imports a list of advertiser's contacts to count VK registered users against the target group.
//
// https://vk.com/dev/ads.importTargetContacts
type AdsImportTargetContacts struct {
	AccountID     int64  // Advertising account ID.
	ClientID      int64  // 'Only for advertising agencies.' , ID of the client with the advertising account where the group will be created.
	TargetGroupID int64  // Target group ID.
	Contacts      string // List of phone numbers, emails or user IDs separated with a comma.
}

func (req AdsImportTargetContacts) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.TargetGroupID != 0 {
		params["target_group_id"] = req.TargetGroupID
	}
	if req.Contacts != "" {
		params["contacts"] = req.Contacts
	}
	return params
}

// AdsRemoveOfficeUsers.
//
// Removes managers and/or supervisors from advertising account.
//
// https://vk.com/dev/ads.removeOfficeUsers
type AdsRemoveOfficeUsers struct {
	AccountID int64  // Advertising account ID.
	IDs       string // Serialized JSON array with IDs of deleted managers.
}

func (req AdsRemoveOfficeUsers) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.IDs != "" {
		params["ids"] = req.IDs
	}
	return params
}

// AdsUpdateAds.
//
// Edits ads.
//
// https://vk.com/dev/ads.updateAds
type AdsUpdateAds struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe changes in ads. Description of 'ad_edit_specification' objects see below.
}

func (req AdsUpdateAds) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsUpdateCampaigns.
//
// Edits advertising campaigns.
//
// https://vk.com/dev/ads.updateCampaigns
type AdsUpdateCampaigns struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe changes in campaigns. Description of 'campaign_mod' objects see below.
}

func (req AdsUpdateCampaigns) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsUpdateClients.
//
// Edits clients of an advertising agency.
//
// https://vk.com/dev/ads.updateClients
type AdsUpdateClients struct {
	AccountID int64  // Advertising account ID.
	Data      string // Serialized JSON array of objects that describe changes in clients. Description of 'client_mod' objects see below.
}

func (req AdsUpdateClients) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// AdsUpdateTargetGroup.
//
// Edits a retarget group.
//
// https://vk.com/dev/ads.updateTargetGroup
type AdsUpdateTargetGroup struct {
	AccountID        int64  // Advertising account ID.
	ClientID         int64  // 'Only for advertising agencies.' , ID of the client with the advertising account where the group will be created.
	TargetGroupID    int64  // Group ID.
	Name             string // New name of the target group — a string up to 64 characters long.
	Domain           string // Domain of the site where user accounting code will be placed.
	Lifetime         int64  // 'Only for the groups that get audience from sites with user accounting code.', Time in days when users added to a retarget group will be automatically excluded from it. '0' - automatic exclusion is off.
	TargetPixelID    int64
	TargetPixelRules string
}

func (req AdsUpdateTargetGroup) params() Params {
	params := make(Params)
	if req.AccountID != 0 {
		params["account_id"] = req.AccountID
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.TargetGroupID != 0 {
		params["target_group_id"] = req.TargetGroupID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Domain != "" {
		params["domain"] = req.Domain
	}
	if req.Lifetime != 0 {
		params["lifetime"] = req.Lifetime
	}
	if req.TargetPixelID != 0 {
		params["target_pixel_id"] = req.TargetPixelID
	}
	if req.TargetPixelRules != "" {
		params["target_pixel_rules"] = req.TargetPixelRules
	}
	return params
}

// AppWidgetsUpdate.
//
// Allows to update community app widget
//
// https://vk.com/dev/appWidgets.update
type AppWidgetsUpdate struct {
	Code string
	Type string
}

func (req AppWidgetsUpdate) params() Params {
	params := make(Params)
	if req.Code != "" {
		params["code"] = req.Code
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	return params
}

// AppsDeleteAppRequests.
//
// Deletes all request notifications from the current app.
//
// https://vk.com/dev/apps.deleteAppRequests
type AppsDeleteAppRequests struct {
}

func (req AppsDeleteAppRequests) params() Params {
	params := make(Params)
	return params
}

// AppsGet.
//
// Returns applications data.
//
// https://vk.com/dev/apps.get
type AppsGet struct {
	AppID         int64    // Application ID
	AppIDs        []string // List of application ID
	Platform      string   // platform. Possible values: *'ios' — iOS,, *'android' — Android,, *'winphone' — Windows Phone,, *'web' — приложения на vk.com. By default: 'web'.
	Extended      bool
	ReturnFriends bool
	Fields        []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'contacts', 'education', 'online', 'counters', 'relation', 'last_seen', 'activity', 'can_write_private_message', 'can_see_all_posts', 'can_post', 'universities', (only if return_friends - 1)
	NameCase      string        // Case for declension of user name and surname: 'nom' — nominative (default),, 'gen' — genitive,, 'dat' — dative,, 'acc' — accusative,, 'ins' — instrumental,, 'abl' — prepositional. (only if 'return_friends' = '1')
}

func (req AppsGet) params() Params {
	params := make(Params)
	if req.AppID != 0 {
		params["app_id"] = req.AppID
	}
	if len(req.AppIDs) > 0 {
		params["app_ids"] = req.AppIDs
	}
	if req.Platform != "" {
		params["platform"] = req.Platform
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.ReturnFriends {
		params["return_friends"] = req.ReturnFriends
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// AppsGetCatalog.
//
// Returns a list of applications (apps) available to users in the App Catalog.
//
// https://vk.com/dev/apps.getCatalog
type AppsGetCatalog struct {
	Sort          string // Sort order: 'popular_today' — popular for one day (default), 'visitors' — by visitors number , 'create_date' — by creation date, 'growth_rate' — by growth rate, 'popular_week' — popular for one week
	Offset        int64  // Offset required to return a specific subset of apps.
	Count         int64  // Number of apps to return.
	Platform      string
	Extended      bool // '1' — to return additional fields 'screenshots', 'MAU', 'catalog_position', and 'international'. If set, 'count' must be less than or equal to '100'. '0' — not to return additional fields (default).
	ReturnFriends bool
	Fields        []UsersFields
	NameCase      string
	Q             string // Search query string.
	GenreID       int64
	Filter        string // 'installed' — to return list of installed apps (only for mobile platform).
}

func (req AppsGetCatalog) params() Params {
	params := make(Params)
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Platform != "" {
		params["platform"] = req.Platform
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.ReturnFriends {
		params["return_friends"] = req.ReturnFriends
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.GenreID != 0 {
		params["genre_id"] = req.GenreID
	}
	if req.Filter != "" {
		params["filter"] = req.Filter
	}
	return params
}

// AppsGetFriendsList.
//
// Creates friends list for requests and invites in current app.
//
// https://vk.com/dev/apps.getFriendsList
type AppsGetFriendsList struct {
	Extended bool
	Count    int64 // List size.
	Offset   int64
	Type     string        // List type. Possible values: * 'invite' — available for invites (don't play the game),, * 'request' — available for request (play the game). By default: 'invite'.
	Fields   []UsersFields // Additional profile fields, see [vk.com/dev/fields|description].
}

func (req AppsGetFriendsList) params() Params {
	params := make(Params)
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// AppsGetLeaderboard.
//
// Returns players rating in the game.
//
// https://vk.com/dev/apps.getLeaderboard
type AppsGetLeaderboard struct {
	Type     string // Leaderboard type. Possible values: *'level' — by level,, *'points' — by mission points,, *'score' — by score ().
	Global   bool   // Rating type. Possible values: *'1' — global rating among all players,, *'0' — rating among user friends.
	Extended bool   // 1 — to return additional info about users
}

func (req AppsGetLeaderboard) params() Params {
	params := make(Params)
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.Global {
		params["global"] = req.Global
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// AppsGetScopes.
//
// Returns scopes for auth
//
// https://vk.com/dev/apps.getScopes
type AppsGetScopes struct {
	Type string
}

func (req AppsGetScopes) params() Params {
	params := make(Params)
	if req.Type != "" {
		params["type"] = req.Type
	}
	return params
}

// AppsGetScore.
//
// Returns user score in app
//
// https://vk.com/dev/apps.getScore
type AppsGetScore struct {
	UserID int64
}

func (req AppsGetScore) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// AppsPromoHasActiveGift.
//
// https://vk.com/dev/apps.promoHasActiveGift
type AppsPromoHasActiveGift struct {
	PromoID int64 // Id of game promo action
	UserID  int64
}

func (req AppsPromoHasActiveGift) params() Params {
	params := make(Params)
	if req.PromoID != 0 {
		params["promo_id"] = req.PromoID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// AppsPromoUseGift.
//
// https://vk.com/dev/apps.promoUseGift
type AppsPromoUseGift struct {
	PromoID int64 // Id of game promo action
	UserID  int64
}

func (req AppsPromoUseGift) params() Params {
	params := make(Params)
	if req.PromoID != 0 {
		params["promo_id"] = req.PromoID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// AppsSendRequest.
//
// Sends a request to another user in an app that uses VK authorization.
//
// https://vk.com/dev/apps.sendRequest
type AppsSendRequest struct {
	UserID   int64  // id of the user to send a request
	Text     string // request text
	Type     string // request type. Values: 'invite' – if the request is sent to a user who does not have the app installed,, 'request' – if a user has already installed the app
	Name     string
	Key      string // special string key to be sent with the request
	Separate bool
}

func (req AppsSendRequest) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Key != "" {
		params["key"] = req.Key
	}
	if req.Separate {
		params["separate"] = req.Separate
	}
	return params
}

// AuthCheckPhone.
//
// Checks a user's phone number for correctness.
//
// https://vk.com/dev/auth.checkPhone
type AuthCheckPhone struct {
	Phone        string // Phone number.
	ClientID     int64  // User ID.
	ClientSecret string
	AuthByPhone  bool
}

func (req AuthCheckPhone) params() Params {
	params := make(Params)
	if req.Phone != "" {
		params["phone"] = req.Phone
	}
	if req.ClientID != 0 {
		params["client_id"] = req.ClientID
	}
	if req.ClientSecret != "" {
		params["client_secret"] = req.ClientSecret
	}
	if req.AuthByPhone {
		params["auth_by_phone"] = req.AuthByPhone
	}
	return params
}

// AuthRestore.
//
// Allows to restore account access using a code received via SMS. " This method is only available for apps with [vk.com/dev/auth_direct|Direct authorization] access. "
//
// https://vk.com/dev/auth.restore
type AuthRestore struct {
	Phone    string // User phone number.
	LastName string // User last name.
}

func (req AuthRestore) params() Params {
	params := make(Params)
	if req.Phone != "" {
		params["phone"] = req.Phone
	}
	if req.LastName != "" {
		params["last_name"] = req.LastName
	}
	return params
}

// BoardAddTopic.
//
// Creates a new topic on a community's discussion board.
//
// https://vk.com/dev/board.addTopic
type BoardAddTopic struct {
	GroupID     int64    // ID of the community that owns the discussion board.
	Title       string   // Topic title.
	Text        string   // Text of the topic.
	FromGroup   bool     // For a community: '1' — to post the topic as by the community, '0' — to post the topic as by the user (default)
	Attachments []string // List of media objects attached to the topic, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media object: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media owner. '<media_id>' — Media ID. Example: "photo100172_166443618,photo66748_265827614", , "NOTE: If you try to attach more than one reference, an error will be thrown.",
}

func (req BoardAddTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	if req.FromGroup {
		params["from_group"] = req.FromGroup
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	return params
}

// BoardCloseTopic.
//
// Closes a topic on a community's discussion board so that comments cannot be posted.
//
// https://vk.com/dev/board.closeTopic
type BoardCloseTopic struct {
	GroupID int64 // ID of the community that owns the discussion board.
	TopicID int64 // Topic ID.
}

func (req BoardCloseTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	return params
}

// BoardCreateComment.
//
// Adds a comment on a topic on a community's discussion board.
//
// https://vk.com/dev/board.createComment
type BoardCreateComment struct {
	GroupID     int64    // ID of the community that owns the discussion board.
	TopicID     int64    // ID of the topic to be commented on.
	Message     string   // (Required if 'attachments' is not set.) Text of the comment.
	Attachments []string // (Required if 'text' is not set.) List of media objects attached to the comment, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media object: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media owner. '<media_id>' — Media ID.
	FromGroup   bool     // '1' — to post the comment as by the community, '0' — to post the comment as by the user (default)
	StickerID   int64    // Sticker ID.
	Guid        string   // Unique identifier to avoid repeated comments.
}

func (req BoardCreateComment) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.FromGroup {
		params["from_group"] = req.FromGroup
	}
	if req.StickerID != 0 {
		params["sticker_id"] = req.StickerID
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	return params
}

// BoardDeleteComment.
//
// Deletes a comment on a topic on a community's discussion board.
//
// https://vk.com/dev/board.deleteComment
type BoardDeleteComment struct {
	GroupID   int64 // ID of the community that owns the discussion board.
	TopicID   int64 // Topic ID.
	CommentID int64 // Comment ID.
}

func (req BoardDeleteComment) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// BoardDeleteTopic.
//
// Deletes a topic from a community's discussion board.
//
// https://vk.com/dev/board.deleteTopic
type BoardDeleteTopic struct {
	GroupID int64 // ID of the community that owns the discussion board.
	TopicID int64 // Topic ID.
}

func (req BoardDeleteTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	return params
}

// BoardEditComment.
//
// Edits a comment on a topic on a community's discussion board.
//
// https://vk.com/dev/board.editComment
type BoardEditComment struct {
	GroupID     int64    // ID of the community that owns the discussion board.
	TopicID     int64    // Topic ID.
	CommentID   int64    // ID of the comment on the topic.
	Message     string   // (Required if 'attachments' is not set). New comment text.
	Attachments []string // (Required if 'message' is not set.) List of media objects attached to the comment, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media object: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media owner. '<media_id>' — Media ID. Example: "photo100172_166443618,photo66748_265827614"
}

func (req BoardEditComment) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	return params
}

// BoardEditTopic.
//
// Edits the title of a topic on a community's discussion board.
//
// https://vk.com/dev/board.editTopic
type BoardEditTopic struct {
	GroupID int64  // ID of the community that owns the discussion board.
	TopicID int64  // Topic ID.
	Title   string // New title of the topic.
}

func (req BoardEditTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	return params
}

// BoardFixTopic.
//
// Pins a topic (fixes its place) to the top of a community's discussion board.
//
// https://vk.com/dev/board.fixTopic
type BoardFixTopic struct {
	GroupID int64 // ID of the community that owns the discussion board.
	TopicID int64 // Topic ID.
}

func (req BoardFixTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	return params
}

// BoardGetComments.
//
// Returns a list of comments on a topic on a community's discussion board.
//
// https://vk.com/dev/board.getComments
type BoardGetComments struct {
	GroupID        int64 // ID of the community that owns the discussion board.
	TopicID        int64 // Topic ID.
	NeedLikes      bool  // '1' — to return the 'likes' field, '0' — not to return the 'likes' field (default)
	StartCommentID int64
	Offset         int64  // Offset needed to return a specific subset of comments.
	Count          int64  // Number of comments to return.
	Extended       bool   // '1' — to return information about users who posted comments, '0' — to return no additional fields (default)
	Sort           string // Sort order: 'asc' — by creation date in chronological order, 'desc' — by creation date in reverse chronological order,
}

func (req BoardGetComments) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	if req.NeedLikes {
		params["need_likes"] = req.NeedLikes
	}
	if req.StartCommentID != 0 {
		params["start_comment_id"] = req.StartCommentID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	return params
}

// BoardGetTopics.
//
// Returns a list of topics on a community's discussion board.
//
// https://vk.com/dev/board.getTopics
type BoardGetTopics struct {
	GroupID       int64   // ID of the community that owns the discussion board.
	TopicIDs      []int64 // IDs of topics to be returned (100 maximum). By default, all topics are returned. If this parameter is set, the 'order', 'offset', and 'count' parameters are ignored.
	Order         int64   // Sort order: '1' — by date updated in reverse chronological order. '2' — by date created in reverse chronological order. '-1' — by date updated in chronological order. '-2' — by date created in chronological order. If no sort order is specified, topics are returned in the order specified by the group administrator. Pinned topics are returned first, regardless of the sorting.
	Offset        int64   // Offset needed to return a specific subset of topics.
	Count         int64   // Number of topics to return.
	Extended      bool    // '1' — to return information about users who created topics or who posted there last, '0' — to return no additional fields (default)
	Preview       int64   // '1' — to return the first comment in each topic,, '2' — to return the last comment in each topic,, '0' — to return no comments. By default: '0'.
	PreviewLength int64   // Number of characters after which to truncate the previewed comment. To preview the full comment, specify '0'.
}

func (req BoardGetTopics) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if len(req.TopicIDs) > 0 {
		params["topic_ids"] = req.TopicIDs
	}
	if req.Order != 0 {
		params["order"] = req.Order
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Preview != 0 {
		params["preview"] = req.Preview
	}
	if req.PreviewLength != 0 {
		params["preview_length"] = req.PreviewLength
	}
	return params
}

// BoardOpenTopic.
//
// Re-opens a previously closed topic on a community's discussion board.
//
// https://vk.com/dev/board.openTopic
type BoardOpenTopic struct {
	GroupID int64 // ID of the community that owns the discussion board.
	TopicID int64 // Topic ID.
}

func (req BoardOpenTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	return params
}

// BoardRestoreComment.
//
// Restores a comment deleted from a topic on a community's discussion board.
//
// https://vk.com/dev/board.restoreComment
type BoardRestoreComment struct {
	GroupID   int64 // ID of the community that owns the discussion board.
	TopicID   int64 // Topic ID.
	CommentID int64 // Comment ID.
}

func (req BoardRestoreComment) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// BoardUnfixTopic.
//
// Unpins a pinned topic from the top of a community's discussion board.
//
// https://vk.com/dev/board.unfixTopic
type BoardUnfixTopic struct {
	GroupID int64 // ID of the community that owns the discussion board.
	TopicID int64 // Topic ID.
}

func (req BoardUnfixTopic) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.TopicID != 0 {
		params["topic_id"] = req.TopicID
	}
	return params
}

// DatabaseGetChairs.
//
// Returns list of chairs on a specified faculty.
//
// https://vk.com/dev/database.getChairs
type DatabaseGetChairs struct {
	FacultyID int64 // id of the faculty to get chairs from
	Offset    int64 // offset required to get a certain subset of chairs
	Count     int64 // amount of chairs to get
}

func (req DatabaseGetChairs) params() Params {
	params := make(Params)
	if req.FacultyID != 0 {
		params["faculty_id"] = req.FacultyID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DatabaseGetCities.
//
// Returns a list of cities.
//
// https://vk.com/dev/database.getCities
type DatabaseGetCities struct {
	CountryID int64  // Country ID.
	RegionID  int64  // Region ID.
	Q         string // Search query.
	NeedAll   bool   // '1' — to return all cities in the country, '0' — to return major cities in the country (default),
	Offset    int64  // Offset needed to return a specific subset of cities.
	Count     int64  // Number of cities to return.
}

func (req DatabaseGetCities) params() Params {
	params := make(Params)
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.RegionID != 0 {
		params["region_id"] = req.RegionID
	}
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.NeedAll {
		params["need_all"] = req.NeedAll
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DatabaseGetCitiesByID.
//
// Returns information about cities by their IDs.
//
// https://vk.com/dev/database.getCitiesById
type DatabaseGetCitiesByID struct {
	CityIDs []int64 // City IDs.
}

func (req DatabaseGetCitiesByID) params() Params {
	params := make(Params)
	if len(req.CityIDs) > 0 {
		params["city_ids"] = req.CityIDs
	}
	return params
}

// DatabaseGetCountries.
//
// Returns a list of countries.
//
// https://vk.com/dev/database.getCountries
type DatabaseGetCountries struct {
	NeedAll bool   // '1' — to return a full list of all countries, '0' — to return a list of countries near the current user's country (default).
	Code    string // Country codes in [vk.com/dev/country_codes|ISO 3166-1 alpha-2] standard.
	Offset  int64  // Offset needed to return a specific subset of countries.
	Count   int64  // Number of countries to return.
}

func (req DatabaseGetCountries) params() Params {
	params := make(Params)
	if req.NeedAll {
		params["need_all"] = req.NeedAll
	}
	if req.Code != "" {
		params["code"] = req.Code
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DatabaseGetCountriesByID.
//
// Returns information about countries by their IDs.
//
// https://vk.com/dev/database.getCountriesById
type DatabaseGetCountriesByID struct {
	CountryIDs []int64 // Country IDs.
}

func (req DatabaseGetCountriesByID) params() Params {
	params := make(Params)
	if len(req.CountryIDs) > 0 {
		params["country_ids"] = req.CountryIDs
	}
	return params
}

// DatabaseGetFaculties.
//
// Returns a list of faculties (i.e., university departments).
//
// https://vk.com/dev/database.getFaculties
type DatabaseGetFaculties struct {
	UniversityID int64 // University ID.
	Offset       int64 // Offset needed to return a specific subset of faculties.
	Count        int64 // Number of faculties to return.
}

func (req DatabaseGetFaculties) params() Params {
	params := make(Params)
	if req.UniversityID != 0 {
		params["university_id"] = req.UniversityID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DatabaseGetMetroStations.
//
// Get metro stations by city
//
// https://vk.com/dev/database.getMetroStations
type DatabaseGetMetroStations struct {
	CityID   int64
	Offset   int64
	Count    int64
	Extended bool
}

func (req DatabaseGetMetroStations) params() Params {
	params := make(Params)
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// DatabaseGetMetroStationsByID.
//
// Get metro station by his id
//
// https://vk.com/dev/database.getMetroStationsById
type DatabaseGetMetroStationsByID struct {
	StationIDs []int64
}

func (req DatabaseGetMetroStationsByID) params() Params {
	params := make(Params)
	if len(req.StationIDs) > 0 {
		params["station_ids"] = req.StationIDs
	}
	return params
}

// DatabaseGetRegions.
//
// Returns a list of regions.
//
// https://vk.com/dev/database.getRegions
type DatabaseGetRegions struct {
	CountryID int64  // Country ID, received in [vk.com/dev/database.getCountries|database.getCountries] method.
	Q         string // Search query.
	Offset    int64  // Offset needed to return specific subset of regions.
	Count     int64  // Number of regions to return.
}

func (req DatabaseGetRegions) params() Params {
	params := make(Params)
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DatabaseGetSchoolClasses.
//
// Returns a list of school classes specified for the country.
//
// https://vk.com/dev/database.getSchoolClasses
type DatabaseGetSchoolClasses struct {
	CountryID int64 // Country ID.
}

func (req DatabaseGetSchoolClasses) params() Params {
	params := make(Params)
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	return params
}

// DatabaseGetSchools.
//
// Returns a list of schools.
//
// https://vk.com/dev/database.getSchools
type DatabaseGetSchools struct {
	Q      string // Search query.
	CityID int64  // City ID.
	Offset int64  // Offset needed to return a specific subset of schools.
	Count  int64  // Number of schools to return.
}

func (req DatabaseGetSchools) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DatabaseGetUniversities.
//
// Returns a list of higher education institutions.
//
// https://vk.com/dev/database.getUniversities
type DatabaseGetUniversities struct {
	Q         string // Search query.
	CountryID int64  // Country ID.
	CityID    int64  // City ID.
	Offset    int64  // Offset needed to return a specific subset of universities.
	Count     int64  // Number of universities to return.
}

func (req DatabaseGetUniversities) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// DocsAdd.
//
// Copies a document to a user's or community's document list.
//
// https://vk.com/dev/docs.add
type DocsAdd struct {
	OwnerID   int64  // ID of the user or community that owns the document. Use a negative value to designate a community ID.
	DocID     int64  // Document ID.
	AccessKey string // Access key. This parameter is required if 'access_key' was returned with the document's data.
}

func (req DocsAdd) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.DocID != 0 {
		params["doc_id"] = req.DocID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// DocsDelete.
//
// Deletes a user or community document.
//
// https://vk.com/dev/docs.delete
type DocsDelete struct {
	OwnerID int64 // ID of the user or community that owns the document. Use a negative value to designate a community ID.
	DocID   int64 // Document ID.
}

func (req DocsDelete) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.DocID != 0 {
		params["doc_id"] = req.DocID
	}
	return params
}

// DocsEdit.
//
// Edits a document.
//
// https://vk.com/dev/docs.edit
type DocsEdit struct {
	OwnerID int64    // User ID or community ID. Use a negative value to designate a community ID.
	DocID   int64    // Document ID.
	Title   string   // Document title.
	Tags    []string // Document tags.
}

func (req DocsEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.DocID != 0 {
		params["doc_id"] = req.DocID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if len(req.Tags) > 0 {
		params["tags"] = req.Tags
	}
	return params
}

// DocsGet.
//
// Returns detailed information about user or community documents.
//
// https://vk.com/dev/docs.get
type DocsGet struct {
	Count      int64 // Number of documents to return. By default, all documents.
	Offset     int64 // Offset needed to return a specific subset of documents.
	Type       int64
	OwnerID    int64 // ID of the user or community that owns the documents. Use a negative value to designate a community ID.
	ReturnTags bool
}

func (req DocsGet) params() Params {
	params := make(Params)
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Type != 0 {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ReturnTags {
		params["return_tags"] = req.ReturnTags
	}
	return params
}

// DocsGetByID.
//
// Returns information about documents by their IDs.
//
// https://vk.com/dev/docs.getById
type DocsGetByID struct {
	Docs       []string // Document IDs. Example: , "66748_91488,66748_91455",
	ReturnTags bool
}

func (req DocsGetByID) params() Params {
	params := make(Params)
	if len(req.Docs) > 0 {
		params["docs"] = req.Docs
	}
	if req.ReturnTags {
		params["return_tags"] = req.ReturnTags
	}
	return params
}

// DocsGetMessagesUploadServer.
//
// Returns the server address for document upload.
//
// https://vk.com/dev/docs.getMessagesUploadServer
type DocsGetMessagesUploadServer struct {
	Type   string // Document type.
	PeerID int64  // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
}

func (req DocsGetMessagesUploadServer) params() Params {
	params := make(Params)
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	return params
}

// DocsGetTypes.
//
// Returns documents types available for current user.
//
// https://vk.com/dev/docs.getTypes
type DocsGetTypes struct {
	OwnerID int64 // ID of the user or community that owns the documents. Use a negative value to designate a community ID.
}

func (req DocsGetTypes) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// DocsGetUploadServer.
//
// Returns the server address for document upload.
//
// https://vk.com/dev/docs.getUploadServer
type DocsGetUploadServer struct {
	GroupID int64 // Community ID (if the document will be uploaded to the community).
}

func (req DocsGetUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// DocsGetWallUploadServer.
//
// Returns the server address for document upload onto a user's or community's wall.
//
// https://vk.com/dev/docs.getWallUploadServer
type DocsGetWallUploadServer struct {
	GroupID int64 // Community ID (if the document will be uploaded to the community).
}

func (req DocsGetWallUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// DocsSave.
//
// Saves a document after [vk.com/dev/upload_files_2|uploading it to a server].
//
// https://vk.com/dev/docs.save
type DocsSave struct {
	File       string // This parameter is returned when the file is [vk.com/dev/upload_files_2|uploaded to the server].
	Title      string // Document title.
	Tags       string // Document tags.
	ReturnTags bool
}

func (req DocsSave) params() Params {
	params := make(Params)
	if req.File != "" {
		params["file"] = req.File
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Tags != "" {
		params["tags"] = req.Tags
	}
	if req.ReturnTags {
		params["return_tags"] = req.ReturnTags
	}
	return params
}

// DocsSearch.
//
// Returns a list of documents matching the search criteria.
//
// https://vk.com/dev/docs.search
type DocsSearch struct {
	Q          string // Search query string.
	SearchOwn  bool
	Count      int64 // Number of results to return.
	Offset     int64 // Offset needed to return a specific subset of results.
	ReturnTags bool
}

func (req DocsSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.SearchOwn {
		params["search_own"] = req.SearchOwn
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.ReturnTags {
		params["return_tags"] = req.ReturnTags
	}
	return params
}

// DownloadedGamesGetPaidStatus.
//
// https://vk.com/dev/downloadedGames.getPaidStatus
type DownloadedGamesGetPaidStatus struct {
	UserID int64
}

func (req DownloadedGamesGetPaidStatus) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// FaveAddArticle.
//
// https://vk.com/dev/fave.addArticle
type FaveAddArticle struct {
	URL string
}

func (req FaveAddArticle) params() Params {
	params := make(Params)
	if req.URL != "" {
		params["url"] = req.URL
	}
	return params
}

// FaveAddLink.
//
// Adds a link to user faves.
//
// https://vk.com/dev/fave.addLink
type FaveAddLink struct {
	Link string // Link URL.
}

func (req FaveAddLink) params() Params {
	params := make(Params)
	if req.Link != "" {
		params["link"] = req.Link
	}
	return params
}

// FaveAddPage.
//
// https://vk.com/dev/fave.addPage
type FaveAddPage struct {
	UserID  int64
	GroupID int64
}

func (req FaveAddPage) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// FaveAddPost.
//
// https://vk.com/dev/fave.addPost
type FaveAddPost struct {
	OwnerID   int64
	ID        int64
	AccessKey string
}

func (req FaveAddPost) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ID != 0 {
		params["id"] = req.ID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// FaveAddProduct.
//
// https://vk.com/dev/fave.addProduct
type FaveAddProduct struct {
	OwnerID   int64
	ID        int64
	AccessKey string
}

func (req FaveAddProduct) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ID != 0 {
		params["id"] = req.ID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// FaveAddTag.
//
// https://vk.com/dev/fave.addTag
type FaveAddTag struct {
	Name     string
	Position string
}

func (req FaveAddTag) params() Params {
	params := make(Params)
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Position != "" {
		params["position"] = req.Position
	}
	return params
}

// FaveAddVideo.
//
// https://vk.com/dev/fave.addVideo
type FaveAddVideo struct {
	OwnerID   int64
	ID        int64
	AccessKey string
}

func (req FaveAddVideo) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ID != 0 {
		params["id"] = req.ID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// FaveEditTag.
//
// https://vk.com/dev/fave.editTag
type FaveEditTag struct {
	ID   int64
	Name string
}

func (req FaveEditTag) params() Params {
	params := make(Params)
	if req.ID != 0 {
		params["id"] = req.ID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	return params
}

// FaveGet.
//
// https://vk.com/dev/fave.get
type FaveGet struct {
	Extended       bool // '1' — to return additional 'wall', 'profiles', and 'groups' fields. By default: '0'.
	ItemType       string
	TagID          int64 // Tag ID.
	Offset         int64 // Offset needed to return a specific subset of users.
	Count          int64 // Number of users to return.
	Fields         string
	IsFromSnackbar bool
}

func (req FaveGet) params() Params {
	params := make(Params)
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.ItemType != "" {
		params["item_type"] = req.ItemType
	}
	if req.TagID != 0 {
		params["tag_id"] = req.TagID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Fields != "" {
		params["fields"] = req.Fields
	}
	if req.IsFromSnackbar {
		params["is_from_snackbar"] = req.IsFromSnackbar
	}
	return params
}

// FaveGetPages.
//
// https://vk.com/dev/fave.getPages
type FaveGetPages struct {
	Offset int64
	Count  int64
	Type   string
	Fields []BaseUserGroupFields
	TagID  int64
}

func (req FaveGetPages) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.TagID != 0 {
		params["tag_id"] = req.TagID
	}
	return params
}

// FaveGetTags.
//
// https://vk.com/dev/fave.getTags
type FaveGetTags struct {
}

func (req FaveGetTags) params() Params {
	params := make(Params)
	return params
}

// FaveMarkSeen.
//
// https://vk.com/dev/fave.markSeen
type FaveMarkSeen struct {
}

func (req FaveMarkSeen) params() Params {
	params := make(Params)
	return params
}

// FaveRemoveArticle.
//
// https://vk.com/dev/fave.removeArticle
type FaveRemoveArticle struct {
	OwnerID   int64
	ArticleID int64
}

func (req FaveRemoveArticle) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ArticleID != 0 {
		params["article_id"] = req.ArticleID
	}
	return params
}

// FaveRemoveLink.
//
// Removes link from the user's faves.
//
// https://vk.com/dev/fave.removeLink
type FaveRemoveLink struct {
	LinkID string // Link ID (can be obtained by [vk.com/dev/faves.getLinks|faves.getLinks] method).
	Link   string // Link URL
}

func (req FaveRemoveLink) params() Params {
	params := make(Params)
	if req.LinkID != "" {
		params["link_id"] = req.LinkID
	}
	if req.Link != "" {
		params["link"] = req.Link
	}
	return params
}

// FaveRemovePage.
//
// https://vk.com/dev/fave.removePage
type FaveRemovePage struct {
	UserID  int64
	GroupID int64
}

func (req FaveRemovePage) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// FaveRemovePost.
//
// https://vk.com/dev/fave.removePost
type FaveRemovePost struct {
	OwnerID int64
	ID      int64
}

func (req FaveRemovePost) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ID != 0 {
		params["id"] = req.ID
	}
	return params
}

// FaveRemoveProduct.
//
// https://vk.com/dev/fave.removeProduct
type FaveRemoveProduct struct {
	OwnerID int64
	ID      int64
}

func (req FaveRemoveProduct) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ID != 0 {
		params["id"] = req.ID
	}
	return params
}

// FaveRemoveTag.
//
// https://vk.com/dev/fave.removeTag
type FaveRemoveTag struct {
	ID int64
}

func (req FaveRemoveTag) params() Params {
	params := make(Params)
	if req.ID != 0 {
		params["id"] = req.ID
	}
	return params
}

// FaveReorderTags.
//
// https://vk.com/dev/fave.reorderTags
type FaveReorderTags struct {
	IDs []int64
}

func (req FaveReorderTags) params() Params {
	params := make(Params)
	if len(req.IDs) > 0 {
		params["ids"] = req.IDs
	}
	return params
}

// FaveSetPageTags.
//
// https://vk.com/dev/fave.setPageTags
type FaveSetPageTags struct {
	UserID  int64
	GroupID int64
	TagIDs  []int64
}

func (req FaveSetPageTags) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if len(req.TagIDs) > 0 {
		params["tag_ids"] = req.TagIDs
	}
	return params
}

// FaveSetTags.
//
// https://vk.com/dev/fave.setTags
type FaveSetTags struct {
	ItemType    string
	ItemOwnerID int64
	ItemID      int64
	TagIDs      []int64
	LinkID      string
	LinkURL     string
}

func (req FaveSetTags) params() Params {
	params := make(Params)
	if req.ItemType != "" {
		params["item_type"] = req.ItemType
	}
	if req.ItemOwnerID != 0 {
		params["item_owner_id"] = req.ItemOwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if len(req.TagIDs) > 0 {
		params["tag_ids"] = req.TagIDs
	}
	if req.LinkID != "" {
		params["link_id"] = req.LinkID
	}
	if req.LinkURL != "" {
		params["link_url"] = req.LinkURL
	}
	return params
}

// FaveTrackPageInteraction.
//
// https://vk.com/dev/fave.trackPageInteraction
type FaveTrackPageInteraction struct {
	UserID  int64
	GroupID int64
}

func (req FaveTrackPageInteraction) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// FriendsAdd.
//
// Approves or creates a friend request.
//
// https://vk.com/dev/friends.add
type FriendsAdd struct {
	UserID int64  // ID of the user whose friend request will be approved or to whom a friend request will be sent.
	Text   string // Text of the message (up to 500 characters) for the friend request, if any.
	Follow bool   // '1' to pass an incoming request to followers list.
}

func (req FriendsAdd) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	if req.Follow {
		params["follow"] = req.Follow
	}
	return params
}

// FriendsAddList.
//
// Creates a new friend list for the current user.
//
// https://vk.com/dev/friends.addList
type FriendsAddList struct {
	Name    string  // Name of the friend list.
	UserIDs []int64 // IDs of users to be added to the friend list.
}

func (req FriendsAddList) params() Params {
	params := make(Params)
	if req.Name != "" {
		params["name"] = req.Name
	}
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	return params
}

// FriendsAreFriends.
//
// Checks the current user's friendship status with other specified users.
//
// https://vk.com/dev/friends.areFriends
type FriendsAreFriends struct {
	UserIDs  []int64 // IDs of the users whose friendship status to check.
	NeedSign bool    // '1' — to return 'sign' field. 'sign' is md5("{id}_{user_id}_{friends_status}_{application_secret}"), where id is current user ID. This field allows to check that data has not been modified by the client. By default: '0'.
	Extended bool    // Return friend request read_state field
}

func (req FriendsAreFriends) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.NeedSign {
		params["need_sign"] = req.NeedSign
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// FriendsDelete.
//
// Declines a friend request or deletes a user from the current user's friend list.
//
// https://vk.com/dev/friends.delete
type FriendsDelete struct {
	UserID int64 // ID of the user whose friend request is to be declined or who is to be deleted from the current user's friend list.
}

func (req FriendsDelete) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// FriendsDeleteAllRequests.
//
// Marks all incoming friend requests as viewed.
//
// https://vk.com/dev/friends.deleteAllRequests
type FriendsDeleteAllRequests struct {
}

func (req FriendsDeleteAllRequests) params() Params {
	params := make(Params)
	return params
}

// FriendsDeleteList.
//
// Deletes a friend list of the current user.
//
// https://vk.com/dev/friends.deleteList
type FriendsDeleteList struct {
	ListID int64 // ID of the friend list to delete.
}

func (req FriendsDeleteList) params() Params {
	params := make(Params)
	if req.ListID != 0 {
		params["list_id"] = req.ListID
	}
	return params
}

// FriendsEdit.
//
// Edits the friend lists of the selected user.
//
// https://vk.com/dev/friends.edit
type FriendsEdit struct {
	UserID  int64   // ID of the user whose friend list is to be edited.
	ListIDs []int64 // IDs of the friend lists to which to add the user.
}

func (req FriendsEdit) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if len(req.ListIDs) > 0 {
		params["list_ids"] = req.ListIDs
	}
	return params
}

// FriendsEditList.
//
// Edits a friend list of the current user.
//
// https://vk.com/dev/friends.editList
type FriendsEditList struct {
	Name          string  // Name of the friend list.
	ListID        int64   // Friend list ID.
	UserIDs       []int64 // IDs of users in the friend list.
	AddUserIDs    []int64 // (Applies if 'user_ids' parameter is not set.), User IDs to add to the friend list.
	DeleteUserIDs []int64 // (Applies if 'user_ids' parameter is not set.), User IDs to delete from the friend list.
}

func (req FriendsEditList) params() Params {
	params := make(Params)
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.ListID != 0 {
		params["list_id"] = req.ListID
	}
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if len(req.AddUserIDs) > 0 {
		params["add_user_ids"] = req.AddUserIDs
	}
	if len(req.DeleteUserIDs) > 0 {
		params["delete_user_ids"] = req.DeleteUserIDs
	}
	return params
}

// FriendsGet.
//
// Returns a list of user IDs or detailed information about a user's friends.
//
// https://vk.com/dev/friends.get
type FriendsGet struct {
	UserID   int64         // User ID. By default, the current user ID.
	Order    string        // Sort order: , 'name' — by name (enabled only if the 'fields' parameter is used), 'hints' — by rating, similar to how friends are sorted in My friends section, , This parameter is available only for [vk.com/dev/standalone|desktop applications].
	ListID   int64         // ID of the friend list returned by the [vk.com/dev/friends.getLists|friends.getLists] method to be used as the source. This parameter is taken into account only when the uid parameter is set to the current user ID. This parameter is available only for [vk.com/dev/standalone|desktop applications].
	Count    int64         // Number of friends to return.
	Offset   int64         // Offset needed to return a specific subset of friends.
	Fields   []UsersFields // Profile fields to return. Sample values: 'uid', 'first_name', 'last_name', 'nickname', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'domain', 'has_mobile', 'rate', 'contacts', 'education'.
	NameCase string        // Case for declension of user name and surname: , 'nom' — nominative (default) , 'gen' — genitive , 'dat' — dative , 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	Ref      string
}

func (req FriendsGet) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Order != "" {
		params["order"] = req.Order
	}
	if req.ListID != 0 {
		params["list_id"] = req.ListID
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	if req.Ref != "" {
		params["ref"] = req.Ref
	}
	return params
}

// FriendsGetAppUsers.
//
// Returns a list of IDs of the current user's friends who installed the application.
//
// https://vk.com/dev/friends.getAppUsers
type FriendsGetAppUsers struct {
}

func (req FriendsGetAppUsers) params() Params {
	params := make(Params)
	return params
}

// FriendsGetByPhones.
//
// Returns a list of the current user's friends whose phone numbers, validated or specified in a profile, are in a given list.
//
// https://vk.com/dev/friends.getByPhones
type FriendsGetByPhones struct {
	Phones []string      // List of phone numbers in MSISDN format (maximum 1000). Example: "+79219876543,+79111234567"
	Fields []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'rate', 'contacts', 'education', 'online, counters'.
}

func (req FriendsGetByPhones) params() Params {
	params := make(Params)
	if len(req.Phones) > 0 {
		params["phones"] = req.Phones
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// FriendsGetLists.
//
// Returns a list of the user's friend lists.
//
// https://vk.com/dev/friends.getLists
type FriendsGetLists struct {
	UserID       int64 // User ID.
	ReturnSystem bool  // '1' — to return system friend lists. By default: '0'.
}

func (req FriendsGetLists) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.ReturnSystem {
		params["return_system"] = req.ReturnSystem
	}
	return params
}

// FriendsGetMutual.
//
// Returns a list of user IDs of the mutual friends of two users.
//
// https://vk.com/dev/friends.getMutual
type FriendsGetMutual struct {
	SourceUid  int64   // ID of the user whose friends will be checked against the friends of the user specified in 'target_uid'.
	TargetUid  int64   // ID of the user whose friends will be checked against the friends of the user specified in 'source_uid'.
	TargetUids []int64 // IDs of the users whose friends will be checked against the friends of the user specified in 'source_uid'.
	Order      string  // Sort order: 'random' — random order
	Count      int64   // Number of mutual friends to return.
	Offset     int64   // Offset needed to return a specific subset of mutual friends.
}

func (req FriendsGetMutual) params() Params {
	params := make(Params)
	if req.SourceUid != 0 {
		params["source_uid"] = req.SourceUid
	}
	if req.TargetUid != 0 {
		params["target_uid"] = req.TargetUid
	}
	if len(req.TargetUids) > 0 {
		params["target_uids"] = req.TargetUids
	}
	if req.Order != "" {
		params["order"] = req.Order
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// FriendsGetOnline.
//
// Returns a list of user IDs of a user's friends who are online.
//
// https://vk.com/dev/friends.getOnline
type FriendsGetOnline struct {
	UserID       int64  // User ID.
	ListID       int64  // Friend list ID. If this parameter is not set, information about all online friends is returned.
	OnlineMobile bool   // '1' — to return an additional 'online_mobile' field, '0' — (default),
	Order        string // Sort order: 'random' — random order
	Count        int64  // Number of friends to return.
	Offset       int64  // Offset needed to return a specific subset of friends.
}

func (req FriendsGetOnline) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.ListID != 0 {
		params["list_id"] = req.ListID
	}
	if req.OnlineMobile {
		params["online_mobile"] = req.OnlineMobile
	}
	if req.Order != "" {
		params["order"] = req.Order
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// FriendsGetRecent.
//
// Returns a list of user IDs of the current user's recently added friends.
//
// https://vk.com/dev/friends.getRecent
type FriendsGetRecent struct {
	Count int64 // Number of recently added friends to return.
}

func (req FriendsGetRecent) params() Params {
	params := make(Params)
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// FriendsGetRequests.
//
// Returns information about the current user's incoming and outgoing friend requests.
//
// https://vk.com/dev/friends.getRequests
type FriendsGetRequests struct {
	Offset     int64 // Offset needed to return a specific subset of friend requests.
	Count      int64 // Number of friend requests to return (default 100, maximum 1000).
	Extended   bool  // '1' — to return response messages from users who have sent a friend request or, if 'suggested' is set to '1', to return a list of suggested friends
	NeedMutual bool  // '1' — to return a list of mutual friends (up to 20), if any
	Out        bool  // '1' — to return outgoing requests, '0' — to return incoming requests (default)
	Sort       int64 // Sort order: '1' — by number of mutual friends, '0' — by date
	NeedViewed bool
	Suggested  bool // '1' — to return a list of suggested friends, '0' — to return friend requests (default)
	Ref        string
	Fields     []UsersFields
}

func (req FriendsGetRequests) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.NeedMutual {
		params["need_mutual"] = req.NeedMutual
	}
	if req.Out {
		params["out"] = req.Out
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.NeedViewed {
		params["need_viewed"] = req.NeedViewed
	}
	if req.Suggested {
		params["suggested"] = req.Suggested
	}
	if req.Ref != "" {
		params["ref"] = req.Ref
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// FriendsGetSuggestions.
//
// Returns a list of profiles of users whom the current user may know.
//
// https://vk.com/dev/friends.getSuggestions
type FriendsGetSuggestions struct {
	Filter   []string      // Types of potential friends to return: 'mutual' — users with many mutual friends , 'contacts' — users found with the [vk.com/dev/account.importContacts|account.importContacts] method , 'mutual_contacts' — users who imported the same contacts as the current user with the [vk.com/dev/account.importContacts|account.importContacts] method
	Count    int64         // Number of suggestions to return.
	Offset   int64         // Offset needed to return a specific subset of suggestions.
	Fields   []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'rate', 'contacts', 'education', 'online', 'counters'.
	NameCase string        // Case for declension of user name and surname: , 'nom' — nominative (default) , 'gen' — genitive , 'dat' — dative , 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
}

func (req FriendsGetSuggestions) params() Params {
	params := make(Params)
	if len(req.Filter) > 0 {
		params["filter"] = req.Filter
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// FriendsSearch.
//
// Returns a list of friends matching the search criteria.
//
// https://vk.com/dev/friends.search
type FriendsSearch struct {
	UserID   int64         // User ID.
	Q        string        // Search query string (e.g., 'Vasya Babich').
	Fields   []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'rate', 'contacts', 'education', 'online',
	NameCase string        // Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	Offset   int64         // Offset needed to return a specific subset of friends.
	Count    int64         // Number of friends to return.
}

func (req FriendsSearch) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Q != "" {
		params["q"] = req.Q
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// GiftsGet.
//
// Returns a list of user gifts.
//
// https://vk.com/dev/gifts.get
type GiftsGet struct {
	UserID int64 // User ID.
	Count  int64 // Number of gifts to return.
	Offset int64 // Offset needed to return a specific subset of results.
}

func (req GiftsGet) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// GroupsAddAddress.
//
// https://vk.com/dev/groups.addAddress
type GroupsAddAddress struct {
	GroupID           int64
	Title             string
	Address           string
	AdditionalAddress string
	CountryID         int64
	CityID            int64
	MetroID           int64
	Latitude          float64
	Longitude         float64
	Phone             string
	WorkInfoStatus    *GroupsAddressWorkInfoStatus
	Timetable         string
	IsMainAddress     bool
}

func (req GroupsAddAddress) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Address != "" {
		params["address"] = req.Address
	}
	if req.AdditionalAddress != "" {
		params["additional_address"] = req.AdditionalAddress
	}
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.MetroID != 0 {
		params["metro_id"] = req.MetroID
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.Phone != "" {
		params["phone"] = req.Phone
	}
	if req.WorkInfoStatus != nil {
		params["work_info_status"] = req.WorkInfoStatus
	}
	if req.Timetable != "" {
		params["timetable"] = req.Timetable
	}
	if req.IsMainAddress {
		params["is_main_address"] = req.IsMainAddress
	}
	return params
}

// GroupsAddCallbackServer.
//
// https://vk.com/dev/groups.addCallbackServer
type GroupsAddCallbackServer struct {
	GroupID   int64
	URL       string
	Title     string
	SecretKey string
}

func (req GroupsAddCallbackServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.URL != "" {
		params["url"] = req.URL
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.SecretKey != "" {
		params["secret_key"] = req.SecretKey
	}
	return params
}

// GroupsAddLink.
//
// Allows to add a link to the community.
//
// https://vk.com/dev/groups.addLink
type GroupsAddLink struct {
	GroupID int64  // Community ID.
	Link    string // Link URL.
	Text    string // Description text for the link.
}

func (req GroupsAddLink) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Link != "" {
		params["link"] = req.Link
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	return params
}

// GroupsApproveRequest.
//
// Allows to approve join request to the community.
//
// https://vk.com/dev/groups.approveRequest
type GroupsApproveRequest struct {
	GroupID int64 // Community ID.
	UserID  int64 // User ID.
}

func (req GroupsApproveRequest) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// GroupsBan.
//
// https://vk.com/dev/groups.ban
type GroupsBan struct {
	GroupID        int64
	OwnerID        int64
	EndDate        int64
	Reason         int64
	Comment        string
	CommentVisible bool
}

func (req GroupsBan) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.EndDate != 0 {
		params["end_date"] = req.EndDate
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	if req.Comment != "" {
		params["comment"] = req.Comment
	}
	if req.CommentVisible {
		params["comment_visible"] = req.CommentVisible
	}
	return params
}

// GroupsCreate.
//
// Creates a new community.
//
// https://vk.com/dev/groups.create
type GroupsCreate struct {
	Title          string // Community title.
	Description    string // Community description (ignored for 'type' = 'public').
	Type           string // Community type. Possible values: *'group' – group,, *'event' – event,, *'public' – public page
	PublicCategory int64  // Category ID (for 'type' = 'public' only).
	Subtype        int64  // Public page subtype. Possible values: *'1' – place or small business,, *'2' – company, organization or website,, *'3' – famous person or group of people,, *'4' – product or work of art.
}

func (req GroupsCreate) params() Params {
	params := make(Params)
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.PublicCategory != 0 {
		params["public_category"] = req.PublicCategory
	}
	if req.Subtype != 0 {
		params["subtype"] = req.Subtype
	}
	return params
}

// GroupsDeleteCallbackServer.
//
// https://vk.com/dev/groups.deleteCallbackServer
type GroupsDeleteCallbackServer struct {
	GroupID  int64
	ServerID int64
}

func (req GroupsDeleteCallbackServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.ServerID != 0 {
		params["server_id"] = req.ServerID
	}
	return params
}

// GroupsDeleteLink.
//
// Allows to delete a link from the community.
//
// https://vk.com/dev/groups.deleteLink
type GroupsDeleteLink struct {
	GroupID int64 // Community ID.
	LinkID  int64 // Link ID.
}

func (req GroupsDeleteLink) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.LinkID != 0 {
		params["link_id"] = req.LinkID
	}
	return params
}

// GroupsDisableOnline.
//
// https://vk.com/dev/groups.disableOnline
type GroupsDisableOnline struct {
	GroupID int64
}

func (req GroupsDisableOnline) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsEdit.
//
// Edits a community.
//
// https://vk.com/dev/groups.edit
type GroupsEdit struct {
	GroupID           int64               // Community ID.
	Title             string              // Community title.
	Description       string              // Community description.
	ScreenName        string              // Community screen name.
	Access            *GroupsGroupAccess  // Community type. Possible values: *'0' – open,, *'1' – closed,, *'2' – private.
	Website           string              // Website that will be displayed in the community information field.
	Subject           *GroupsGroupSubject // Community subject. Possible values: , *'1' – auto/moto,, *'2' – activity holidays,, *'3' – business,, *'4' – pets,, *'5' – health,, *'6' – dating and communication, , *'7' – games,, *'8' – IT (computers and software),, *'9' – cinema,, *'10' – beauty and fashion,, *'11' – cooking,, *'12' – art and culture,, *'13' – literature,, *'14' – mobile services and internet,, *'15' – music,, *'16' – science and technology,, *'17' – real estate,, *'18' – news and media,, *'19' – security,, *'20' – education,, *'21' – home and renovations,, *'22' – politics,, *'23' – food,, *'24' – industry,, *'25' – travel,, *'26' – work,, *'27' – entertainment,, *'28' – religion,, *'29' – family,, *'30' – sports,, *'31' – insurance,, *'32' – television,, *'33' – goods and services,, *'34' – hobbies,, *'35' – finance,, *'36' – photo,, *'37' – esoterics,, *'38' – electronics and appliances,, *'39' – erotic,, *'40' – humor,, *'41' – society, humanities,, *'42' – design and graphics.
	Email             string              // Organizer email (for events).
	Phone             string              // Organizer phone number (for events).
	Rss               string              // RSS feed address for import (available only to communities with special permission. Contact vk.com/support to get it.
	EventStartDate    int64               // Event start date in Unixtime format.
	EventFinishDate   int64               // Event finish date in Unixtime format.
	EventGroupID      int64               // Organizer community ID (for events only).
	PublicCategory    int64               // Public page category ID.
	PublicSubcategory int64               // Public page subcategory ID.
	PublicDate        string              // Founding date of a company or organization owning the community in "dd.mm.YYYY" format.
	Wall              *GroupsGroupWall    // Wall settings. Possible values: *'0' – disabled,, *'1' – open,, *'2' – limited (groups and events only),, *'3' – closed (groups and events only).
	Topics            *GroupsGroupTopics  // Board topics settings. Possbile values: , *'0' – disabled,, *'1' – open,, *'2' – limited (for groups and events only).
	Photos            *GroupsGroupPhotos  // Photos settings. Possible values: *'0' – disabled,, *'1' – open,, *'2' – limited (for groups and events only).
	Video             *GroupsGroupVideo   // Video settings. Possible values: *'0' – disabled,, *'1' – open,, *'2' – limited (for groups and events only).
	Audio             *GroupsGroupAudio   // Audio settings. Possible values: *'0' – disabled,, *'1' – open,, *'2' – limited (for groups and events only).
	Links             bool                // Links settings (for public pages only). Possible values: *'0' – disabled,, *'1' – enabled.
	Events            bool                // Events settings (for public pages only). Possible values: *'0' – disabled,, *'1' – enabled.
	Places            bool                // Places settings (for public pages only). Possible values: *'0' – disabled,, *'1' – enabled.
	Contacts          bool                // Contacts settings (for public pages only). Possible values: *'0' – disabled,, *'1' – enabled.
	Docs              *GroupsGroupDocs    // Documents settings. Possible values: *'0' – disabled,, *'1' – open,, *'2' – limited (for groups and events only).
	Wiki              *GroupsGroupWiki    // Wiki pages settings. Possible values: *'0' – disabled,, *'1' – open,, *'2' – limited (for groups and events only).
	Messages          bool                // Community messages. Possible values: *'0' — disabled,, *'1' — enabled.
	Articles          bool
	Addresses         bool
	AgeLimits         *GroupsGroupAgeLimits      // Community age limits. Possible values: *'1' — no limits,, *'2' — 16+,, *'3' — 18+.
	Market            bool                       // Market settings. Possible values: *'0' – disabled,, *'1' – enabled.
	MarketComments    bool                       // market comments settings. Possible values: *'0' – disabled,, *'1' – enabled.
	MarketCountry     []int64                    // Market delivery countries.
	MarketCity        []int64                    // Market delivery cities (if only one country is specified).
	MarketCurrency    *GroupsGroupMarketCurrency // Market currency settings. Possbile values: , *'643' – Russian rubles,, *'980' – Ukrainian hryvnia,, *'398' – Kazakh tenge,, *'978' – Euro,, *'840' – US dollars
	MarketContact     int64                      // Seller contact for market. Set '0' for community messages.
	MarketWiki        int64                      // ID of a wiki page with market description.
	ObsceneFilter     bool                       // Obscene expressions filter in comments. Possible values: , *'0' – disabled,, *'1' – enabled.
	ObsceneStopwords  bool                       // Stopwords filter in comments. Possible values: , *'0' – disabled,, *'1' – enabled.
	ObsceneWords      []string                   // Keywords for stopwords filter.
	MainSection       int64
	SecondarySection  int64
	Country           int64 // Country of the community.
	City              int64 // City of the community.
}

func (req GroupsEdit) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if req.ScreenName != "" {
		params["screen_name"] = req.ScreenName
	}
	if req.Access != nil {
		params["access"] = req.Access
	}
	if req.Website != "" {
		params["website"] = req.Website
	}
	if req.Subject != nil {
		params["subject"] = req.Subject
	}
	if req.Email != "" {
		params["email"] = req.Email
	}
	if req.Phone != "" {
		params["phone"] = req.Phone
	}
	if req.Rss != "" {
		params["rss"] = req.Rss
	}
	if req.EventStartDate != 0 {
		params["event_start_date"] = req.EventStartDate
	}
	if req.EventFinishDate != 0 {
		params["event_finish_date"] = req.EventFinishDate
	}
	if req.EventGroupID != 0 {
		params["event_group_id"] = req.EventGroupID
	}
	if req.PublicCategory != 0 {
		params["public_category"] = req.PublicCategory
	}
	if req.PublicSubcategory != 0 {
		params["public_subcategory"] = req.PublicSubcategory
	}
	if req.PublicDate != "" {
		params["public_date"] = req.PublicDate
	}
	if req.Wall != nil {
		params["wall"] = req.Wall
	}
	if req.Topics != nil {
		params["topics"] = req.Topics
	}
	if req.Photos != nil {
		params["photos"] = req.Photos
	}
	if req.Video != nil {
		params["video"] = req.Video
	}
	if req.Audio != nil {
		params["audio"] = req.Audio
	}
	if req.Links {
		params["links"] = req.Links
	}
	if req.Events {
		params["events"] = req.Events
	}
	if req.Places {
		params["places"] = req.Places
	}
	if req.Contacts {
		params["contacts"] = req.Contacts
	}
	if req.Docs != nil {
		params["docs"] = req.Docs
	}
	if req.Wiki != nil {
		params["wiki"] = req.Wiki
	}
	if req.Messages {
		params["messages"] = req.Messages
	}
	if req.Articles {
		params["articles"] = req.Articles
	}
	if req.Addresses {
		params["addresses"] = req.Addresses
	}
	if req.AgeLimits != nil {
		params["age_limits"] = req.AgeLimits
	}
	if req.Market {
		params["market"] = req.Market
	}
	if req.MarketComments {
		params["market_comments"] = req.MarketComments
	}
	if len(req.MarketCountry) > 0 {
		params["market_country"] = req.MarketCountry
	}
	if len(req.MarketCity) > 0 {
		params["market_city"] = req.MarketCity
	}
	if req.MarketCurrency != nil {
		params["market_currency"] = req.MarketCurrency
	}
	if req.MarketContact != 0 {
		params["market_contact"] = req.MarketContact
	}
	if req.MarketWiki != 0 {
		params["market_wiki"] = req.MarketWiki
	}
	if req.ObsceneFilter {
		params["obscene_filter"] = req.ObsceneFilter
	}
	if req.ObsceneStopwords {
		params["obscene_stopwords"] = req.ObsceneStopwords
	}
	if len(req.ObsceneWords) > 0 {
		params["obscene_words"] = req.ObsceneWords
	}
	if req.MainSection != 0 {
		params["main_section"] = req.MainSection
	}
	if req.SecondarySection != 0 {
		params["secondary_section"] = req.SecondarySection
	}
	if req.Country != 0 {
		params["country"] = req.Country
	}
	if req.City != 0 {
		params["city"] = req.City
	}
	return params
}

// GroupsEditAddress.
//
// https://vk.com/dev/groups.editAddress
type GroupsEditAddress struct {
	GroupID           int64
	AddressID         int64
	Title             string
	Address           string
	AdditionalAddress string
	CountryID         int64
	CityID            int64
	MetroID           int64
	Latitude          float64
	Longitude         float64
	Phone             string
	WorkInfoStatus    *GroupsAddressWorkInfoStatus
	Timetable         string
	IsMainAddress     bool
}

func (req GroupsEditAddress) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.AddressID != 0 {
		params["address_id"] = req.AddressID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Address != "" {
		params["address"] = req.Address
	}
	if req.AdditionalAddress != "" {
		params["additional_address"] = req.AdditionalAddress
	}
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.MetroID != 0 {
		params["metro_id"] = req.MetroID
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.Phone != "" {
		params["phone"] = req.Phone
	}
	if req.WorkInfoStatus != nil {
		params["work_info_status"] = req.WorkInfoStatus
	}
	if req.Timetable != "" {
		params["timetable"] = req.Timetable
	}
	if req.IsMainAddress {
		params["is_main_address"] = req.IsMainAddress
	}
	return params
}

// GroupsEditCallbackServer.
//
// https://vk.com/dev/groups.editCallbackServer
type GroupsEditCallbackServer struct {
	GroupID   int64
	ServerID  int64
	URL       string
	Title     string
	SecretKey string
}

func (req GroupsEditCallbackServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.ServerID != 0 {
		params["server_id"] = req.ServerID
	}
	if req.URL != "" {
		params["url"] = req.URL
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.SecretKey != "" {
		params["secret_key"] = req.SecretKey
	}
	return params
}

// GroupsEditLink.
//
// Allows to edit a link in the community.
//
// https://vk.com/dev/groups.editLink
type GroupsEditLink struct {
	GroupID int64  // Community ID.
	LinkID  int64  // Link ID.
	Text    string // New description text for the link.
}

func (req GroupsEditLink) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.LinkID != 0 {
		params["link_id"] = req.LinkID
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	return params
}

// GroupsEditManager.
//
// Allows to add, remove or edit the community manager.
//
// https://vk.com/dev/groups.editManager
type GroupsEditManager struct {
	GroupID         int64            // Community ID.
	UserID          int64            // User ID.
	Role            *GroupsGroupRole // Manager role. Possible values: *'moderator',, *'editor',, *'administrator',, *'advertiser'.
	IsContact       bool             // '1' — to show the manager in Contacts block of the community.
	ContactPosition string           // Position to show in Contacts block.
	ContactPhone    string           // Contact phone.
	ContactEmail    string           // Contact e-mail.
}

func (req GroupsEditManager) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Role != nil {
		params["role"] = req.Role
	}
	if req.IsContact {
		params["is_contact"] = req.IsContact
	}
	if req.ContactPosition != "" {
		params["contact_position"] = req.ContactPosition
	}
	if req.ContactPhone != "" {
		params["contact_phone"] = req.ContactPhone
	}
	if req.ContactEmail != "" {
		params["contact_email"] = req.ContactEmail
	}
	return params
}

// GroupsEnableOnline.
//
// https://vk.com/dev/groups.enableOnline
type GroupsEnableOnline struct {
	GroupID int64
}

func (req GroupsEnableOnline) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsGet.
//
// Returns a list of the communities to which a user belongs.
//
// https://vk.com/dev/groups.get
type GroupsGet struct {
	UserID   int64          // User ID.
	Extended bool           // '1' — to return complete information about a user's communities, '0' — to return a list of community IDs without any additional fields (default),
	Filter   []GroupsFilter // Types of communities to return: 'admin' — to return communities administered by the user , 'editor' — to return communities where the user is an administrator or editor, 'moder' — to return communities where the user is an administrator, editor, or moderator, 'groups' — to return only groups, 'publics' — to return only public pages, 'events' — to return only events
	Fields   []GroupsFields // Profile fields to return.
	Offset   int64          // Offset needed to return a specific subset of communities.
	Count    int64          // Number of communities to return.
}

func (req GroupsGet) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Filter) > 0 {
		params["filter"] = req.Filter
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// GroupsGetAddresses.
//
// Returns a list of community addresses.
//
// https://vk.com/dev/groups.getAddresses
type GroupsGetAddresses struct {
	GroupID    int64 // ID or screen name of the community.
	AddressIDs []int64
	Latitude   float64           // Latitude of  the user geo position.
	Longitude  float64           // Longitude of the user geo position.
	Offset     int64             // Offset needed to return a specific subset of community addresses.
	Count      int64             // Number of community addresses to return.
	Fields     []AddressesFields // Address fields
}

func (req GroupsGetAddresses) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if len(req.AddressIDs) > 0 {
		params["address_ids"] = req.AddressIDs
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// GroupsGetBanned.
//
// Returns a list of users on a community blacklist.
//
// https://vk.com/dev/groups.getBanned
type GroupsGetBanned struct {
	GroupID int64 // Community ID.
	Offset  int64 // Offset needed to return a specific subset of users.
	Count   int64 // Number of users to return.
	Fields  []BaseUserGroupFields
	OwnerID int64
}

func (req GroupsGetBanned) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// GroupsGetByID.
//
// Returns information about communities by their IDs.
//
// https://vk.com/dev/groups.getById
type GroupsGetByID struct {
	GroupIDs []string       // IDs or screen names of communities.
	GroupID  string         // ID or screen name of the community.
	Fields   []GroupsFields // Group fields to return.
}

func (req GroupsGetByID) params() Params {
	params := make(Params)
	if len(req.GroupIDs) > 0 {
		params["group_ids"] = req.GroupIDs
	}
	if req.GroupID != "" {
		params["group_id"] = req.GroupID
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// GroupsGetCallbackConfirmationCode.
//
// Returns Callback API confirmation code for the community.
//
// https://vk.com/dev/groups.getCallbackConfirmationCode
type GroupsGetCallbackConfirmationCode struct {
	GroupID int64 // Community ID.
}

func (req GroupsGetCallbackConfirmationCode) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsGetCallbackServers.
//
// https://vk.com/dev/groups.getCallbackServers
type GroupsGetCallbackServers struct {
	GroupID   int64
	ServerIDs []int64
}

func (req GroupsGetCallbackServers) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if len(req.ServerIDs) > 0 {
		params["server_ids"] = req.ServerIDs
	}
	return params
}

// GroupsGetCallbackSettings.
//
// Returns [vk.com/dev/callback_api|Callback API] notifications settings.
//
// https://vk.com/dev/groups.getCallbackSettings
type GroupsGetCallbackSettings struct {
	GroupID  int64 // Community ID.
	ServerID int64 // Server ID.
}

func (req GroupsGetCallbackSettings) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.ServerID != 0 {
		params["server_id"] = req.ServerID
	}
	return params
}

// GroupsGetCatalog.
//
// Returns communities list for a catalog category.
//
// https://vk.com/dev/groups.getCatalog
type GroupsGetCatalog struct {
	CategoryID    int64 // Category id received from [vk.com/dev/groups.getCatalogInfo|groups.getCatalogInfo].
	SubcategoryID int64 // Subcategory id received from [vk.com/dev/groups.getCatalogInfo|groups.getCatalogInfo].
}

func (req GroupsGetCatalog) params() Params {
	params := make(Params)
	if req.CategoryID != 0 {
		params["category_id"] = req.CategoryID
	}
	if req.SubcategoryID != 0 {
		params["subcategory_id"] = req.SubcategoryID
	}
	return params
}

// GroupsGetCatalogInfo.
//
// Returns categories list for communities catalog
//
// https://vk.com/dev/groups.getCatalogInfo
type GroupsGetCatalogInfo struct {
	Extended      bool // 1 – to return communities count and three communities for preview. By default: 0.
	Subcategories bool // 1 – to return subcategories info. By default: 0.
}

func (req GroupsGetCatalogInfo) params() Params {
	params := make(Params)
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Subcategories {
		params["subcategories"] = req.Subcategories
	}
	return params
}

// GroupsGetInvitedUsers.
//
// Returns invited users list of a community
//
// https://vk.com/dev/groups.getInvitedUsers
type GroupsGetInvitedUsers struct {
	GroupID  int64         // Group ID to return invited users for.
	Offset   int64         // Offset needed to return a specific subset of results.
	Count    int64         // Number of results to return.
	Fields   []UsersFields // List of additional fields to be returned. Available values: 'sex, bdate, city, country, photo_50, photo_100, photo_200_orig, photo_200, photo_400_orig, photo_max, photo_max_orig, online, online_mobile, lists, domain, has_mobile, contacts, connections, site, education, universities, schools, can_post, can_see_all_posts, can_see_audio, can_write_private_message, status, last_seen, common_count, relation, relatives, counters'.
	NameCase string        // Case for declension of user name and surname. Possible values: *'nom' — nominative (default),, *'gen' — genitive,, *'dat' — dative,, *'acc' — accusative, , *'ins' — instrumental,, *'abl' — prepositional.
}

func (req GroupsGetInvitedUsers) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// GroupsGetInvites.
//
// Returns a list of invitations to join communities and events.
//
// https://vk.com/dev/groups.getInvites
type GroupsGetInvites struct {
	Offset   int64 // Offset needed to return a specific subset of invitations.
	Count    int64 // Number of invitations to return.
	Extended bool  // '1' — to return additional [vk.com/dev/fields_groups|fields] for communities..
}

func (req GroupsGetInvites) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// GroupsGetLongPollServer.
//
// Returns the data needed to query a Long Poll server for events
//
// https://vk.com/dev/groups.getLongPollServer
type GroupsGetLongPollServer struct {
	GroupID int64 // Community ID
}

func (req GroupsGetLongPollServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsGetLongPollSettings.
//
// Returns Long Poll notification settings
//
// https://vk.com/dev/groups.getLongPollSettings
type GroupsGetLongPollSettings struct {
	GroupID int64 // Community ID.
}

func (req GroupsGetLongPollSettings) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsGetMembers.
//
// Returns a list of community members.
//
// https://vk.com/dev/groups.getMembers
type GroupsGetMembers struct {
	GroupID string        // ID or screen name of the community.
	Sort    string        // Sort order. Available values: 'id_asc', 'id_desc', 'time_asc', 'time_desc'. 'time_asc' and 'time_desc' are availavle only if the method is called by the group's 'moderator'.
	Offset  int64         // Offset needed to return a specific subset of community members.
	Count   int64         // Number of community members to return.
	Fields  []UsersFields // List of additional fields to be returned. Available values: 'sex, bdate, city, country, photo_50, photo_100, photo_200_orig, photo_200, photo_400_orig, photo_max, photo_max_orig, online, online_mobile, lists, domain, has_mobile, contacts, connections, site, education, universities, schools, can_post, can_see_all_posts, can_see_audio, can_write_private_message, status, last_seen, common_count, relation, relatives, counters'.
	Filter  string        // *'friends' – only friends in this community will be returned,, *'unsure' – only those who pressed 'I may attend' will be returned (if it's an event).
}

func (req GroupsGetMembers) params() Params {
	params := make(Params)
	if req.GroupID != "" {
		params["group_id"] = req.GroupID
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.Filter != "" {
		params["filter"] = req.Filter
	}
	return params
}

// GroupsGetRequests.
//
// Returns a list of requests to the community.
//
// https://vk.com/dev/groups.getRequests
type GroupsGetRequests struct {
	GroupID int64         // Community ID.
	Offset  int64         // Offset needed to return a specific subset of results.
	Count   int64         // Number of results to return.
	Fields  []UsersFields // Profile fields to return.
}

func (req GroupsGetRequests) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// GroupsGetSettings.
//
// Returns community settings.
//
// https://vk.com/dev/groups.getSettings
type GroupsGetSettings struct {
	GroupID int64 // Community ID.
}

func (req GroupsGetSettings) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsGetTokenPermissions.
//
// https://vk.com/dev/groups.getTokenPermissions
type GroupsGetTokenPermissions struct {
}

func (req GroupsGetTokenPermissions) params() Params {
	params := make(Params)
	return params
}

// GroupsInvite.
//
// Allows to invite friends to the community.
//
// https://vk.com/dev/groups.invite
type GroupsInvite struct {
	GroupID int64 // Community ID.
	UserID  int64 // User ID.
}

func (req GroupsInvite) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// GroupsIsMember.
//
// Returns information specifying whether a user is a member of a community.
//
// https://vk.com/dev/groups.isMember
type GroupsIsMember struct {
	GroupID  string  // ID or screen name of the community.
	UserID   int64   // User ID.
	UserIDs  []int64 // User IDs.
	Extended bool    // '1' — to return an extended response with additional fields. By default: '0'.
}

func (req GroupsIsMember) params() Params {
	params := make(Params)
	if req.GroupID != "" {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// GroupsJoin.
//
// With this method you can join the group or public page, and also confirm your participation in an event.
//
// https://vk.com/dev/groups.join
type GroupsJoin struct {
	GroupID int64  // ID or screen name of the community.
	NotSure string // Optional parameter which is taken into account when 'gid' belongs to the event: '1' — Perhaps I will attend, '0' — I will be there for sure (default), ,
}

func (req GroupsJoin) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.NotSure != "" {
		params["not_sure"] = req.NotSure
	}
	return params
}

// GroupsLeave.
//
// With this method you can leave a group, public page, or event.
//
// https://vk.com/dev/groups.leave
type GroupsLeave struct {
	GroupID int64 // ID or screen name of the community.
}

func (req GroupsLeave) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// GroupsRemoveUser.
//
// Removes a user from the community.
//
// https://vk.com/dev/groups.removeUser
type GroupsRemoveUser struct {
	GroupID int64 // Community ID.
	UserID  int64 // User ID.
}

func (req GroupsRemoveUser) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// GroupsReorderLink.
//
// Allows to reorder links in the community.
//
// https://vk.com/dev/groups.reorderLink
type GroupsReorderLink struct {
	GroupID int64 // Community ID.
	LinkID  int64 // Link ID.
	After   int64 // ID of the link after which to place the link with 'link_id'.
}

func (req GroupsReorderLink) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.LinkID != 0 {
		params["link_id"] = req.LinkID
	}
	if req.After != 0 {
		params["after"] = req.After
	}
	return params
}

// GroupsSearch.
//
// Returns a list of communities matching the search criteria.
//
// https://vk.com/dev/groups.search
type GroupsSearch struct {
	Q         string // Search query string.
	Type      string // Community type. Possible values: 'group, page, event.'
	CountryID int64  // Country ID.
	CityID    int64  // City ID. If this parameter is transmitted, country_id is ignored.
	Future    bool   // '1' — to return only upcoming events. Works with the 'type' = 'event' only.
	Market    bool   // '1' — to return communities with enabled market only.
	Sort      int64  // Sort order. Possible values: *'0' — default sorting (similar the full version of the site),, *'1' — by growth speed,, *'2'— by the "day attendance/members number" ratio,, *'3' — by the "Likes number/members number" ratio,, *'4' — by the "comments number/members number" ratio,, *'5' — by the "boards entries number/members number" ratio.
	Offset    int64  // Offset needed to return a specific subset of results.
	Count     int64  // Number of communities to return. "Note that you can not receive more than first thousand of results, regardless of 'count' and 'offset' values."
}

func (req GroupsSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.CountryID != 0 {
		params["country_id"] = req.CountryID
	}
	if req.CityID != 0 {
		params["city_id"] = req.CityID
	}
	if req.Future {
		params["future"] = req.Future
	}
	if req.Market {
		params["market"] = req.Market
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// GroupsSetCallbackSettings.
//
// Allow to set notifications settings for group.
//
// https://vk.com/dev/groups.setCallbackSettings
type GroupsSetCallbackSettings struct {
	GroupID              int64 // Community ID.
	ServerID             int64 // Server ID.
	ApiVersion           string
	MessageNew           bool // A new incoming message has been received ('0' — disabled, '1' — enabled).
	MessageReply         bool // A new outcoming message has been received ('0' — disabled, '1' — enabled).
	MessageAllow         bool // Allowed messages notifications ('0' — disabled, '1' — enabled).
	MessageEdit          bool
	MessageDeny          bool // Denied messages notifications ('0' — disabled, '1' — enabled).
	MessageTypingState   bool
	PhotoNew             bool // New photos notifications ('0' — disabled, '1' — enabled).
	AudioNew             bool // New audios notifications ('0' — disabled, '1' — enabled).
	VideoNew             bool // New videos notifications ('0' — disabled, '1' — enabled).
	WallReplyNew         bool // New wall replies notifications ('0' — disabled, '1' — enabled).
	WallReplyEdit        bool // Wall replies edited notifications ('0' — disabled, '1' — enabled).
	WallReplyDelete      bool // A wall comment has been deleted ('0' — disabled, '1' — enabled).
	WallReplyRestore     bool // A wall comment has been restored ('0' — disabled, '1' — enabled).
	WallPostNew          bool // New wall posts notifications ('0' — disabled, '1' — enabled).
	WallRepost           bool // New wall posts notifications ('0' — disabled, '1' — enabled).
	BoardPostNew         bool // New board posts notifications ('0' — disabled, '1' — enabled).
	BoardPostEdit        bool // Board posts edited notifications ('0' — disabled, '1' — enabled).
	BoardPostRestore     bool // Board posts restored notifications ('0' — disabled, '1' — enabled).
	BoardPostDelete      bool // Board posts deleted notifications ('0' — disabled, '1' — enabled).
	PhotoCommentNew      bool // New comment to photo notifications ('0' — disabled, '1' — enabled).
	PhotoCommentEdit     bool // A photo comment has been edited ('0' — disabled, '1' — enabled).
	PhotoCommentDelete   bool // A photo comment has been deleted ('0' — disabled, '1' — enabled).
	PhotoCommentRestore  bool // A photo comment has been restored ('0' — disabled, '1' — enabled).
	VideoCommentNew      bool // New comment to video notifications ('0' — disabled, '1' — enabled).
	VideoCommentEdit     bool // A video comment has been edited ('0' — disabled, '1' — enabled).
	VideoCommentDelete   bool // A video comment has been deleted ('0' — disabled, '1' — enabled).
	VideoCommentRestore  bool // A video comment has been restored ('0' — disabled, '1' — enabled).
	MarketCommentNew     bool // New comment to market item notifications ('0' — disabled, '1' — enabled).
	MarketCommentEdit    bool // A market comment has been edited ('0' — disabled, '1' — enabled).
	MarketCommentDelete  bool // A market comment has been deleted ('0' — disabled, '1' — enabled).
	MarketCommentRestore bool // A market comment has been restored ('0' — disabled, '1' — enabled).
	PollVoteNew          bool // A vote in a public poll has been added ('0' — disabled, '1' — enabled).
	GroupJoin            bool // Joined community notifications ('0' — disabled, '1' — enabled).
	GroupLeave           bool // Left community notifications ('0' — disabled, '1' — enabled).
	GroupChangeSettings  bool
	GroupChangePhoto     bool
	GroupOfficersEdit    bool
	UserBlock            bool // User added to community blacklist
	UserUnblock          bool // User removed from community blacklist
	LeadFormsNew         bool // New form in lead forms
	LikeAdd              bool
	LikeRemove           bool
	MessageEvent         bool
}

func (req GroupsSetCallbackSettings) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.ServerID != 0 {
		params["server_id"] = req.ServerID
	}
	if req.ApiVersion != "" {
		params["api_version"] = req.ApiVersion
	}
	if req.MessageNew {
		params["message_new"] = req.MessageNew
	}
	if req.MessageReply {
		params["message_reply"] = req.MessageReply
	}
	if req.MessageAllow {
		params["message_allow"] = req.MessageAllow
	}
	if req.MessageEdit {
		params["message_edit"] = req.MessageEdit
	}
	if req.MessageDeny {
		params["message_deny"] = req.MessageDeny
	}
	if req.MessageTypingState {
		params["message_typing_state"] = req.MessageTypingState
	}
	if req.PhotoNew {
		params["photo_new"] = req.PhotoNew
	}
	if req.AudioNew {
		params["audio_new"] = req.AudioNew
	}
	if req.VideoNew {
		params["video_new"] = req.VideoNew
	}
	if req.WallReplyNew {
		params["wall_reply_new"] = req.WallReplyNew
	}
	if req.WallReplyEdit {
		params["wall_reply_edit"] = req.WallReplyEdit
	}
	if req.WallReplyDelete {
		params["wall_reply_delete"] = req.WallReplyDelete
	}
	if req.WallReplyRestore {
		params["wall_reply_restore"] = req.WallReplyRestore
	}
	if req.WallPostNew {
		params["wall_post_new"] = req.WallPostNew
	}
	if req.WallRepost {
		params["wall_repost"] = req.WallRepost
	}
	if req.BoardPostNew {
		params["board_post_new"] = req.BoardPostNew
	}
	if req.BoardPostEdit {
		params["board_post_edit"] = req.BoardPostEdit
	}
	if req.BoardPostRestore {
		params["board_post_restore"] = req.BoardPostRestore
	}
	if req.BoardPostDelete {
		params["board_post_delete"] = req.BoardPostDelete
	}
	if req.PhotoCommentNew {
		params["photo_comment_new"] = req.PhotoCommentNew
	}
	if req.PhotoCommentEdit {
		params["photo_comment_edit"] = req.PhotoCommentEdit
	}
	if req.PhotoCommentDelete {
		params["photo_comment_delete"] = req.PhotoCommentDelete
	}
	if req.PhotoCommentRestore {
		params["photo_comment_restore"] = req.PhotoCommentRestore
	}
	if req.VideoCommentNew {
		params["video_comment_new"] = req.VideoCommentNew
	}
	if req.VideoCommentEdit {
		params["video_comment_edit"] = req.VideoCommentEdit
	}
	if req.VideoCommentDelete {
		params["video_comment_delete"] = req.VideoCommentDelete
	}
	if req.VideoCommentRestore {
		params["video_comment_restore"] = req.VideoCommentRestore
	}
	if req.MarketCommentNew {
		params["market_comment_new"] = req.MarketCommentNew
	}
	if req.MarketCommentEdit {
		params["market_comment_edit"] = req.MarketCommentEdit
	}
	if req.MarketCommentDelete {
		params["market_comment_delete"] = req.MarketCommentDelete
	}
	if req.MarketCommentRestore {
		params["market_comment_restore"] = req.MarketCommentRestore
	}
	if req.PollVoteNew {
		params["poll_vote_new"] = req.PollVoteNew
	}
	if req.GroupJoin {
		params["group_join"] = req.GroupJoin
	}
	if req.GroupLeave {
		params["group_leave"] = req.GroupLeave
	}
	if req.GroupChangeSettings {
		params["group_change_settings"] = req.GroupChangeSettings
	}
	if req.GroupChangePhoto {
		params["group_change_photo"] = req.GroupChangePhoto
	}
	if req.GroupOfficersEdit {
		params["group_officers_edit"] = req.GroupOfficersEdit
	}
	if req.UserBlock {
		params["user_block"] = req.UserBlock
	}
	if req.UserUnblock {
		params["user_unblock"] = req.UserUnblock
	}
	if req.LeadFormsNew {
		params["lead_forms_new"] = req.LeadFormsNew
	}
	if req.LikeAdd {
		params["like_add"] = req.LikeAdd
	}
	if req.LikeRemove {
		params["like_remove"] = req.LikeRemove
	}
	if req.MessageEvent {
		params["message_event"] = req.MessageEvent
	}
	return params
}

// GroupsSetLongPollSettings.
//
// Sets Long Poll notification settings
//
// https://vk.com/dev/groups.setLongPollSettings
type GroupsSetLongPollSettings struct {
	GroupID              int64 // Community ID.
	Enabled              bool  // Sets whether Long Poll is enabled ('0' — disabled, '1' — enabled).
	ApiVersion           string
	MessageNew           bool // A new incoming message has been received ('0' — disabled, '1' — enabled).
	MessageReply         bool // A new outcoming message has been received ('0' — disabled, '1' — enabled).
	MessageAllow         bool // Allowed messages notifications ('0' — disabled, '1' — enabled).
	MessageDeny          bool // Denied messages notifications ('0' — disabled, '1' — enabled).
	MessageEdit          bool // A message has been edited ('0' — disabled, '1' — enabled).
	MessageTypingState   bool
	PhotoNew             bool // New photos notifications ('0' — disabled, '1' — enabled).
	AudioNew             bool // New audios notifications ('0' — disabled, '1' — enabled).
	VideoNew             bool // New videos notifications ('0' — disabled, '1' — enabled).
	WallReplyNew         bool // New wall replies notifications ('0' — disabled, '1' — enabled).
	WallReplyEdit        bool // Wall replies edited notifications ('0' — disabled, '1' — enabled).
	WallReplyDelete      bool // A wall comment has been deleted ('0' — disabled, '1' — enabled).
	WallReplyRestore     bool // A wall comment has been restored ('0' — disabled, '1' — enabled).
	WallPostNew          bool // New wall posts notifications ('0' — disabled, '1' — enabled).
	WallRepost           bool // New wall posts notifications ('0' — disabled, '1' — enabled).
	BoardPostNew         bool // New board posts notifications ('0' — disabled, '1' — enabled).
	BoardPostEdit        bool // Board posts edited notifications ('0' — disabled, '1' — enabled).
	BoardPostRestore     bool // Board posts restored notifications ('0' — disabled, '1' — enabled).
	BoardPostDelete      bool // Board posts deleted notifications ('0' — disabled, '1' — enabled).
	PhotoCommentNew      bool // New comment to photo notifications ('0' — disabled, '1' — enabled).
	PhotoCommentEdit     bool // A photo comment has been edited ('0' — disabled, '1' — enabled).
	PhotoCommentDelete   bool // A photo comment has been deleted ('0' — disabled, '1' — enabled).
	PhotoCommentRestore  bool // A photo comment has been restored ('0' — disabled, '1' — enabled).
	VideoCommentNew      bool // New comment to video notifications ('0' — disabled, '1' — enabled).
	VideoCommentEdit     bool // A video comment has been edited ('0' — disabled, '1' — enabled).
	VideoCommentDelete   bool // A video comment has been deleted ('0' — disabled, '1' — enabled).
	VideoCommentRestore  bool // A video comment has been restored ('0' — disabled, '1' — enabled).
	MarketCommentNew     bool // New comment to market item notifications ('0' — disabled, '1' — enabled).
	MarketCommentEdit    bool // A market comment has been edited ('0' — disabled, '1' — enabled).
	MarketCommentDelete  bool // A market comment has been deleted ('0' — disabled, '1' — enabled).
	MarketCommentRestore bool // A market comment has been restored ('0' — disabled, '1' — enabled).
	PollVoteNew          bool // A vote in a public poll has been added ('0' — disabled, '1' — enabled).
	GroupJoin            bool // Joined community notifications ('0' — disabled, '1' — enabled).
	GroupLeave           bool // Left community notifications ('0' — disabled, '1' — enabled).
	GroupChangeSettings  bool
	GroupChangePhoto     bool
	GroupOfficersEdit    bool
	UserBlock            bool // User added to community blacklist
	UserUnblock          bool // User removed from community blacklist
	LikeAdd              bool
	LikeRemove           bool
	MessageEvent         bool
}

func (req GroupsSetLongPollSettings) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Enabled {
		params["enabled"] = req.Enabled
	}
	if req.ApiVersion != "" {
		params["api_version"] = req.ApiVersion
	}
	if req.MessageNew {
		params["message_new"] = req.MessageNew
	}
	if req.MessageReply {
		params["message_reply"] = req.MessageReply
	}
	if req.MessageAllow {
		params["message_allow"] = req.MessageAllow
	}
	if req.MessageDeny {
		params["message_deny"] = req.MessageDeny
	}
	if req.MessageEdit {
		params["message_edit"] = req.MessageEdit
	}
	if req.MessageTypingState {
		params["message_typing_state"] = req.MessageTypingState
	}
	if req.PhotoNew {
		params["photo_new"] = req.PhotoNew
	}
	if req.AudioNew {
		params["audio_new"] = req.AudioNew
	}
	if req.VideoNew {
		params["video_new"] = req.VideoNew
	}
	if req.WallReplyNew {
		params["wall_reply_new"] = req.WallReplyNew
	}
	if req.WallReplyEdit {
		params["wall_reply_edit"] = req.WallReplyEdit
	}
	if req.WallReplyDelete {
		params["wall_reply_delete"] = req.WallReplyDelete
	}
	if req.WallReplyRestore {
		params["wall_reply_restore"] = req.WallReplyRestore
	}
	if req.WallPostNew {
		params["wall_post_new"] = req.WallPostNew
	}
	if req.WallRepost {
		params["wall_repost"] = req.WallRepost
	}
	if req.BoardPostNew {
		params["board_post_new"] = req.BoardPostNew
	}
	if req.BoardPostEdit {
		params["board_post_edit"] = req.BoardPostEdit
	}
	if req.BoardPostRestore {
		params["board_post_restore"] = req.BoardPostRestore
	}
	if req.BoardPostDelete {
		params["board_post_delete"] = req.BoardPostDelete
	}
	if req.PhotoCommentNew {
		params["photo_comment_new"] = req.PhotoCommentNew
	}
	if req.PhotoCommentEdit {
		params["photo_comment_edit"] = req.PhotoCommentEdit
	}
	if req.PhotoCommentDelete {
		params["photo_comment_delete"] = req.PhotoCommentDelete
	}
	if req.PhotoCommentRestore {
		params["photo_comment_restore"] = req.PhotoCommentRestore
	}
	if req.VideoCommentNew {
		params["video_comment_new"] = req.VideoCommentNew
	}
	if req.VideoCommentEdit {
		params["video_comment_edit"] = req.VideoCommentEdit
	}
	if req.VideoCommentDelete {
		params["video_comment_delete"] = req.VideoCommentDelete
	}
	if req.VideoCommentRestore {
		params["video_comment_restore"] = req.VideoCommentRestore
	}
	if req.MarketCommentNew {
		params["market_comment_new"] = req.MarketCommentNew
	}
	if req.MarketCommentEdit {
		params["market_comment_edit"] = req.MarketCommentEdit
	}
	if req.MarketCommentDelete {
		params["market_comment_delete"] = req.MarketCommentDelete
	}
	if req.MarketCommentRestore {
		params["market_comment_restore"] = req.MarketCommentRestore
	}
	if req.PollVoteNew {
		params["poll_vote_new"] = req.PollVoteNew
	}
	if req.GroupJoin {
		params["group_join"] = req.GroupJoin
	}
	if req.GroupLeave {
		params["group_leave"] = req.GroupLeave
	}
	if req.GroupChangeSettings {
		params["group_change_settings"] = req.GroupChangeSettings
	}
	if req.GroupChangePhoto {
		params["group_change_photo"] = req.GroupChangePhoto
	}
	if req.GroupOfficersEdit {
		params["group_officers_edit"] = req.GroupOfficersEdit
	}
	if req.UserBlock {
		params["user_block"] = req.UserBlock
	}
	if req.UserUnblock {
		params["user_unblock"] = req.UserUnblock
	}
	if req.LikeAdd {
		params["like_add"] = req.LikeAdd
	}
	if req.LikeRemove {
		params["like_remove"] = req.LikeRemove
	}
	if req.MessageEvent {
		params["message_event"] = req.MessageEvent
	}
	return params
}

// GroupsUnban.
//
// https://vk.com/dev/groups.unban
type GroupsUnban struct {
	GroupID int64
	OwnerID int64
}

func (req GroupsUnban) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// LeadsCheckUser.
//
// Checks if the user can start the lead.
//
// https://vk.com/dev/leads.checkUser
type LeadsCheckUser struct {
	LeadID     int64 // Lead ID.
	TestResult int64 // Value to be return in 'result' field when test mode is used.
	TestMode   bool
	AutoStart  bool
	Age        int64  // User age.
	Country    string // User country code.
}

func (req LeadsCheckUser) params() Params {
	params := make(Params)
	if req.LeadID != 0 {
		params["lead_id"] = req.LeadID
	}
	if req.TestResult != 0 {
		params["test_result"] = req.TestResult
	}
	if req.TestMode {
		params["test_mode"] = req.TestMode
	}
	if req.AutoStart {
		params["auto_start"] = req.AutoStart
	}
	if req.Age != 0 {
		params["age"] = req.Age
	}
	if req.Country != "" {
		params["country"] = req.Country
	}
	return params
}

// LeadsComplete.
//
// Completes the lead started by user.
//
// https://vk.com/dev/leads.complete
type LeadsComplete struct {
	VKSid   string // Session obtained as GET parameter when session started.
	Secret  string // Secret key from the lead testing interface.
	Comment string // Comment text.
}

func (req LeadsComplete) params() Params {
	params := make(Params)
	if req.VKSid != "" {
		params["vk_sid"] = req.VKSid
	}
	if req.Secret != "" {
		params["secret"] = req.Secret
	}
	if req.Comment != "" {
		params["comment"] = req.Comment
	}
	return params
}

// LeadsGetStats.
//
// Returns lead stats data.
//
// https://vk.com/dev/leads.getStats
type LeadsGetStats struct {
	LeadID    int64  // Lead ID.
	Secret    string // Secret key obtained from the lead testing interface.
	DateStart string // Day to start stats from (YYYY_MM_DD, e.g.2011-09-17).
	DateEnd   string // Day to finish stats (YYYY_MM_DD, e.g.2011-09-17).
}

func (req LeadsGetStats) params() Params {
	params := make(Params)
	if req.LeadID != 0 {
		params["lead_id"] = req.LeadID
	}
	if req.Secret != "" {
		params["secret"] = req.Secret
	}
	if req.DateStart != "" {
		params["date_start"] = req.DateStart
	}
	if req.DateEnd != "" {
		params["date_end"] = req.DateEnd
	}
	return params
}

// LeadsGetUsers.
//
// Returns a list of last user actions for the offer.
//
// https://vk.com/dev/leads.getUsers
type LeadsGetUsers struct {
	OfferID int64  // Offer ID.
	Secret  string // Secret key obtained in the lead testing interface.
	Offset  int64  // Offset needed to return a specific subset of results.
	Count   int64  // Number of results to return.
	Status  int64  // Action type. Possible values: *'0' — start,, *'1' — finish,, *'2' — blocking users,, *'3' — start in a test mode,, *'4' — finish in a test mode.
	Reverse bool   // Sort order. Possible values: *'1' — chronological,, *'0' — reverse chronological.
}

func (req LeadsGetUsers) params() Params {
	params := make(Params)
	if req.OfferID != 0 {
		params["offer_id"] = req.OfferID
	}
	if req.Secret != "" {
		params["secret"] = req.Secret
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Status != 0 {
		params["status"] = req.Status
	}
	if req.Reverse {
		params["reverse"] = req.Reverse
	}
	return params
}

// LeadsMetricHit.
//
// Counts the metric event.
//
// https://vk.com/dev/leads.metricHit
type LeadsMetricHit struct {
	Data string // Metric data obtained in the lead interface.
}

func (req LeadsMetricHit) params() Params {
	params := make(Params)
	if req.Data != "" {
		params["data"] = req.Data
	}
	return params
}

// LeadsStart.
//
// Creates new session for the user passing the offer.
//
// https://vk.com/dev/leads.start
type LeadsStart struct {
	LeadID   int64  // Lead ID.
	Secret   string // Secret key from the lead testing interface.
	Uid      int64
	Aid      int64
	TestMode bool
	Force    bool
}

func (req LeadsStart) params() Params {
	params := make(Params)
	if req.LeadID != 0 {
		params["lead_id"] = req.LeadID
	}
	if req.Secret != "" {
		params["secret"] = req.Secret
	}
	if req.Uid != 0 {
		params["uid"] = req.Uid
	}
	if req.Aid != 0 {
		params["aid"] = req.Aid
	}
	if req.TestMode {
		params["test_mode"] = req.TestMode
	}
	if req.Force {
		params["force"] = req.Force
	}
	return params
}

// LikesAdd.
//
// Adds the specified object to the 'Likes' list of the current user.
//
// https://vk.com/dev/likes.add
type LikesAdd struct {
	Type      *LikesType // Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion, 'sitepage' — page of the site where the [vk.com/dev/Like|Like widget] is installed
	OwnerID   int64      // ID of the user or community that owns the object.
	ItemID    int64      // Object ID.
	AccessKey string     // Access key required for an object owned by a private entity.
}

func (req LikesAdd) params() Params {
	params := make(Params)
	if req.Type != nil {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// LikesDelete.
//
// Deletes the specified object from the 'Likes' list of the current user.
//
// https://vk.com/dev/likes.delete
type LikesDelete struct {
	Type      *LikesType // Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion, 'sitepage' — page of the site where the [vk.com/dev/Like|Like widget] is installed
	OwnerID   int64      // ID of the user or community that owns the object.
	ItemID    int64      // Object ID.
	AccessKey string     // Access key required for an object owned by a private entity.
}

func (req LikesDelete) params() Params {
	params := make(Params)
	if req.Type != nil {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// LikesGetList.
//
// Returns a list of IDs of users who added the specified object to their 'Likes' list.
//
// https://vk.com/dev/likes.getList
type LikesGetList struct {
	Type        *LikesType // , Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion, 'sitepage' — page of the site where the [vk.com/dev/Like|Like widget] is installed
	OwnerID     int64      // ID of the user, community, or application that owns the object. If the 'type' parameter is set as 'sitepage', the application ID is passed as 'owner_id'. Use negative value for a community id. If the 'type' parameter is not set, the 'owner_id' is assumed to be either the current user or the same application ID as if the 'type' parameter was set to 'sitepage'.
	ItemID      int64      // Object ID. If 'type' is set as 'sitepage', 'item_id' can include the 'page_id' parameter value used during initialization of the [vk.com/dev/Like|Like widget].
	PageURL     string     // URL of the page where the [vk.com/dev/Like|Like widget] is installed. Used instead of the 'item_id' parameter.
	Filter      string     // Filters to apply: 'likes' — returns information about all users who liked the object (default), 'copies' — returns information only about users who told their friends about the object
	FriendsOnly int64      // Specifies which users are returned: '1' — to return only the current user's friends, '0' — to return all users (default)
	Extended    bool       // Specifies whether extended information will be returned. '1' — to return extended information about users and communities from the 'Likes' list, '0' — to return no additional information (default)
	Offset      int64      // Offset needed to select a specific subset of users.
	Count       int64      // Number of user IDs to return (maximum '1000'). Default is '100' if 'friends_only' is set to '0', otherwise, the default is '10' if 'friends_only' is set to '1'.
	SkipOwn     bool
}

func (req LikesGetList) params() Params {
	params := make(Params)
	if req.Type != nil {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.PageURL != "" {
		params["page_url"] = req.PageURL
	}
	if req.Filter != "" {
		params["filter"] = req.Filter
	}
	if req.FriendsOnly != 0 {
		params["friends_only"] = req.FriendsOnly
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.SkipOwn {
		params["skip_own"] = req.SkipOwn
	}
	return params
}

// LikesIsLiked.
//
// Checks for the object in the 'Likes' list of the specified user.
//
// https://vk.com/dev/likes.isLiked
type LikesIsLiked struct {
	UserID  int64      // User ID.
	Type    *LikesType // Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion
	OwnerID int64      // ID of the user or community that owns the object.
	ItemID  int64      // Object ID.
}

func (req LikesIsLiked) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Type != nil {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	return params
}

// MarketAdd.
//
// Ads a new item to the market.
//
// https://vk.com/dev/market.add
type MarketAdd struct {
	OwnerID         int64   // ID of an item owner community.
	Name            string  // Item name.
	Description     string  // Item description.
	CategoryID      int64   // Item category ID.
	Price           float64 // Item price.
	OldPrice        float64
	Deleted         bool    // Item status ('1' — deleted, '0' — not deleted).
	MainPhotoID     int64   // Cover photo ID.
	PhotoIDs        []int64 // IDs of additional photos.
	URL             string  // Url for button in market item.
	DimensionWidth  int64
	DimensionHeight int64
	DimensionLength int64
	Weight          int64
}

func (req MarketAdd) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if req.CategoryID != 0 {
		params["category_id"] = req.CategoryID
	}
	if req.Price != 0 {
		params["price"] = req.Price
	}
	if req.OldPrice != 0 {
		params["old_price"] = req.OldPrice
	}
	if req.Deleted {
		params["deleted"] = req.Deleted
	}
	if req.MainPhotoID != 0 {
		params["main_photo_id"] = req.MainPhotoID
	}
	if len(req.PhotoIDs) > 0 {
		params["photo_ids"] = req.PhotoIDs
	}
	if req.URL != "" {
		params["url"] = req.URL
	}
	if req.DimensionWidth != 0 {
		params["dimension_width"] = req.DimensionWidth
	}
	if req.DimensionHeight != 0 {
		params["dimension_height"] = req.DimensionHeight
	}
	if req.DimensionLength != 0 {
		params["dimension_length"] = req.DimensionLength
	}
	if req.Weight != 0 {
		params["weight"] = req.Weight
	}
	return params
}

// MarketAddAlbum.
//
// Creates new collection of items
//
// https://vk.com/dev/market.addAlbum
type MarketAddAlbum struct {
	OwnerID   int64  // ID of an item owner community.
	Title     string // Collection title.
	PhotoID   int64  // Cover photo ID.
	MainAlbum bool   // Set as main ('1' – set, '0' – no).
}

func (req MarketAddAlbum) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.MainAlbum {
		params["main_album"] = req.MainAlbum
	}
	return params
}

// MarketAddToAlbum.
//
// Adds an item to one or multiple collections.
//
// https://vk.com/dev/market.addToAlbum
type MarketAddToAlbum struct {
	OwnerID  int64   // ID of an item owner community.
	ItemID   int64   // Item ID.
	AlbumIDs []int64 // Collections IDs to add item to.
}

func (req MarketAddToAlbum) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if len(req.AlbumIDs) > 0 {
		params["album_ids"] = req.AlbumIDs
	}
	return params
}

// MarketCreateComment.
//
// Creates a new comment for an item.
//
// https://vk.com/dev/market.createComment
type MarketCreateComment struct {
	OwnerID        int64    // ID of an item owner community.
	ItemID         int64    // Item ID.
	Message        string   // Comment text (required if 'attachments' parameter is not specified)
	Attachments    []string // Comma-separated list of objects attached to a comment. The field is submitted the following way: , "'<owner_id>_<media_id>,<owner_id>_<media_id>'", , '' - media attachment type: "'photo' - photo, 'video' - video, 'audio' - audio, 'doc' - document", , '<owner_id>' - media owner id, '<media_id>' - media attachment id, , For example: "photo100172_166443618,photo66748_265827614",
	FromGroup      bool     // '1' - comment will be published on behalf of a community, '0' - on behalf of a user (by default).
	ReplyToComment int64    // ID of a comment to reply with current comment to.
	StickerID      int64    // Sticker ID.
	Guid           string   // Random value to avoid resending one comment.
}

func (req MarketCreateComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.FromGroup {
		params["from_group"] = req.FromGroup
	}
	if req.ReplyToComment != 0 {
		params["reply_to_comment"] = req.ReplyToComment
	}
	if req.StickerID != 0 {
		params["sticker_id"] = req.StickerID
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	return params
}

// MarketDelete.
//
// Deletes an item.
//
// https://vk.com/dev/market.delete
type MarketDelete struct {
	OwnerID int64 // ID of an item owner community.
	ItemID  int64 // Item ID.
}

func (req MarketDelete) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	return params
}

// MarketDeleteAlbum.
//
// Deletes a collection of items.
//
// https://vk.com/dev/market.deleteAlbum
type MarketDeleteAlbum struct {
	OwnerID int64 // ID of an collection owner community.
	AlbumID int64 // Collection ID.
}

func (req MarketDeleteAlbum) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	return params
}

// MarketDeleteComment.
//
// Deletes an item's comment
//
// https://vk.com/dev/market.deleteComment
type MarketDeleteComment struct {
	OwnerID   int64 // identifier of an item owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	CommentID int64 // comment id
}

func (req MarketDeleteComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// MarketEdit.
//
// Edits an item.
//
// https://vk.com/dev/market.edit
type MarketEdit struct {
	OwnerID     int64   // ID of an item owner community.
	ItemID      int64   // Item ID.
	Name        string  // Item name.
	Description string  // Item description.
	CategoryID  int64   // Item category ID.
	Price       float64 // Item price.
	Deleted     bool    // Item status ('1' — deleted, '0' — not deleted).
	MainPhotoID int64   // Cover photo ID.
	PhotoIDs    []int64 // IDs of additional photos.
	URL         string  // Url for button in market item.
}

func (req MarketEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if req.CategoryID != 0 {
		params["category_id"] = req.CategoryID
	}
	if req.Price != 0 {
		params["price"] = req.Price
	}
	if req.Deleted {
		params["deleted"] = req.Deleted
	}
	if req.MainPhotoID != 0 {
		params["main_photo_id"] = req.MainPhotoID
	}
	if len(req.PhotoIDs) > 0 {
		params["photo_ids"] = req.PhotoIDs
	}
	if req.URL != "" {
		params["url"] = req.URL
	}
	return params
}

// MarketEditAlbum.
//
// Edits a collection of items
//
// https://vk.com/dev/market.editAlbum
type MarketEditAlbum struct {
	OwnerID   int64  // ID of an collection owner community.
	AlbumID   int64  // Collection ID.
	Title     string // Collection title.
	PhotoID   int64  // Cover photo id
	MainAlbum bool   // Set as main ('1' – set, '0' – no).
}

func (req MarketEditAlbum) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.MainAlbum {
		params["main_album"] = req.MainAlbum
	}
	return params
}

// MarketEditComment.
//
// Chages item comment's text
//
// https://vk.com/dev/market.editComment
type MarketEditComment struct {
	OwnerID     int64    // ID of an item owner community.
	CommentID   int64    // Comment ID.
	Message     string   // New comment text (required if 'attachments' are not specified), , 2048 symbols maximum.
	Attachments []string // Comma-separated list of objects attached to a comment. The field is submitted the following way: , "'<owner_id>_<media_id>,<owner_id>_<media_id>'", , '' - media attachment type: "'photo' - photo, 'video' - video, 'audio' - audio, 'doc' - document", , '<owner_id>' - media owner id, '<media_id>' - media attachment id, , For example: "photo100172_166443618,photo66748_265827614",
}

func (req MarketEditComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	return params
}

// MarketGet.
//
// Returns items list for a community.
//
// https://vk.com/dev/market.get
type MarketGet struct {
	OwnerID  int64 // ID of an item owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	AlbumID  int64
	Count    int64 // Number of items to return.
	Offset   int64 // Offset needed to return a specific subset of results.
	Extended bool  // '1' – method will return additional fields: 'likes, can_comment, car_repost, photos'. These parameters are not returned by default.
}

func (req MarketGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// MarketGetAlbumByID.
//
// Returns items album's data
//
// https://vk.com/dev/market.getAlbumById
type MarketGetAlbumByID struct {
	OwnerID  int64   // identifier of an album owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	AlbumIDs []int64 // collections identifiers to obtain data from
}

func (req MarketGetAlbumByID) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if len(req.AlbumIDs) > 0 {
		params["album_ids"] = req.AlbumIDs
	}
	return params
}

// MarketGetAlbums.
//
// Returns community's collections list.
//
// https://vk.com/dev/market.getAlbums
type MarketGetAlbums struct {
	OwnerID int64 // ID of an items owner community.
	Offset  int64 // Offset needed to return a specific subset of results.
	Count   int64 // Number of items to return.
}

func (req MarketGetAlbums) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// MarketGetByID.
//
// Returns information about market items by their ids.
//
// https://vk.com/dev/market.getById
type MarketGetByID struct {
	ItemIDs  []string // Comma-separated ids list: {user id}_{item id}. If an item belongs to a community -{community id} is used. " 'Videos' value example: , '-4363_136089719,13245770_137352259'"
	Extended bool     // '1' – to return additional fields: 'likes, can_comment, car_repost, photos'. By default: '0'.
}

func (req MarketGetByID) params() Params {
	params := make(Params)
	if len(req.ItemIDs) > 0 {
		params["item_ids"] = req.ItemIDs
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// MarketGetCategories.
//
// Returns a list of market categories.
//
// https://vk.com/dev/market.getCategories
type MarketGetCategories struct {
	Count  int64 // Number of results to return.
	Offset int64 // Offset needed to return a specific subset of results.
}

func (req MarketGetCategories) params() Params {
	params := make(Params)
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// MarketGetComments.
//
// Returns comments list for an item.
//
// https://vk.com/dev/market.getComments
type MarketGetComments struct {
	OwnerID        int64 // ID of an item owner community
	ItemID         int64 // Item ID.
	NeedLikes      bool  // '1' — to return likes info.
	StartCommentID int64 // ID of a comment to start a list from (details below).
	Offset         int64
	Count          int64         // Number of results to return.
	Sort           string        // Sort order ('asc' — from old to new, 'desc' — from new to old)
	Extended       bool          // '1' — comments will be returned as numbered objects, in addition lists of 'profiles' and 'groups' objects will be returned.
	Fields         []UsersFields // List of additional profile fields to return. See the [vk.com/dev/fields|details]
}

func (req MarketGetComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.NeedLikes {
		params["need_likes"] = req.NeedLikes
	}
	if req.StartCommentID != 0 {
		params["start_comment_id"] = req.StartCommentID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// MarketRemoveFromAlbum.
//
// Removes an item from one or multiple collections.
//
// https://vk.com/dev/market.removeFromAlbum
type MarketRemoveFromAlbum struct {
	OwnerID  int64   // ID of an item owner community.
	ItemID   int64   // Item ID.
	AlbumIDs []int64 // Collections IDs to remove item from.
}

func (req MarketRemoveFromAlbum) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if len(req.AlbumIDs) > 0 {
		params["album_ids"] = req.AlbumIDs
	}
	return params
}

// MarketReorderAlbums.
//
// Reorders the collections list.
//
// https://vk.com/dev/market.reorderAlbums
type MarketReorderAlbums struct {
	OwnerID int64 // ID of an item owner community.
	AlbumID int64 // Collection ID.
	Before  int64 // ID of a collection to place current collection before it.
	After   int64 // ID of a collection to place current collection after it.
}

func (req MarketReorderAlbums) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Before != 0 {
		params["before"] = req.Before
	}
	if req.After != 0 {
		params["after"] = req.After
	}
	return params
}

// MarketReorderItems.
//
// Changes item place in a collection.
//
// https://vk.com/dev/market.reorderItems
type MarketReorderItems struct {
	OwnerID int64 // ID of an item owner community.
	AlbumID int64 // ID of a collection to reorder items in. Set 0 to reorder full items list.
	ItemID  int64 // Item ID.
	Before  int64 // ID of an item to place current item before it.
	After   int64 // ID of an item to place current item after it.
}

func (req MarketReorderItems) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.Before != 0 {
		params["before"] = req.Before
	}
	if req.After != 0 {
		params["after"] = req.After
	}
	return params
}

// MarketReport.
//
// Sends a complaint to the item.
//
// https://vk.com/dev/market.report
type MarketReport struct {
	OwnerID int64 // ID of an item owner community.
	ItemID  int64 // Item ID.
	Reason  int64 // Complaint reason. Possible values: *'0' — spam,, *'1' — child porn,, *'2' — extremism,, *'3' — violence,, *'4' — drugs propaganda,, *'5' — adult materials,, *'6' — insult.
}

func (req MarketReport) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// MarketReportComment.
//
// Sends a complaint to the item's comment.
//
// https://vk.com/dev/market.reportComment
type MarketReportComment struct {
	OwnerID   int64 // ID of an item owner community.
	CommentID int64 // Comment ID.
	Reason    int64 // Complaint reason. Possible values: *'0' — spam,, *'1' — child porn,, *'2' — extremism,, *'3' — violence,, *'4' — drugs propaganda,, *'5' — adult materials,, *'6' — insult.
}

func (req MarketReportComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// MarketRestore.
//
// Restores recently deleted item
//
// https://vk.com/dev/market.restore
type MarketRestore struct {
	OwnerID int64 // ID of an item owner community.
	ItemID  int64 // Deleted item ID.
}

func (req MarketRestore) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	return params
}

// MarketRestoreComment.
//
// Restores a recently deleted comment
//
// https://vk.com/dev/market.restoreComment
type MarketRestoreComment struct {
	OwnerID   int64 // identifier of an item owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	CommentID int64 // deleted comment id
}

func (req MarketRestoreComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// MarketSearch.
//
// Searches market items in a community's catalog
//
// https://vk.com/dev/market.search
type MarketSearch struct {
	OwnerID   int64 // ID of an items owner community.
	AlbumID   int64
	Q         string // Search query, for example "pink slippers".
	PriceFrom int64  // Minimum item price value.
	PriceTo   int64  // Maximum item price value.
	Sort      int64
	Rev       int64 // '0' — do not use reverse order, '1' — use reverse order
	Offset    int64 // Offset needed to return a specific subset of results.
	Count     int64 // Number of items to return.
	Extended  bool  // '1' – to return additional fields: 'likes, can_comment, car_repost, photos'. By default: '0'.
	Status    int64
}

func (req MarketSearch) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.PriceFrom != 0 {
		params["price_from"] = req.PriceFrom
	}
	if req.PriceTo != 0 {
		params["price_to"] = req.PriceTo
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.Rev != 0 {
		params["rev"] = req.Rev
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Status != 0 {
		params["status"] = req.Status
	}
	return params
}

// MessagesAddChatUser.
//
// Adds a new user to a chat.
//
// https://vk.com/dev/messages.addChatUser
type MessagesAddChatUser struct {
	ChatID               int64 // Chat ID.
	UserID               int64 // ID of the user to be added to the chat.
	VisibleMessagesCount int64
}

func (req MessagesAddChatUser) params() Params {
	params := make(Params)
	if req.ChatID != 0 {
		params["chat_id"] = req.ChatID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.VisibleMessagesCount != 0 {
		params["visible_messages_count"] = req.VisibleMessagesCount
	}
	return params
}

// MessagesAllowMessagesFromGroup.
//
// Allows sending messages from community to the current user.
//
// https://vk.com/dev/messages.allowMessagesFromGroup
type MessagesAllowMessagesFromGroup struct {
	GroupID int64 // Group ID.
	Key     string
}

func (req MessagesAllowMessagesFromGroup) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Key != "" {
		params["key"] = req.Key
	}
	return params
}

// MessagesCreateChat.
//
// Creates a chat with several participants.
//
// https://vk.com/dev/messages.createChat
type MessagesCreateChat struct {
	UserIDs []int64 // IDs of the users to be added to the chat.
	Title   string  // Chat title.
	GroupID int64
}

func (req MessagesCreateChat) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesDelete.
//
// Deletes one or more messages.
//
// https://vk.com/dev/messages.delete
type MessagesDelete struct {
	MessageIDs   []int64 // Message IDs.
	Spam         bool    // '1' — to mark message as spam.
	GroupID      int64   // Group ID (for group messages with user access token)
	DeleteForAll bool    // '1' — delete message for for all.
}

func (req MessagesDelete) params() Params {
	params := make(Params)
	if len(req.MessageIDs) > 0 {
		params["message_ids"] = req.MessageIDs
	}
	if req.Spam {
		params["spam"] = req.Spam
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.DeleteForAll {
		params["delete_for_all"] = req.DeleteForAll
	}
	return params
}

// MessagesDeleteChatPhoto.
//
// Deletes a chat's cover picture.
//
// https://vk.com/dev/messages.deleteChatPhoto
type MessagesDeleteChatPhoto struct {
	ChatID  int64 // Chat ID.
	GroupID int64
}

func (req MessagesDeleteChatPhoto) params() Params {
	params := make(Params)
	if req.ChatID != 0 {
		params["chat_id"] = req.ChatID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesDeleteConversation.
//
// Deletes all private messages in a conversation.
//
// https://vk.com/dev/messages.deleteConversation
type MessagesDeleteConversation struct {
	UserID  int64 // User ID. To clear a chat history use 'chat_id'
	PeerID  int64 // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	GroupID int64 // Group ID (for group messages with user access token)
}

func (req MessagesDeleteConversation) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesDenyMessagesFromGroup.
//
// Denies sending message from community to the current user.
//
// https://vk.com/dev/messages.denyMessagesFromGroup
type MessagesDenyMessagesFromGroup struct {
	GroupID int64 // Group ID.
}

func (req MessagesDenyMessagesFromGroup) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesEdit.
//
// Edits the message.
//
// https://vk.com/dev/messages.edit
type MessagesEdit struct {
	PeerID                int64   // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	Message               string  // (Required if 'attachments' is not set.) Text of the message.
	Lat                   float64 // Geographical latitude of a check-in, in degrees (from -90 to 90).
	Long                  float64 // Geographical longitude of a check-in, in degrees (from -180 to 180).
	Attachment            string  // (Required if 'message' is not set.) List of objects attached to the message, separated by commas, in the following format: "<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'wall' — wall post, '<owner_id>' — ID of the media attachment owner. '<media_id>' — media attachment ID. Example: "photo100172_166443618"
	KeepForwardMessages   bool    // '1' — to keep forwarded, messages.
	KeepSnippets          bool    // '1' — to keep attached snippets.
	GroupID               int64   // Group ID (for group messages with user access token)
	DontParseLinks        bool
	MessageID             int64
	ConversationMessageID int64
	Template              string
	Keyboard              string
}

func (req MessagesEdit) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.Attachment != "" {
		params["attachment"] = req.Attachment
	}
	if req.KeepForwardMessages {
		params["keep_forward_messages"] = req.KeepForwardMessages
	}
	if req.KeepSnippets {
		params["keep_snippets"] = req.KeepSnippets
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.DontParseLinks {
		params["dont_parse_links"] = req.DontParseLinks
	}
	if req.MessageID != 0 {
		params["message_id"] = req.MessageID
	}
	if req.ConversationMessageID != 0 {
		params["conversation_message_id"] = req.ConversationMessageID
	}
	if req.Template != "" {
		params["template"] = req.Template
	}
	if req.Keyboard != "" {
		params["keyboard"] = req.Keyboard
	}
	return params
}

// MessagesEditChat.
//
// Edits the title of a chat.
//
// https://vk.com/dev/messages.editChat
type MessagesEditChat struct {
	ChatID int64  // Chat ID.
	Title  string // New title of the chat.
}

func (req MessagesEditChat) params() Params {
	params := make(Params)
	if req.ChatID != 0 {
		params["chat_id"] = req.ChatID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	return params
}

// MessagesGetByConversationMessageID.
//
// Returns messages by their IDs within the conversation.
//
// https://vk.com/dev/messages.getByConversationMessageId
type MessagesGetByConversationMessageID struct {
	PeerID                 int64         // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	ConversationMessageIDs []int64       // Conversation message IDs.
	Extended               bool          // Information whether the response should be extended
	Fields                 []UsersFields // Profile fields to return.
	GroupID                int64         // Group ID (for group messages with group access token)
}

func (req MessagesGetByConversationMessageID) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if len(req.ConversationMessageIDs) > 0 {
		params["conversation_message_ids"] = req.ConversationMessageIDs
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetByID.
//
// Returns messages by their IDs.
//
// https://vk.com/dev/messages.getById
type MessagesGetByID struct {
	MessageIDs    []int64       // Message IDs.
	PreviewLength int64         // Number of characters after which to truncate a previewed message. To preview the full message, specify '0'. "NOTE: Messages are not truncated by default. Messages are truncated by words."
	Extended      bool          // Information whether the response should be extended
	Fields        []UsersFields // Profile fields to return.
	GroupID       int64         // Group ID (for group messages with group access token)
}

func (req MessagesGetByID) params() Params {
	params := make(Params)
	if len(req.MessageIDs) > 0 {
		params["message_ids"] = req.MessageIDs
	}
	if req.PreviewLength != 0 {
		params["preview_length"] = req.PreviewLength
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetChatPreview.
//
// https://vk.com/dev/messages.getChatPreview
type MessagesGetChatPreview struct {
	PeerID int64
	Link   string        // Invitation link.
	Fields []UsersFields // Profile fields to return.
}

func (req MessagesGetChatPreview) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Link != "" {
		params["link"] = req.Link
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// MessagesGetConversationMembers.
//
// Returns a list of IDs of users participating in a chat.
//
// https://vk.com/dev/messages.getConversationMembers
type MessagesGetConversationMembers struct {
	PeerID  int64         // Peer ID.
	Fields  []UsersFields // Profile fields to return.
	GroupID int64         // Group ID (for group messages with group access token)
}

func (req MessagesGetConversationMembers) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetConversations.
//
// Returns a list of the current user's conversations.
//
// https://vk.com/dev/messages.getConversations
type MessagesGetConversations struct {
	Offset         int64                 // Offset needed to return a specific subset of conversations.
	Count          int64                 // Number of conversations to return.
	Filter         string                // Filter to apply: 'all' — all conversations, 'unread' — conversations with unread messages, 'important' — conversations, marked as important (only for community messages), 'unanswered' — conversations, marked as unanswered (only for community messages)
	Extended       bool                  // '1' — return extra information about users and communities
	StartMessageID int64                 // ID of the message from what to return dialogs.
	Fields         []BaseUserGroupFields // Profile and communities fields to return.
	GroupID        int64                 // Group ID (for group messages with group access token)
}

func (req MessagesGetConversations) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Filter != "" {
		params["filter"] = req.Filter
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.StartMessageID != 0 {
		params["start_message_id"] = req.StartMessageID
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetConversationsByID.
//
// Returns conversations by their IDs
//
// https://vk.com/dev/messages.getConversationsById
type MessagesGetConversationsByID struct {
	PeerIDs  []int64               // Destination IDs. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	Extended bool                  // Return extended properties
	Fields   []BaseUserGroupFields // Profile and communities fields to return.
	GroupID  int64                 // Group ID (for group messages with group access token)
}

func (req MessagesGetConversationsByID) params() Params {
	params := make(Params)
	if len(req.PeerIDs) > 0 {
		params["peer_ids"] = req.PeerIDs
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetHistory.
//
// Returns message history for the specified user or group chat.
//
// https://vk.com/dev/messages.getHistory
type MessagesGetHistory struct {
	Offset         int64 // Offset needed to return a specific subset of messages.
	Count          int64 // Number of messages to return.
	UserID         int64 // ID of the user whose message history you want to return.
	PeerID         int64
	StartMessageID int64         // Starting message ID from which to return history.
	Rev            int64         // Sort order: '1' — return messages in chronological order. '0' — return messages in reverse chronological order.
	Extended       bool          // Information whether the response should be extended
	Fields         []UsersFields // Profile fields to return.
	GroupID        int64         // Group ID (for group messages with group access token)
}

func (req MessagesGetHistory) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.StartMessageID != 0 {
		params["start_message_id"] = req.StartMessageID
	}
	if req.Rev != 0 {
		params["rev"] = req.Rev
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetHistoryAttachments.
//
// Returns media files from the dialog or group chat.
//
// https://vk.com/dev/messages.getHistoryAttachments
type MessagesGetHistoryAttachments struct {
	PeerID           int64         // Peer ID. ", For group chat: '2000000000 + chat ID' , , For community: '-community ID'"
	MediaType        string        // Type of media files to return: *'photo',, *'video',, *'audio',, *'doc',, *'link'.,*'market'.,*'wall'.,*'share'
	StartFrom        string        // Message ID to start return results from.
	Count            int64         // Number of objects to return.
	PhotoSizes       bool          // '1' — to return photo sizes in a
	Fields           []UsersFields // Additional profile [vk.com/dev/fields|fields] to return.
	GroupID          int64         // Group ID (for group messages with group access token)
	PreserveOrder    bool
	MaxForwardsLevel int64
}

func (req MessagesGetHistoryAttachments) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.MediaType != "" {
		params["media_type"] = req.MediaType
	}
	if req.StartFrom != "" {
		params["start_from"] = req.StartFrom
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.PhotoSizes {
		params["photo_sizes"] = req.PhotoSizes
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.PreserveOrder {
		params["preserve_order"] = req.PreserveOrder
	}
	if req.MaxForwardsLevel != 0 {
		params["max_forwards_level"] = req.MaxForwardsLevel
	}
	return params
}

// MessagesGetInviteLink.
//
// https://vk.com/dev/messages.getInviteLink
type MessagesGetInviteLink struct {
	PeerID  int64 // Destination ID.
	Reset   bool  // 1 — to generate new link (revoke previous), 0 — to return previous link.
	GroupID int64 // Group ID
}

func (req MessagesGetInviteLink) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Reset {
		params["reset"] = req.Reset
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesGetLastActivity.
//
// Returns a user's current status and date of last activity.
//
// https://vk.com/dev/messages.getLastActivity
type MessagesGetLastActivity struct {
	UserID int64 // User ID.
}

func (req MessagesGetLastActivity) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// MessagesGetLongPollHistory.
//
// Returns updates in user's private messages.
//
// https://vk.com/dev/messages.getLongPollHistory
type MessagesGetLongPollHistory struct {
	Ts            int64         // Last value of the 'ts' parameter returned from the Long Poll server or by using [vk.com/dev/messages.getLongPollHistory|messages.getLongPollHistory] method.
	Pts           int64         // Lsat value of 'pts' parameter returned from the Long Poll server or by using [vk.com/dev/messages.getLongPollHistory|messages.getLongPollHistory] method.
	PreviewLength int64         // Number of characters after which to truncate a previewed message. To preview the full message, specify '0'. "NOTE: Messages are not truncated by default. Messages are truncated by words."
	Onlines       bool          // '1' — to return history with online users only.
	Fields        []UsersFields // Additional profile [vk.com/dev/fields|fields] to return.
	EventsLimit   int64         // Maximum number of events to return.
	MsgsLimit     int64         // Maximum number of messages to return.
	MaxMsgID      int64         // Maximum ID of the message among existing ones in the local copy. Both messages received with API methods (for example, , ), and data received from a Long Poll server (events with code 4) are taken into account.
	GroupID       int64         // Group ID (for group messages with user access token)
	LpVersion     int64
	LastN         int64
	Credentials   bool
}

func (req MessagesGetLongPollHistory) params() Params {
	params := make(Params)
	if req.Ts != 0 {
		params["ts"] = req.Ts
	}
	if req.Pts != 0 {
		params["pts"] = req.Pts
	}
	if req.PreviewLength != 0 {
		params["preview_length"] = req.PreviewLength
	}
	if req.Onlines {
		params["onlines"] = req.Onlines
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.EventsLimit != 0 {
		params["events_limit"] = req.EventsLimit
	}
	if req.MsgsLimit != 0 {
		params["msgs_limit"] = req.MsgsLimit
	}
	if req.MaxMsgID != 0 {
		params["max_msg_id"] = req.MaxMsgID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.LpVersion != 0 {
		params["lp_version"] = req.LpVersion
	}
	if req.LastN != 0 {
		params["last_n"] = req.LastN
	}
	if req.Credentials {
		params["credentials"] = req.Credentials
	}
	return params
}

// MessagesGetLongPollServer.
//
// Returns data required for connection to a Long Poll server.
//
// https://vk.com/dev/messages.getLongPollServer
type MessagesGetLongPollServer struct {
	NeedPts   bool  // '1' — to return the 'pts' field, needed for the [vk.com/dev/messages.getLongPollHistory|messages.getLongPollHistory] method.
	GroupID   int64 // Group ID (for group messages with user access token)
	LpVersion int64 // Long poll version
}

func (req MessagesGetLongPollServer) params() Params {
	params := make(Params)
	if req.NeedPts {
		params["need_pts"] = req.NeedPts
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.LpVersion != 0 {
		params["lp_version"] = req.LpVersion
	}
	return params
}

// MessagesIsMessagesFromGroupAllowed.
//
// Returns information whether sending messages from the community to current user is allowed.
//
// https://vk.com/dev/messages.isMessagesFromGroupAllowed
type MessagesIsMessagesFromGroupAllowed struct {
	GroupID int64 // Group ID.
	UserID  int64 // User ID.
}

func (req MessagesIsMessagesFromGroupAllowed) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// MessagesJoinChatByInviteLink.
//
// https://vk.com/dev/messages.joinChatByInviteLink
type MessagesJoinChatByInviteLink struct {
	Link string // Invitation link.
}

func (req MessagesJoinChatByInviteLink) params() Params {
	params := make(Params)
	if req.Link != "" {
		params["link"] = req.Link
	}
	return params
}

// MessagesMarkAsAnsweredConversation.
//
// Marks and unmarks conversations as unanswered.
//
// https://vk.com/dev/messages.markAsAnsweredConversation
type MessagesMarkAsAnsweredConversation struct {
	PeerID   int64 // ID of conversation to mark as important.
	Answered bool  // '1' — to mark as answered, '0' — to remove the mark
	GroupID  int64 // Group ID (for group messages with group access token)
}

func (req MessagesMarkAsAnsweredConversation) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Answered {
		params["answered"] = req.Answered
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesMarkAsImportant.
//
// Marks and unmarks messages as important (starred).
//
// https://vk.com/dev/messages.markAsImportant
type MessagesMarkAsImportant struct {
	MessageIDs []int64 // IDs of messages to mark as important.
	Important  int64   // '1' — to add a star (mark as important), '0' — to remove the star
}

func (req MessagesMarkAsImportant) params() Params {
	params := make(Params)
	if len(req.MessageIDs) > 0 {
		params["message_ids"] = req.MessageIDs
	}
	if req.Important != 0 {
		params["important"] = req.Important
	}
	return params
}

// MessagesMarkAsImportantConversation.
//
// Marks and unmarks conversations as important.
//
// https://vk.com/dev/messages.markAsImportantConversation
type MessagesMarkAsImportantConversation struct {
	PeerID    int64 // ID of conversation to mark as important.
	Important bool  // '1' — to add a star (mark as important), '0' — to remove the star
	GroupID   int64 // Group ID (for group messages with group access token)
}

func (req MessagesMarkAsImportantConversation) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Important {
		params["important"] = req.Important
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesMarkAsRead.
//
// Marks messages as read.
//
// https://vk.com/dev/messages.markAsRead
type MessagesMarkAsRead struct {
	MessageIDs             []int64 // IDs of messages to mark as read.
	PeerID                 int64   // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	StartMessageID         int64   // Message ID to start from.
	GroupID                int64   // Group ID (for group messages with user access token)
	MarkConversationAsRead bool
}

func (req MessagesMarkAsRead) params() Params {
	params := make(Params)
	if len(req.MessageIDs) > 0 {
		params["message_ids"] = req.MessageIDs
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.StartMessageID != 0 {
		params["start_message_id"] = req.StartMessageID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.MarkConversationAsRead {
		params["mark_conversation_as_read"] = req.MarkConversationAsRead
	}
	return params
}

// MessagesPin.
//
// Pin a message.
//
// https://vk.com/dev/messages.pin
type MessagesPin struct {
	PeerID    int64 // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
	MessageID int64
}

func (req MessagesPin) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.MessageID != 0 {
		params["message_id"] = req.MessageID
	}
	return params
}

// MessagesRemoveChatUser.
//
// Allows the current user to leave a chat or, if the current user started the chat, allows the user to remove another user from the chat.
//
// https://vk.com/dev/messages.removeChatUser
type MessagesRemoveChatUser struct {
	ChatID   int64 // Chat ID.
	UserID   int64 // ID of the user to be removed from the chat.
	MemberID int64
}

func (req MessagesRemoveChatUser) params() Params {
	params := make(Params)
	if req.ChatID != 0 {
		params["chat_id"] = req.ChatID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.MemberID != 0 {
		params["member_id"] = req.MemberID
	}
	return params
}

// MessagesRestore.
//
// Restores a deleted message.
//
// https://vk.com/dev/messages.restore
type MessagesRestore struct {
	MessageID int64 // ID of a previously-deleted message to restore.
	GroupID   int64 // Group ID (for group messages with user access token)
}

func (req MessagesRestore) params() Params {
	params := make(Params)
	if req.MessageID != 0 {
		params["message_id"] = req.MessageID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesSearch.
//
// Returns a list of the current user's private messages that match search criteria.
//
// https://vk.com/dev/messages.search
type MessagesSearch struct {
	Q             string // Search query string.
	PeerID        int64  // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	Date          int64  // Date to search message before in Unixtime.
	PreviewLength int64  // Number of characters after which to truncate a previewed message. To preview the full message, specify '0'. "NOTE: Messages are not truncated by default. Messages are truncated by words."
	Offset        int64  // Offset needed to return a specific subset of messages.
	Count         int64  // Number of messages to return.
	Extended      bool
	Fields        []string
	GroupID       int64 // Group ID (for group messages with group access token)
}

func (req MessagesSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Date != 0 {
		params["date"] = req.Date
	}
	if req.PreviewLength != 0 {
		params["preview_length"] = req.PreviewLength
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesSearchConversations.
//
// Returns a list of the current user's conversations that match search criteria.
//
// https://vk.com/dev/messages.searchConversations
type MessagesSearchConversations struct {
	Q        string        // Search query string.
	Count    int64         // Maximum number of results.
	Extended bool          // '1' — return extra information about users and communities
	Fields   []UsersFields // Profile fields to return.
	GroupID  int64         // Group ID (for group messages with user access token)
}

func (req MessagesSearchConversations) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesSend.
//
// Sends a message.
//
// https://vk.com/dev/messages.send
type MessagesSend struct {
	UserID          int64   // User ID (by default — current user).
	RandomID        int64   // Unique identifier to avoid resending the message.
	PeerID          int64   // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	Domain          string  // User's short address (for example, 'illarionov').
	ChatID          int64   // ID of conversation the message will relate to.
	UserIDs         []int64 // IDs of message recipients (if new conversation shall be started).
	Message         string  // (Required if 'attachments' is not set.) Text of the message.
	Lat             float64 // Geographical latitude of a check-in, in degrees (from -90 to 90).
	Long            float64 // Geographical longitude of a check-in, in degrees (from -180 to 180).
	Attachment      string  // (Required if 'message' is not set.) List of objects attached to the message, separated by commas, in the following format: "<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'wall' — wall post, '<owner_id>' — ID of the media attachment owner. '<media_id>' — media attachment ID. Example: "photo100172_166443618"
	ReplyTo         int64
	ForwardMessages []int64 // ID of forwarded messages, separated with a comma. Listed messages of the sender will be shown in the message body at the recipient's. Example: "123,431,544"
	StickerID       int64   // Sticker id.
	GroupID         int64   // Group ID (for group messages with group access token)
	Keyboard        *MessagesKeyboard
	Payload         string
	DontParseLinks  bool
	DisableMentions bool
	Intent          string
	SubscribeID     int64
}

func (req MessagesSend) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.RandomID != 0 {
		params["random_id"] = req.RandomID
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.Domain != "" {
		params["domain"] = req.Domain
	}
	if req.ChatID != 0 {
		params["chat_id"] = req.ChatID
	}
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.Attachment != "" {
		params["attachment"] = req.Attachment
	}
	if req.ReplyTo != 0 {
		params["reply_to"] = req.ReplyTo
	}
	if len(req.ForwardMessages) > 0 {
		params["forward_messages"] = req.ForwardMessages
	}
	if req.StickerID != 0 {
		params["sticker_id"] = req.StickerID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Keyboard != nil {
		params["keyboard"] = req.Keyboard
	}
	if req.Payload != "" {
		params["payload"] = req.Payload
	}
	if req.DontParseLinks {
		params["dont_parse_links"] = req.DontParseLinks
	}
	if req.DisableMentions {
		params["disable_mentions"] = req.DisableMentions
	}
	if req.Intent != "" {
		params["intent"] = req.Intent
	}
	if req.SubscribeID != 0 {
		params["subscribe_id"] = req.SubscribeID
	}
	return params
}

// MessagesSendMessageEventAnswer.
//
// https://vk.com/dev/messages.sendMessageEventAnswer
type MessagesSendMessageEventAnswer struct {
	EventID   string
	UserID    int64
	PeerID    int64
	EventData string
}

func (req MessagesSendMessageEventAnswer) params() Params {
	params := make(Params)
	if req.EventID != "" {
		params["event_id"] = req.EventID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.EventData != "" {
		params["event_data"] = req.EventData
	}
	return params
}

// MessagesSetActivity.
//
// Changes the status of a user as typing in a conversation.
//
// https://vk.com/dev/messages.setActivity
type MessagesSetActivity struct {
	UserID  int64  // User ID.
	Type    string // 'typing' — user has started to type.
	PeerID  int64  // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	GroupID int64  // Group ID (for group messages with group access token)
}

func (req MessagesSetActivity) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// MessagesSetChatPhoto.
//
// Sets a previously-uploaded picture as the cover picture of a chat.
//
// https://vk.com/dev/messages.setChatPhoto
type MessagesSetChatPhoto struct {
	File string // Upload URL from the 'response' field returned by the [vk.com/dev/photos.getChatUploadServer|photos.getChatUploadServer] method upon successfully uploading an image.
}

func (req MessagesSetChatPhoto) params() Params {
	params := make(Params)
	if req.File != "" {
		params["file"] = req.File
	}
	return params
}

// MessagesUnpin.
//
// https://vk.com/dev/messages.unpin
type MessagesUnpin struct {
	PeerID  int64
	GroupID int64
}

func (req MessagesUnpin) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// NewsfeedAddBan.
//
// Prevents news from specified users and communities from appearing in the current user's newsfeed.
//
// https://vk.com/dev/newsfeed.addBan
type NewsfeedAddBan struct {
	UserIDs  []int64
	GroupIDs []int64
}

func (req NewsfeedAddBan) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if len(req.GroupIDs) > 0 {
		params["group_ids"] = req.GroupIDs
	}
	return params
}

// NewsfeedDeleteBan.
//
// Allows news from previously banned users and communities to be shown in the current user's newsfeed.
//
// https://vk.com/dev/newsfeed.deleteBan
type NewsfeedDeleteBan struct {
	UserIDs  []int64
	GroupIDs []int64
}

func (req NewsfeedDeleteBan) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if len(req.GroupIDs) > 0 {
		params["group_ids"] = req.GroupIDs
	}
	return params
}

// NewsfeedDeleteList.
//
// https://vk.com/dev/newsfeed.deleteList
type NewsfeedDeleteList struct {
	ListID int64
}

func (req NewsfeedDeleteList) params() Params {
	params := make(Params)
	if req.ListID != 0 {
		params["list_id"] = req.ListID
	}
	return params
}

// NewsfeedGet.
//
// Returns data required to show newsfeed for the current user.
//
// https://vk.com/dev/newsfeed.get
type NewsfeedGet struct {
	Filters      []NewsfeedFilters     // Filters to apply: 'post' — new wall posts, 'photo' — new photos, 'photo_tag' — new photo tags, 'wall_photo' — new wall photos, 'friend' — new friends, 'note' — new notes
	ReturnBanned bool                  // '1' — to return news items from banned sources
	StartTime    int64                 // Earliest timestamp (in Unix time) of a news item to return. By default, 24 hours ago.
	EndTime      int64                 // Latest timestamp (in Unix time) of a news item to return. By default, the current time.
	MaxPhotos    int64                 // Maximum number of photos to return. By default, '5'.
	SourceIDs    string                // Sources to obtain news from, separated by commas. User IDs can be specified in formats '' or 'u' , where '' is the user's friend ID. Community IDs can be specified in formats '-' or 'g' , where '' is the community ID. If the parameter is not set, all of the user's friends and communities are returned, except for banned sources, which can be obtained with the [vk.com/dev/newsfeed.getBanned|newsfeed.getBanned] method.
	StartFrom    string                // identifier required to get the next page of results. Value for this parameter is returned in 'next_from' field in a reply.
	Count        int64                 // Number of news items to return (default 50, maximum 100). For auto feed, you can use the 'new_offset' parameter returned by this method.
	Fields       []BaseUserGroupFields // Additional fields of [vk.com/dev/fields|profiles] and [vk.com/dev/fields_groups|communities] to return.
	Section      string
}

func (req NewsfeedGet) params() Params {
	params := make(Params)
	if len(req.Filters) > 0 {
		params["filters"] = req.Filters
	}
	if req.ReturnBanned {
		params["return_banned"] = req.ReturnBanned
	}
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	if req.MaxPhotos != 0 {
		params["max_photos"] = req.MaxPhotos
	}
	if req.SourceIDs != "" {
		params["source_ids"] = req.SourceIDs
	}
	if req.StartFrom != "" {
		params["start_from"] = req.StartFrom
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.Section != "" {
		params["section"] = req.Section
	}
	return params
}

// NewsfeedGetBanned.
//
// Returns a list of users and communities banned from the current user's newsfeed.
//
// https://vk.com/dev/newsfeed.getBanned
type NewsfeedGetBanned struct {
	Extended bool          // '1' — return extra information about users and communities
	Fields   []UsersFields // Profile fields to return.
	NameCase string        // Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
}

func (req NewsfeedGetBanned) params() Params {
	params := make(Params)
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// NewsfeedGetComments.
//
// Returns a list of comments in the current user's newsfeed.
//
// https://vk.com/dev/newsfeed.getComments
type NewsfeedGetComments struct {
	Count             int64                     // Number of comments to return. For auto feed, you can use the 'new_offset' parameter returned by this method.
	Filters           []NewsfeedCommentsFilters // Filters to apply: 'post' — new comments on wall posts, 'photo' — new comments on photos, 'video' — new comments on videos, 'topic' — new comments on discussions, 'note' — new comments on notes,
	Reposts           string                    // Object ID, comments on repost of which shall be returned, e.g. 'wall1_45486'. (If the parameter is set, the 'filters' parameter is optional.),
	StartTime         int64                     // Earliest timestamp (in Unix time) of a comment to return. By default, 24 hours ago.
	EndTime           int64                     // Latest timestamp (in Unix time) of a comment to return. By default, the current time.
	LastCommentsCount int64
	StartFrom         string                // Identificator needed to return the next page with results. Value for this parameter returns in 'next_from' field.
	Fields            []BaseUserGroupFields // Additional fields of [vk.com/dev/fields|profiles] and [vk.com/dev/fields_groups|communities] to return.
}

func (req NewsfeedGetComments) params() Params {
	params := make(Params)
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Filters) > 0 {
		params["filters"] = req.Filters
	}
	if req.Reposts != "" {
		params["reposts"] = req.Reposts
	}
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	if req.LastCommentsCount != 0 {
		params["last_comments_count"] = req.LastCommentsCount
	}
	if req.StartFrom != "" {
		params["start_from"] = req.StartFrom
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// NewsfeedGetLists.
//
// Returns a list of newsfeeds followed by the current user.
//
// https://vk.com/dev/newsfeed.getLists
type NewsfeedGetLists struct {
	ListIDs  []int64 // numeric list identifiers.
	Extended bool    // Return additional list info
}

func (req NewsfeedGetLists) params() Params {
	params := make(Params)
	if len(req.ListIDs) > 0 {
		params["list_ids"] = req.ListIDs
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// NewsfeedGetMentions.
//
// Returns a list of posts on user walls in which the current user is mentioned.
//
// https://vk.com/dev/newsfeed.getMentions
type NewsfeedGetMentions struct {
	OwnerID   int64 // Owner ID.
	StartTime int64 // Earliest timestamp (in Unix time) of a post to return. By default, 24 hours ago.
	EndTime   int64 // Latest timestamp (in Unix time) of a post to return. By default, the current time.
	Offset    int64 // Offset needed to return a specific subset of posts.
	Count     int64 // Number of posts to return.
}

func (req NewsfeedGetMentions) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// NewsfeedGetRecommended.
//
// , Returns a list of newsfeeds recommended to the current user.
//
// https://vk.com/dev/newsfeed.getRecommended
type NewsfeedGetRecommended struct {
	StartTime int64                 // Earliest timestamp (in Unix time) of a news item to return. By default, 24 hours ago.
	EndTime   int64                 // Latest timestamp (in Unix time) of a news item to return. By default, the current time.
	MaxPhotos int64                 // Maximum number of photos to return. By default, '5'.
	StartFrom string                // 'new_from' value obtained in previous call.
	Count     int64                 // Number of news items to return.
	Fields    []BaseUserGroupFields // Additional fields of [vk.com/dev/fields|profiles] and [vk.com/dev/fields_groups|communities] to return.
}

func (req NewsfeedGetRecommended) params() Params {
	params := make(Params)
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	if req.MaxPhotos != 0 {
		params["max_photos"] = req.MaxPhotos
	}
	if req.StartFrom != "" {
		params["start_from"] = req.StartFrom
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// NewsfeedGetSuggestedSources.
//
// Returns communities and users that current user is suggested to follow.
//
// https://vk.com/dev/newsfeed.getSuggestedSources
type NewsfeedGetSuggestedSources struct {
	Offset  int64                 // offset required to choose a particular subset of communities or users.
	Count   int64                 // amount of communities or users to return.
	Shuffle bool                  // shuffle the returned list or not.
	Fields  []BaseUserGroupFields // list of extra fields to be returned. See available fields for [vk.com/dev/fields|users] and [vk.com/dev/fields_groups|communities].
}

func (req NewsfeedGetSuggestedSources) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Shuffle {
		params["shuffle"] = req.Shuffle
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// NewsfeedIgnoreItem.
//
// Hides an item from the newsfeed.
//
// https://vk.com/dev/newsfeed.ignoreItem
type NewsfeedIgnoreItem struct {
	Type    *NewsfeedIgnoreItemType // Item type. Possible values: *'wall' – post on the wall,, *'tag' – tag on a photo,, *'profilephoto' – profile photo,, *'video' – video,, *'audio' – audio.
	OwnerID int64                   // Item owner's identifier (user or community), "Note that community id must be negative. 'owner_id=1' – user , 'owner_id=-1' – community "
	ItemID  int64                   // Item identifier
}

func (req NewsfeedIgnoreItem) params() Params {
	params := make(Params)
	if req.Type != nil {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	return params
}

// NewsfeedSaveList.
//
// Creates and edits user newsfeed lists
//
// https://vk.com/dev/newsfeed.saveList
type NewsfeedSaveList struct {
	ListID    int64   // numeric list identifier (if not sent, will be set automatically).
	Title     string  // list name.
	SourceIDs []int64 // users and communities identifiers to be added to the list. Community identifiers must be negative numbers.
	NoReposts bool    // reposts display on and off ('1' is for off).
}

func (req NewsfeedSaveList) params() Params {
	params := make(Params)
	if req.ListID != 0 {
		params["list_id"] = req.ListID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if len(req.SourceIDs) > 0 {
		params["source_ids"] = req.SourceIDs
	}
	if req.NoReposts {
		params["no_reposts"] = req.NoReposts
	}
	return params
}

// NewsfeedSearch.
//
// Returns search results by statuses.
//
// https://vk.com/dev/newsfeed.search
type NewsfeedSearch struct {
	Q         string  // Search query string (e.g., 'New Year').
	Extended  bool    // '1' — to return additional information about the user or community that placed the post.
	Count     int64   // Number of posts to return.
	Latitude  float64 // Geographical latitude point (in degrees, -90 to 90) within which to search.
	Longitude float64 // Geographical longitude point (in degrees, -180 to 180) within which to search.
	StartTime int64   // Earliest timestamp (in Unix time) of a news item to return. By default, 24 hours ago.
	EndTime   int64   // Latest timestamp (in Unix time) of a news item to return. By default, the current time.
	StartFrom string
	Fields    []BaseUserGroupFields // Additional fields of [vk.com/dev/fields|profiles] and [vk.com/dev/fields_groups|communities] to return.
}

func (req NewsfeedSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	if req.StartFrom != "" {
		params["start_from"] = req.StartFrom
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// NewsfeedUnignoreItem.
//
// Returns a hidden item to the newsfeed.
//
// https://vk.com/dev/newsfeed.unignoreItem
type NewsfeedUnignoreItem struct {
	Type      *NewsfeedIgnoreItemType // Item type. Possible values: *'wall' – post on the wall,, *'tag' – tag on a photo,, *'profilephoto' – profile photo,, *'video' – video,, *'audio' – audio.
	OwnerID   int64                   // Item owner's identifier (user or community), "Note that community id must be negative. 'owner_id=1' – user , 'owner_id=-1' – community "
	ItemID    int64                   // Item identifier
	TrackCode string                  // Track code of unignored item
}

func (req NewsfeedUnignoreItem) params() Params {
	params := make(Params)
	if req.Type != nil {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	if req.TrackCode != "" {
		params["track_code"] = req.TrackCode
	}
	return params
}

// NewsfeedUnsubscribe.
//
// Unsubscribes the current user from specified newsfeeds.
//
// https://vk.com/dev/newsfeed.unsubscribe
type NewsfeedUnsubscribe struct {
	Type    string // Type of object from which to unsubscribe: 'note' — note, 'photo' — photo, 'post' — post on user wall or community wall, 'topic' — topic, 'video' — video
	OwnerID int64  // Object owner ID.
	ItemID  int64  // Object ID.
}

func (req NewsfeedUnsubscribe) params() Params {
	params := make(Params)
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ItemID != 0 {
		params["item_id"] = req.ItemID
	}
	return params
}

// NotesAdd.
//
// Creates a new note for the current user.
//
// https://vk.com/dev/notes.add
type NotesAdd struct {
	Title          string // Note title.
	Text           string // Note text.
	PrivacyView    []string
	PrivacyComment []string
}

func (req NotesAdd) params() Params {
	params := make(Params)
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	if len(req.PrivacyView) > 0 {
		params["privacy_view"] = req.PrivacyView
	}
	if len(req.PrivacyComment) > 0 {
		params["privacy_comment"] = req.PrivacyComment
	}
	return params
}

// NotesCreateComment.
//
// Adds a new comment on a note.
//
// https://vk.com/dev/notes.createComment
type NotesCreateComment struct {
	NoteID  int64  // Note ID.
	OwnerID int64  // Note owner ID.
	ReplyTo int64  // ID of the user to whom the reply is addressed (if the comment is a reply to another comment).
	Message string // Comment text.
	Guid    string
}

func (req NotesCreateComment) params() Params {
	params := make(Params)
	if req.NoteID != 0 {
		params["note_id"] = req.NoteID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.ReplyTo != 0 {
		params["reply_to"] = req.ReplyTo
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	return params
}

// NotesDelete.
//
// Deletes a note of the current user.
//
// https://vk.com/dev/notes.delete
type NotesDelete struct {
	NoteID int64 // Note ID.
}

func (req NotesDelete) params() Params {
	params := make(Params)
	if req.NoteID != 0 {
		params["note_id"] = req.NoteID
	}
	return params
}

// NotesDeleteComment.
//
// Deletes a comment on a note.
//
// https://vk.com/dev/notes.deleteComment
type NotesDeleteComment struct {
	CommentID int64 // Comment ID.
	OwnerID   int64 // Note owner ID.
}

func (req NotesDeleteComment) params() Params {
	params := make(Params)
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// NotesEdit.
//
// Edits a note of the current user.
//
// https://vk.com/dev/notes.edit
type NotesEdit struct {
	NoteID         int64  // Note ID.
	Title          string // Note title.
	Text           string // Note text.
	PrivacyView    []string
	PrivacyComment []string
}

func (req NotesEdit) params() Params {
	params := make(Params)
	if req.NoteID != 0 {
		params["note_id"] = req.NoteID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Text != "" {
		params["text"] = req.Text
	}
	if len(req.PrivacyView) > 0 {
		params["privacy_view"] = req.PrivacyView
	}
	if len(req.PrivacyComment) > 0 {
		params["privacy_comment"] = req.PrivacyComment
	}
	return params
}

// NotesEditComment.
//
// Edits a comment on a note.
//
// https://vk.com/dev/notes.editComment
type NotesEditComment struct {
	CommentID int64  // Comment ID.
	OwnerID   int64  // Note owner ID.
	Message   string // New comment text.
}

func (req NotesEditComment) params() Params {
	params := make(Params)
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	return params
}

// NotesGet.
//
// Returns a list of notes created by a user.
//
// https://vk.com/dev/notes.get
type NotesGet struct {
	NoteIDs []int64 // Note IDs.
	UserID  int64   // Note owner ID.
	Offset  int64
	Count   int64 // Number of notes to return.
	Sort    int64
}

func (req NotesGet) params() Params {
	params := make(Params)
	if len(req.NoteIDs) > 0 {
		params["note_ids"] = req.NoteIDs
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	return params
}

// NotesGetByID.
//
// Returns a note by its ID.
//
// https://vk.com/dev/notes.getById
type NotesGetByID struct {
	NoteID   int64 // Note ID.
	OwnerID  int64 // Note owner ID.
	NeedWiki bool
}

func (req NotesGetByID) params() Params {
	params := make(Params)
	if req.NoteID != 0 {
		params["note_id"] = req.NoteID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.NeedWiki {
		params["need_wiki"] = req.NeedWiki
	}
	return params
}

// NotesGetComments.
//
// Returns a list of comments on a note.
//
// https://vk.com/dev/notes.getComments
type NotesGetComments struct {
	NoteID  int64 // Note ID.
	OwnerID int64 // Note owner ID.
	Sort    int64
	Offset  int64
	Count   int64 // Number of comments to return.
}

func (req NotesGetComments) params() Params {
	params := make(Params)
	if req.NoteID != 0 {
		params["note_id"] = req.NoteID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// NotesRestoreComment.
//
// Restores a deleted comment on a note.
//
// https://vk.com/dev/notes.restoreComment
type NotesRestoreComment struct {
	CommentID int64 // Comment ID.
	OwnerID   int64 // Note owner ID.
}

func (req NotesRestoreComment) params() Params {
	params := make(Params)
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// NotificationsGet.
//
// Returns a list of notifications about other users' feedback to the current user's wall posts.
//
// https://vk.com/dev/notifications.get
type NotificationsGet struct {
	Count     int64 // Number of notifications to return.
	StartFrom string
	Filters   []string // Type of notifications to return: 'wall' — wall posts, 'mentions' — mentions in wall posts, comments, or topics, 'comments' — comments to wall posts, photos, and videos, 'likes' — likes, 'reposted' — wall posts that are copied from the current user's wall, 'followers' — new followers, 'friends' — accepted friend requests
	StartTime int64    // Earliest timestamp (in Unix time) of a notification to return. By default, 24 hours ago.
	EndTime   int64    // Latest timestamp (in Unix time) of a notification to return. By default, the current time.
}

func (req NotificationsGet) params() Params {
	params := make(Params)
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.StartFrom != "" {
		params["start_from"] = req.StartFrom
	}
	if len(req.Filters) > 0 {
		params["filters"] = req.Filters
	}
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	return params
}

// NotificationsMarkAsViewed.
//
// Resets the counter of new notifications about other users' feedback to the current user's wall posts.
//
// https://vk.com/dev/notifications.markAsViewed
type NotificationsMarkAsViewed struct {
}

func (req NotificationsMarkAsViewed) params() Params {
	params := make(Params)
	return params
}

// NotificationsSendMessage.
//
// https://vk.com/dev/notifications.sendMessage
type NotificationsSendMessage struct {
	UserIDs  []int64
	Message  string
	Fragment string
	GroupID  int64
	RandomID int64
}

func (req NotificationsSendMessage) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if req.Fragment != "" {
		params["fragment"] = req.Fragment
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.RandomID != 0 {
		params["random_id"] = req.RandomID
	}
	return params
}

// OrdersCancelSubscription.
//
// https://vk.com/dev/orders.cancelSubscription
type OrdersCancelSubscription struct {
	UserID         int64
	SubscriptionID int64
	PendingCancel  bool
}

func (req OrdersCancelSubscription) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.SubscriptionID != 0 {
		params["subscription_id"] = req.SubscriptionID
	}
	if req.PendingCancel {
		params["pending_cancel"] = req.PendingCancel
	}
	return params
}

// OrdersChangeState.
//
// Changes order status.
//
// https://vk.com/dev/orders.changeState
type OrdersChangeState struct {
	OrderID    int64  // order ID.
	Action     string // action to be done with the order. Available actions: *cancel — to cancel unconfirmed order. *charge — to confirm unconfirmed order. Applies only if processing of [vk.com/dev/payments_status|order_change_state] notification failed. *refund — to cancel confirmed order.
	AppOrderID int64  // internal ID of the order in the application.
	TestMode   bool   // if this parameter is set to 1, this method returns a list of test mode orders. By default — 0.
}

func (req OrdersChangeState) params() Params {
	params := make(Params)
	if req.OrderID != 0 {
		params["order_id"] = req.OrderID
	}
	if req.Action != "" {
		params["action"] = req.Action
	}
	if req.AppOrderID != 0 {
		params["app_order_id"] = req.AppOrderID
	}
	if req.TestMode {
		params["test_mode"] = req.TestMode
	}
	return params
}

// OrdersGet.
//
// Returns a list of orders.
//
// https://vk.com/dev/orders.get
type OrdersGet struct {
	Offset   int64
	Count    int64 // number of returned orders.
	TestMode bool  // if this parameter is set to 1, this method returns a list of test mode orders. By default — 0.
}

func (req OrdersGet) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.TestMode {
		params["test_mode"] = req.TestMode
	}
	return params
}

// OrdersGetAmount.
//
// https://vk.com/dev/orders.getAmount
type OrdersGetAmount struct {
	UserID int64
	Votes  []string
}

func (req OrdersGetAmount) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if len(req.Votes) > 0 {
		params["votes"] = req.Votes
	}
	return params
}

// OrdersGetByID.
//
// Returns information about orders by their IDs.
//
// https://vk.com/dev/orders.getById
type OrdersGetByID struct {
	OrderID  int64   // order ID.
	OrderIDs []int64 // order IDs (when information about several orders is requested).
	TestMode bool    // if this parameter is set to 1, this method returns a list of test mode orders. By default — 0.
}

func (req OrdersGetByID) params() Params {
	params := make(Params)
	if req.OrderID != 0 {
		params["order_id"] = req.OrderID
	}
	if len(req.OrderIDs) > 0 {
		params["order_ids"] = req.OrderIDs
	}
	if req.TestMode {
		params["test_mode"] = req.TestMode
	}
	return params
}

// OrdersGetUserSubscriptionByID.
//
// https://vk.com/dev/orders.getUserSubscriptionById
type OrdersGetUserSubscriptionByID struct {
	UserID         int64
	SubscriptionID int64
}

func (req OrdersGetUserSubscriptionByID) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.SubscriptionID != 0 {
		params["subscription_id"] = req.SubscriptionID
	}
	return params
}

// OrdersGetUserSubscriptions.
//
// https://vk.com/dev/orders.getUserSubscriptions
type OrdersGetUserSubscriptions struct {
	UserID int64
}

func (req OrdersGetUserSubscriptions) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// OrdersUpdateSubscription.
//
// https://vk.com/dev/orders.updateSubscription
type OrdersUpdateSubscription struct {
	UserID         int64
	SubscriptionID int64
	Price          int64
}

func (req OrdersUpdateSubscription) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.SubscriptionID != 0 {
		params["subscription_id"] = req.SubscriptionID
	}
	if req.Price != 0 {
		params["price"] = req.Price
	}
	return params
}

// PagesClearCache.
//
// Allows to clear the cache of particular 'external' pages which may be attached to VK posts.
//
// https://vk.com/dev/pages.clearCache
type PagesClearCache struct {
	URL string // Address of the page where you need to refesh the cached version
}

func (req PagesClearCache) params() Params {
	params := make(Params)
	if req.URL != "" {
		params["url"] = req.URL
	}
	return params
}

// PagesGet.
//
// Returns information about a wiki page.
//
// https://vk.com/dev/pages.get
type PagesGet struct {
	OwnerID     int64  // Page owner ID.
	PageID      int64  // Wiki page ID.
	Global      bool   // '1' — to return information about a global wiki page
	SitePreview bool   // '1' — resulting wiki page is a preview for the attached link
	Title       string // Wiki page title.
	NeedSource  bool
	NeedHtml    bool // '1' — to return the page as HTML,
}

func (req PagesGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PageID != 0 {
		params["page_id"] = req.PageID
	}
	if req.Global {
		params["global"] = req.Global
	}
	if req.SitePreview {
		params["site_preview"] = req.SitePreview
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.NeedSource {
		params["need_source"] = req.NeedSource
	}
	if req.NeedHtml {
		params["need_html"] = req.NeedHtml
	}
	return params
}

// PagesGetHistory.
//
// Returns a list of all previous versions of a wiki page.
//
// https://vk.com/dev/pages.getHistory
type PagesGetHistory struct {
	PageID  int64 // Wiki page ID.
	GroupID int64 // ID of the community that owns the wiki page.
	UserID  int64
}

func (req PagesGetHistory) params() Params {
	params := make(Params)
	if req.PageID != 0 {
		params["page_id"] = req.PageID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// PagesGetTitles.
//
// Returns a list of wiki pages in a group.
//
// https://vk.com/dev/pages.getTitles
type PagesGetTitles struct {
	GroupID int64 // ID of the community that owns the wiki page.
}

func (req PagesGetTitles) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// PagesGetVersion.
//
// Returns the text of one of the previous versions of a wiki page.
//
// https://vk.com/dev/pages.getVersion
type PagesGetVersion struct {
	VersionID int64
	GroupID   int64 // ID of the community that owns the wiki page.
	UserID    int64
	NeedHtml  bool // '1' — to return the page as HTML
}

func (req PagesGetVersion) params() Params {
	params := make(Params)
	if req.VersionID != 0 {
		params["version_id"] = req.VersionID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.NeedHtml {
		params["need_html"] = req.NeedHtml
	}
	return params
}

// PagesParseWiki.
//
// Returns HTML representation of the wiki markup.
//
// https://vk.com/dev/pages.parseWiki
type PagesParseWiki struct {
	Text    string // Text of the wiki page.
	GroupID int64  // ID of the group in the context of which this markup is interpreted.
}

func (req PagesParseWiki) params() Params {
	params := make(Params)
	if req.Text != "" {
		params["text"] = req.Text
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// PagesSave.
//
// Saves the text of a wiki page.
//
// https://vk.com/dev/pages.save
type PagesSave struct {
	Text    string // Text of the wiki page in wiki-format.
	PageID  int64  // Wiki page ID. The 'title' parameter can be passed instead of 'pid'.
	GroupID int64  // ID of the community that owns the wiki page.
	UserID  int64  // User ID
	Title   string // Wiki page title.
}

func (req PagesSave) params() Params {
	params := make(Params)
	if req.Text != "" {
		params["text"] = req.Text
	}
	if req.PageID != 0 {
		params["page_id"] = req.PageID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	return params
}

// PagesSaveAccess.
//
// Saves modified read and edit access settings for a wiki page.
//
// https://vk.com/dev/pages.saveAccess
type PagesSaveAccess struct {
	PageID  int64 // Wiki page ID.
	GroupID int64 // ID of the community that owns the wiki page.
	UserID  int64
	View    int64 // Who can view the wiki page: '1' — only community members, '2' — all users can view the page, '0' — only community managers
	Edit    int64 // Who can edit the wiki page: '1' — only community members, '2' — all users can edit the page, '0' — only community managers
}

func (req PagesSaveAccess) params() Params {
	params := make(Params)
	if req.PageID != 0 {
		params["page_id"] = req.PageID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.View != 0 {
		params["view"] = req.View
	}
	if req.Edit != 0 {
		params["edit"] = req.Edit
	}
	return params
}

// PhotosConfirmTag.
//
// Confirms a tag on a photo.
//
// https://vk.com/dev/photos.confirmTag
type PhotosConfirmTag struct {
	OwnerID int64  // ID of the user or community that owns the photo.
	PhotoID string // Photo ID.
	TagID   int64  // Tag ID.
}

func (req PhotosConfirmTag) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != "" {
		params["photo_id"] = req.PhotoID
	}
	if req.TagID != 0 {
		params["tag_id"] = req.TagID
	}
	return params
}

// PhotosCopy.
//
// Allows to copy a photo to the "Saved photos" album
//
// https://vk.com/dev/photos.copy
type PhotosCopy struct {
	OwnerID   int64  // photo's owner ID
	PhotoID   int64  // photo ID
	AccessKey string // for private photos
}

func (req PhotosCopy) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// PhotosCreateAlbum.
//
// Creates an empty photo album.
//
// https://vk.com/dev/photos.createAlbum
type PhotosCreateAlbum struct {
	Title              string // Album title.
	GroupID            int64  // ID of the community in which the album will be created.
	Description        string // Album description.
	PrivacyView        []string
	PrivacyComment     []string
	UploadByAdminsOnly bool
	CommentsDisabled   bool
}

func (req PhotosCreateAlbum) params() Params {
	params := make(Params)
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if len(req.PrivacyView) > 0 {
		params["privacy_view"] = req.PrivacyView
	}
	if len(req.PrivacyComment) > 0 {
		params["privacy_comment"] = req.PrivacyComment
	}
	if req.UploadByAdminsOnly {
		params["upload_by_admins_only"] = req.UploadByAdminsOnly
	}
	if req.CommentsDisabled {
		params["comments_disabled"] = req.CommentsDisabled
	}
	return params
}

// PhotosCreateComment.
//
// Adds a new comment on the photo.
//
// https://vk.com/dev/photos.createComment
type PhotosCreateComment struct {
	OwnerID        int64    // ID of the user or community that owns the photo.
	PhotoID        int64    // Photo ID.
	Message        string   // Comment text.
	Attachments    []string // (Required if 'message' is not set.) List of objects attached to the post, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — Media attachment owner ID. '<media_id>' — Media attachment ID. Example: "photo100172_166443618,photo66748_265827614"
	FromGroup      bool     // '1' — to post a comment from the community
	ReplyToComment int64
	StickerID      int64
	AccessKey      string
	Guid           string
}

func (req PhotosCreateComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.FromGroup {
		params["from_group"] = req.FromGroup
	}
	if req.ReplyToComment != 0 {
		params["reply_to_comment"] = req.ReplyToComment
	}
	if req.StickerID != 0 {
		params["sticker_id"] = req.StickerID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	return params
}

// PhotosDelete.
//
// Deletes a photo.
//
// https://vk.com/dev/photos.delete
type PhotosDelete struct {
	OwnerID int64 // ID of the user or community that owns the photo.
	PhotoID int64 // Photo ID.
}

func (req PhotosDelete) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	return params
}

// PhotosDeleteAlbum.
//
// Deletes a photo album belonging to the current user.
//
// https://vk.com/dev/photos.deleteAlbum
type PhotosDeleteAlbum struct {
	AlbumID int64 // Album ID.
	GroupID int64 // ID of the community that owns the album.
}

func (req PhotosDeleteAlbum) params() Params {
	params := make(Params)
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// PhotosDeleteComment.
//
// Deletes a comment on the photo.
//
// https://vk.com/dev/photos.deleteComment
type PhotosDeleteComment struct {
	OwnerID   int64 // ID of the user or community that owns the photo.
	CommentID int64 // Comment ID.
}

func (req PhotosDeleteComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// PhotosEdit.
//
// Edits the caption of a photo.
//
// https://vk.com/dev/photos.edit
type PhotosEdit struct {
	OwnerID      int64  // ID of the user or community that owns the photo.
	PhotoID      int64  // Photo ID.
	Caption      string // New caption for the photo. If this parameter is not set, it is considered to be equal to an empty string.
	Latitude     float64
	Longitude    float64
	PlaceStr     string
	FoursquareID string
	DeletePlace  bool
}

func (req PhotosEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.Caption != "" {
		params["caption"] = req.Caption
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.PlaceStr != "" {
		params["place_str"] = req.PlaceStr
	}
	if req.FoursquareID != "" {
		params["foursquare_id"] = req.FoursquareID
	}
	if req.DeletePlace {
		params["delete_place"] = req.DeletePlace
	}
	return params
}

// PhotosEditAlbum.
//
// Edits information about a photo album.
//
// https://vk.com/dev/photos.editAlbum
type PhotosEditAlbum struct {
	AlbumID            int64  // ID of the photo album to be edited.
	Title              string // New album title.
	Description        string // New album description.
	OwnerID            int64  // ID of the user or community that owns the album.
	PrivacyView        []string
	PrivacyComment     []string
	UploadByAdminsOnly bool
	CommentsDisabled   bool
}

func (req PhotosEditAlbum) params() Params {
	params := make(Params)
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if len(req.PrivacyView) > 0 {
		params["privacy_view"] = req.PrivacyView
	}
	if len(req.PrivacyComment) > 0 {
		params["privacy_comment"] = req.PrivacyComment
	}
	if req.UploadByAdminsOnly {
		params["upload_by_admins_only"] = req.UploadByAdminsOnly
	}
	if req.CommentsDisabled {
		params["comments_disabled"] = req.CommentsDisabled
	}
	return params
}

// PhotosEditComment.
//
// Edits a comment on a photo.
//
// https://vk.com/dev/photos.editComment
type PhotosEditComment struct {
	OwnerID     int64    // ID of the user or community that owns the photo.
	CommentID   int64    // Comment ID.
	Message     string   // New text of the comment.
	Attachments []string // (Required if 'message' is not set.) List of objects attached to the post, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — Media attachment owner ID. '<media_id>' — Media attachment ID. Example: "photo100172_166443618,photo66748_265827614"
}

func (req PhotosEditComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	return params
}

// PhotosGet.
//
// Returns a list of a user's or community's photos.
//
// https://vk.com/dev/photos.get
type PhotosGet struct {
	OwnerID    int64    // ID of the user or community that owns the photos. Use a negative value to designate a community ID.
	AlbumID    string   // Photo album ID. To return information about photos from service albums, use the following string values: 'profile, wall, saved'.
	PhotoIDs   []string // Photo IDs.
	Rev        bool     // Sort order: '1' — reverse chronological, '0' — chronological
	Extended   bool     // '1' — to return additional 'likes', 'comments', and 'tags' fields, '0' — (default)
	FeedType   string   // Type of feed obtained in 'feed' field of the method.
	Feed       int64    // unixtime, that can be obtained with [vk.com/dev/newsfeed.get|newsfeed.get] method in date field to get all photos uploaded by the user on a specific day, or photos the user has been tagged on. Also, 'uid' parameter of the user the event happened with shall be specified.
	PhotoSizes bool     // '1' — to return photo sizes in a [vk.com/dev/photo_sizes|special format]
	Offset     int64
	Count      int64
}

func (req PhotosGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != "" {
		params["album_id"] = req.AlbumID
	}
	if len(req.PhotoIDs) > 0 {
		params["photo_ids"] = req.PhotoIDs
	}
	if req.Rev {
		params["rev"] = req.Rev
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.FeedType != "" {
		params["feed_type"] = req.FeedType
	}
	if req.Feed != 0 {
		params["feed"] = req.Feed
	}
	if req.PhotoSizes {
		params["photo_sizes"] = req.PhotoSizes
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// PhotosGetAlbums.
//
// Returns a list of a user's or community's photo albums.
//
// https://vk.com/dev/photos.getAlbums
type PhotosGetAlbums struct {
	OwnerID    int64   // ID of the user or community that owns the albums.
	AlbumIDs   []int64 // Album IDs.
	Offset     int64   // Offset needed to return a specific subset of albums.
	Count      int64   // Number of albums to return.
	NeedSystem bool    // '1' — to return system albums with negative IDs
	NeedCovers bool    // '1' — to return an additional 'thumb_src' field, '0' — (default)
	PhotoSizes bool    // '1' — to return photo sizes in a
}

func (req PhotosGetAlbums) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if len(req.AlbumIDs) > 0 {
		params["album_ids"] = req.AlbumIDs
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.NeedSystem {
		params["need_system"] = req.NeedSystem
	}
	if req.NeedCovers {
		params["need_covers"] = req.NeedCovers
	}
	if req.PhotoSizes {
		params["photo_sizes"] = req.PhotoSizes
	}
	return params
}

// PhotosGetAlbumsCount.
//
// Returns the number of photo albums belonging to a user or community.
//
// https://vk.com/dev/photos.getAlbumsCount
type PhotosGetAlbumsCount struct {
	UserID  int64 // User ID.
	GroupID int64 // Community ID.
}

func (req PhotosGetAlbumsCount) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// PhotosGetAll.
//
// Returns a list of photos belonging to a user or community, in reverse chronological order.
//
// https://vk.com/dev/photos.getAll
type PhotosGetAll struct {
	OwnerID         int64 // ID of a user or community that owns the photos. Use a negative value to designate a community ID.
	Extended        bool  // '1' — to return detailed information about photos
	Offset          int64 // Offset needed to return a specific subset of photos. By default, '0'.
	Count           int64 // Number of photos to return.
	PhotoSizes      bool  // '1' – to return image sizes in [vk.com/dev/photo_sizes|special format].
	NoServiceAlbums bool  // '1' – to return photos only from standard albums, '0' – to return all photos including those in service albums, e.g., 'My wall photos' (default)
	NeedHidden      bool  // '1' – to show information about photos being hidden from the block above the wall.
	SkipHidden      bool  // '1' – not to return photos being hidden from the block above the wall. Works only with owner_id>0, no_service_albums is ignored.
}

func (req PhotosGetAll) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.PhotoSizes {
		params["photo_sizes"] = req.PhotoSizes
	}
	if req.NoServiceAlbums {
		params["no_service_albums"] = req.NoServiceAlbums
	}
	if req.NeedHidden {
		params["need_hidden"] = req.NeedHidden
	}
	if req.SkipHidden {
		params["skip_hidden"] = req.SkipHidden
	}
	return params
}

// PhotosGetAllComments.
//
// Returns a list of comments on a specific photo album or all albums of the user sorted in reverse chronological order.
//
// https://vk.com/dev/photos.getAllComments
type PhotosGetAllComments struct {
	OwnerID   int64 // ID of the user or community that owns the album(s).
	AlbumID   int64 // Album ID. If the parameter is not set, comments on all of the user's albums will be returned.
	NeedLikes bool  // '1' — to return an additional 'likes' field, '0' — (default)
	Offset    int64 // Offset needed to return a specific subset of comments. By default, '0'.
	Count     int64 // Number of comments to return. By default, '20'. Maximum value, '100'.
}

func (req PhotosGetAllComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.NeedLikes {
		params["need_likes"] = req.NeedLikes
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// PhotosGetByID.
//
// Returns information about photos by their IDs.
//
// https://vk.com/dev/photos.getById
type PhotosGetByID struct {
	Photos     []string // IDs separated with a comma, that are IDs of users who posted photos and IDs of photos themselves with an underscore character between such IDs. To get information about a photo in the group album, you shall specify group ID instead of user ID. Example: "1_129207899,6492_135055734, , -20629724_271945303"
	Extended   bool     // '1' — to return additional fields, '0' — (default)
	PhotoSizes bool     // '1' — to return photo sizes in a
}

func (req PhotosGetByID) params() Params {
	params := make(Params)
	if len(req.Photos) > 0 {
		params["photos"] = req.Photos
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.PhotoSizes {
		params["photo_sizes"] = req.PhotoSizes
	}
	return params
}

// PhotosGetChatUploadServer.
//
// Returns an upload link for chat cover pictures.
//
// https://vk.com/dev/photos.getChatUploadServer
type PhotosGetChatUploadServer struct {
	ChatID    int64 // ID of the chat for which you want to upload a cover photo.
	CropX     int64
	CropY     int64
	CropWidth int64 // Width (in pixels) of the photo after cropping.
}

func (req PhotosGetChatUploadServer) params() Params {
	params := make(Params)
	if req.ChatID != 0 {
		params["chat_id"] = req.ChatID
	}
	if req.CropX != 0 {
		params["crop_x"] = req.CropX
	}
	if req.CropY != 0 {
		params["crop_y"] = req.CropY
	}
	if req.CropWidth != 0 {
		params["crop_width"] = req.CropWidth
	}
	return params
}

// PhotosGetComments.
//
// Returns a list of comments on a photo.
//
// https://vk.com/dev/photos.getComments
type PhotosGetComments struct {
	OwnerID        int64 // ID of the user or community that owns the photo.
	PhotoID        int64 // Photo ID.
	NeedLikes      bool  // '1' — to return an additional 'likes' field, '0' — (default)
	StartCommentID int64
	Offset         int64  // Offset needed to return a specific subset of comments. By default, '0'.
	Count          int64  // Number of comments to return.
	Sort           string // Sort order: 'asc' — old first, 'desc' — new first
	AccessKey      string
	Extended       bool
	Fields         []UsersFields
}

func (req PhotosGetComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.NeedLikes {
		params["need_likes"] = req.NeedLikes
	}
	if req.StartCommentID != 0 {
		params["start_comment_id"] = req.StartCommentID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// PhotosGetMarketAlbumUploadServer.
//
// Returns the server address for market album photo upload.
//
// https://vk.com/dev/photos.getMarketAlbumUploadServer
type PhotosGetMarketAlbumUploadServer struct {
	GroupID int64 // Community ID.
}

func (req PhotosGetMarketAlbumUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// PhotosGetMarketUploadServer.
//
// Returns the server address for market photo upload.
//
// https://vk.com/dev/photos.getMarketUploadServer
type PhotosGetMarketUploadServer struct {
	GroupID   int64 // Community ID.
	MainPhoto bool  // '1' if you want to upload the main item photo.
	CropX     int64 // X coordinate of the crop left upper corner.
	CropY     int64 // Y coordinate of the crop left upper corner.
	CropWidth int64 // Width of the cropped photo in px.
}

func (req PhotosGetMarketUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.MainPhoto {
		params["main_photo"] = req.MainPhoto
	}
	if req.CropX != 0 {
		params["crop_x"] = req.CropX
	}
	if req.CropY != 0 {
		params["crop_y"] = req.CropY
	}
	if req.CropWidth != 0 {
		params["crop_width"] = req.CropWidth
	}
	return params
}

// PhotosGetMessagesUploadServer.
//
// Returns the server address for photo upload in a private message for a user.
//
// https://vk.com/dev/photos.getMessagesUploadServer
type PhotosGetMessagesUploadServer struct {
	PeerID int64 // Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
}

func (req PhotosGetMessagesUploadServer) params() Params {
	params := make(Params)
	if req.PeerID != 0 {
		params["peer_id"] = req.PeerID
	}
	return params
}

// PhotosGetNewTags.
//
// Returns a list of photos with tags that have not been viewed.
//
// https://vk.com/dev/photos.getNewTags
type PhotosGetNewTags struct {
	Offset int64 // Offset needed to return a specific subset of photos.
	Count  int64 // Number of photos to return.
}

func (req PhotosGetNewTags) params() Params {
	params := make(Params)
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// PhotosGetOwnerCoverPhotoUploadServer.
//
// Returns the server address for owner cover upload.
//
// https://vk.com/dev/photos.getOwnerCoverPhotoUploadServer
type PhotosGetOwnerCoverPhotoUploadServer struct {
	GroupID int64 // ID of community that owns the album (if the photo will be uploaded to a community album).
	CropX   int64 // X coordinate of the left-upper corner
	CropY   int64 // Y coordinate of the left-upper corner
	CropX2  int64 // X coordinate of the right-bottom corner
	CropY2  int64 // Y coordinate of the right-bottom corner
}

func (req PhotosGetOwnerCoverPhotoUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.CropX != 0 {
		params["crop_x"] = req.CropX
	}
	if req.CropY != 0 {
		params["crop_y"] = req.CropY
	}
	if req.CropX2 != 0 {
		params["crop_x2"] = req.CropX2
	}
	if req.CropY2 != 0 {
		params["crop_y2"] = req.CropY2
	}
	return params
}

// PhotosGetOwnerPhotoUploadServer.
//
// Returns an upload server address for a profile or community photo.
//
// https://vk.com/dev/photos.getOwnerPhotoUploadServer
type PhotosGetOwnerPhotoUploadServer struct {
	OwnerID int64 // identifier of a community or current user. "Note that community id must be negative. 'owner_id=1' – user, 'owner_id=-1' – community, "
}

func (req PhotosGetOwnerPhotoUploadServer) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// PhotosGetTags.
//
// Returns a list of tags on a photo.
//
// https://vk.com/dev/photos.getTags
type PhotosGetTags struct {
	OwnerID   int64 // ID of the user or community that owns the photo.
	PhotoID   int64 // Photo ID.
	AccessKey string
}

func (req PhotosGetTags) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	return params
}

// PhotosGetUploadServer.
//
// Returns the server address for photo upload.
//
// https://vk.com/dev/photos.getUploadServer
type PhotosGetUploadServer struct {
	GroupID int64 // ID of community that owns the album (if the photo will be uploaded to a community album).
	AlbumID int64
}

func (req PhotosGetUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	return params
}

// PhotosGetUserPhotos.
//
// Returns a list of photos in which a user is tagged.
//
// https://vk.com/dev/photos.getUserPhotos
type PhotosGetUserPhotos struct {
	UserID   int64  // User ID.
	Offset   int64  // Offset needed to return a specific subset of photos. By default, '0'.
	Count    int64  // Number of photos to return. Maximum value is 1000.
	Extended bool   // '1' — to return an additional 'likes' field, '0' — (default)
	Sort     string // Sort order: '1' — by date the tag was added in ascending order, '0' — by date the tag was added in descending order
}

func (req PhotosGetUserPhotos) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	return params
}

// PhotosGetWallUploadServer.
//
// Returns the server address for photo upload onto a user's wall.
//
// https://vk.com/dev/photos.getWallUploadServer
type PhotosGetWallUploadServer struct {
	GroupID int64 // ID of community to whose wall the photo will be uploaded.
}

func (req PhotosGetWallUploadServer) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// PhotosMakeCover.
//
// Makes a photo into an album cover.
//
// https://vk.com/dev/photos.makeCover
type PhotosMakeCover struct {
	OwnerID int64 // ID of the user or community that owns the photo.
	PhotoID int64 // Photo ID.
	AlbumID int64 // Album ID.
}

func (req PhotosMakeCover) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	return params
}

// PhotosMove.
//
// Moves a photo from one album to another.
//
// https://vk.com/dev/photos.move
type PhotosMove struct {
	OwnerID       int64 // ID of the user or community that owns the photo.
	TargetAlbumID int64 // ID of the album to which the photo will be moved.
	PhotoID       int64 // Photo ID.
}

func (req PhotosMove) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.TargetAlbumID != 0 {
		params["target_album_id"] = req.TargetAlbumID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	return params
}

// PhotosPutTag.
//
// Adds a tag on the photo.
//
// https://vk.com/dev/photos.putTag
type PhotosPutTag struct {
	OwnerID int64   // ID of the user or community that owns the photo.
	PhotoID int64   // Photo ID.
	UserID  int64   // ID of the user to be tagged.
	X       float64 // Upper left-corner coordinate of the tagged area (as a percentage of the photo's width).
	Y       float64 // Upper left-corner coordinate of the tagged area (as a percentage of the photo's height).
	X2      float64 // Lower right-corner coordinate of the tagged area (as a percentage of the photo's width).
	Y2      float64 // Lower right-corner coordinate of the tagged area (as a percentage of the photo's height).
}

func (req PhotosPutTag) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.X != 0 {
		params["x"] = req.X
	}
	if req.Y != 0 {
		params["y"] = req.Y
	}
	if req.X2 != 0 {
		params["x2"] = req.X2
	}
	if req.Y2 != 0 {
		params["y2"] = req.Y2
	}
	return params
}

// PhotosRemoveTag.
//
// Removes a tag from a photo.
//
// https://vk.com/dev/photos.removeTag
type PhotosRemoveTag struct {
	OwnerID int64 // ID of the user or community that owns the photo.
	PhotoID int64 // Photo ID.
	TagID   int64 // Tag ID.
}

func (req PhotosRemoveTag) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.TagID != 0 {
		params["tag_id"] = req.TagID
	}
	return params
}

// PhotosReorderAlbums.
//
// Reorders the album in the list of user albums.
//
// https://vk.com/dev/photos.reorderAlbums
type PhotosReorderAlbums struct {
	OwnerID int64 // ID of the user or community that owns the album.
	AlbumID int64 // Album ID.
	Before  int64 // ID of the album before which the album in question shall be placed.
	After   int64 // ID of the album after which the album in question shall be placed.
}

func (req PhotosReorderAlbums) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Before != 0 {
		params["before"] = req.Before
	}
	if req.After != 0 {
		params["after"] = req.After
	}
	return params
}

// PhotosReorderPhotos.
//
// Reorders the photo in the list of photos of the user album.
//
// https://vk.com/dev/photos.reorderPhotos
type PhotosReorderPhotos struct {
	OwnerID int64 // ID of the user or community that owns the photo.
	PhotoID int64 // Photo ID.
	Before  int64 // ID of the photo before which the photo in question shall be placed.
	After   int64 // ID of the photo after which the photo in question shall be placed.
}

func (req PhotosReorderPhotos) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.Before != 0 {
		params["before"] = req.Before
	}
	if req.After != 0 {
		params["after"] = req.After
	}
	return params
}

// PhotosReport.
//
// Reports (submits a complaint about) a photo.
//
// https://vk.com/dev/photos.report
type PhotosReport struct {
	OwnerID int64 // ID of the user or community that owns the photo.
	PhotoID int64 // Photo ID.
	Reason  int64 // Reason for the complaint: '0' – spam, '1' – child pornography, '2' – extremism, '3' – violence, '4' – drug propaganda, '5' – adult material, '6' – insult, abuse
}

func (req PhotosReport) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// PhotosReportComment.
//
// Reports (submits a complaint about) a comment on a photo.
//
// https://vk.com/dev/photos.reportComment
type PhotosReportComment struct {
	OwnerID   int64 // ID of the user or community that owns the photo.
	CommentID int64 // ID of the comment being reported.
	Reason    int64 // Reason for the complaint: '0' – spam, '1' – child pornography, '2' – extremism, '3' – violence, '4' – drug propaganda, '5' – adult material, '6' – insult, abuse
}

func (req PhotosReportComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// PhotosRestore.
//
// Restores a deleted photo.
//
// https://vk.com/dev/photos.restore
type PhotosRestore struct {
	OwnerID int64 // ID of the user or community that owns the photo.
	PhotoID int64 // Photo ID.
}

func (req PhotosRestore) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	return params
}

// PhotosRestoreComment.
//
// Restores a deleted comment on a photo.
//
// https://vk.com/dev/photos.restoreComment
type PhotosRestoreComment struct {
	OwnerID   int64 // ID of the user or community that owns the photo.
	CommentID int64 // ID of the deleted comment.
}

func (req PhotosRestoreComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// PhotosSave.
//
// Saves photos after successful uploading.
//
// https://vk.com/dev/photos.save
type PhotosSave struct {
	AlbumID    int64   // ID of the album to save photos to.
	GroupID    int64   // ID of the community to save photos to.
	Server     int64   // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	PhotosList string  // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash       string  // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Latitude   float64 // Geographical latitude, in degrees (from '-90' to '90').
	Longitude  float64 // Geographical longitude, in degrees (from '-180' to '180').
	Caption    string  // Text describing the photo. 2048 digits max.
}

func (req PhotosSave) params() Params {
	params := make(Params)
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Server != 0 {
		params["server"] = req.Server
	}
	if req.PhotosList != "" {
		params["photos_list"] = req.PhotosList
	}
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.Caption != "" {
		params["caption"] = req.Caption
	}
	return params
}

// PhotosSaveMarketAlbumPhoto.
//
// Saves market album photos after successful uploading.
//
// https://vk.com/dev/photos.saveMarketAlbumPhoto
type PhotosSaveMarketAlbumPhoto struct {
	GroupID int64  // Community ID.
	Photo   string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Server  int64  // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash    string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
}

func (req PhotosSaveMarketAlbumPhoto) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	if req.Server != 0 {
		params["server"] = req.Server
	}
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	return params
}

// PhotosSaveMarketPhoto.
//
// Saves market photos after successful uploading.
//
// https://vk.com/dev/photos.saveMarketPhoto
type PhotosSaveMarketPhoto struct {
	GroupID  int64  // Community ID.
	Photo    string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Server   int64  // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash     string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	CropData string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	CropHash string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
}

func (req PhotosSaveMarketPhoto) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	if req.Server != 0 {
		params["server"] = req.Server
	}
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	if req.CropData != "" {
		params["crop_data"] = req.CropData
	}
	if req.CropHash != "" {
		params["crop_hash"] = req.CropHash
	}
	return params
}

// PhotosSaveMessagesPhoto.
//
// Saves a photo after being successfully uploaded. URL obtained with [vk.com/dev/photos.getMessagesUploadServer|photos.getMessagesUploadServer] method.
//
// https://vk.com/dev/photos.saveMessagesPhoto
type PhotosSaveMessagesPhoto struct {
	Photo  string // Parameter returned when the photo is [vk.com/dev/upload_files|uploaded to the server].
	Server int64
	Hash   string
}

func (req PhotosSaveMessagesPhoto) params() Params {
	params := make(Params)
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	if req.Server != 0 {
		params["server"] = req.Server
	}
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	return params
}

// PhotosSaveOwnerCoverPhoto.
//
// Saves cover photo after successful uploading.
//
// https://vk.com/dev/photos.saveOwnerCoverPhoto
type PhotosSaveOwnerCoverPhoto struct {
	Hash  string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Photo string // Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
}

func (req PhotosSaveOwnerCoverPhoto) params() Params {
	params := make(Params)
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	return params
}

// PhotosSaveOwnerPhoto.
//
// Saves a profile or community photo. Upload URL can be got with the [vk.com/dev/photos.getOwnerPhotoUploadServer|photos.getOwnerPhotoUploadServer] method.
//
// https://vk.com/dev/photos.saveOwnerPhoto
type PhotosSaveOwnerPhoto struct {
	Server string // parameter returned after [vk.com/dev/upload_files|photo upload].
	Hash   string // parameter returned after [vk.com/dev/upload_files|photo upload].
	Photo  string // parameter returned after [vk.com/dev/upload_files|photo upload].
}

func (req PhotosSaveOwnerPhoto) params() Params {
	params := make(Params)
	if req.Server != "" {
		params["server"] = req.Server
	}
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	return params
}

// PhotosSaveWallPhoto.
//
// Saves a photo to a user's or community's wall after being uploaded.
//
// https://vk.com/dev/photos.saveWallPhoto
type PhotosSaveWallPhoto struct {
	UserID    int64  // ID of the user on whose wall the photo will be saved.
	GroupID   int64  // ID of community on whose wall the photo will be saved.
	Photo     string // Parameter returned when the the photo is [vk.com/dev/upload_files|uploaded to the server].
	Server    int64
	Hash      string
	Latitude  float64 // Geographical latitude, in degrees (from '-90' to '90').
	Longitude float64 // Geographical longitude, in degrees (from '-180' to '180').
	Caption   string  // Text describing the photo. 2048 digits max.
}

func (req PhotosSaveWallPhoto) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	if req.Server != 0 {
		params["server"] = req.Server
	}
	if req.Hash != "" {
		params["hash"] = req.Hash
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.Caption != "" {
		params["caption"] = req.Caption
	}
	return params
}

// PhotosSearch.
//
// Returns a list of photos.
//
// https://vk.com/dev/photos.search
type PhotosSearch struct {
	Q         string  // Search query string.
	Lat       float64 // Geographical latitude, in degrees (from '-90' to '90').
	Long      float64 // Geographical longitude, in degrees (from '-180' to '180').
	StartTime int64
	EndTime   int64
	Sort      int64 // Sort order:
	Offset    int64 // Offset needed to return a specific subset of photos.
	Count     int64 // Number of photos to return.
	Radius    int64 // Radius of search in meters (works very approximately). Available values: '10', '100', '800', '6000', '50000'.
}

func (req PhotosSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.StartTime != 0 {
		params["start_time"] = req.StartTime
	}
	if req.EndTime != 0 {
		params["end_time"] = req.EndTime
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Radius != 0 {
		params["radius"] = req.Radius
	}
	return params
}

// PollsAddVote.
//
// Adds the current user's vote to the selected answer in the poll.
//
// https://vk.com/dev/polls.addVote
type PollsAddVote struct {
	OwnerID   int64 // ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	PollID    int64 // Poll ID.
	AnswerIDs []int64
	IsBoard   bool
}

func (req PollsAddVote) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PollID != 0 {
		params["poll_id"] = req.PollID
	}
	if len(req.AnswerIDs) > 0 {
		params["answer_ids"] = req.AnswerIDs
	}
	if req.IsBoard {
		params["is_board"] = req.IsBoard
	}
	return params
}

// PollsCreate.
//
// Creates polls that can be attached to the users' or communities' posts.
//
// https://vk.com/dev/polls.create
type PollsCreate struct {
	Question      string // question text
	IsAnonymous   bool   // '1' – anonymous poll, participants list is hidden,, '0' – public poll, participants list is available,, Default value is '0'.
	IsMultiple    bool
	EndDate       int64
	OwnerID       int64  // If a poll will be added to a communty it is required to send a negative group identifier. Current user by default.
	AddAnswers    string // available answers list, for example: " ["yes","no","maybe"]", There can be from 1 to 10 answers.
	PhotoID       int64
	BackgroundID  string
	DisableUnvote bool
}

func (req PollsCreate) params() Params {
	params := make(Params)
	if req.Question != "" {
		params["question"] = req.Question
	}
	if req.IsAnonymous {
		params["is_anonymous"] = req.IsAnonymous
	}
	if req.IsMultiple {
		params["is_multiple"] = req.IsMultiple
	}
	if req.EndDate != 0 {
		params["end_date"] = req.EndDate
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AddAnswers != "" {
		params["add_answers"] = req.AddAnswers
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.BackgroundID != "" {
		params["background_id"] = req.BackgroundID
	}
	if req.DisableUnvote {
		params["disable_unvote"] = req.DisableUnvote
	}
	return params
}

// PollsDeleteVote.
//
// Deletes the current user's vote from the selected answer in the poll.
//
// https://vk.com/dev/polls.deleteVote
type PollsDeleteVote struct {
	OwnerID  int64 // ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	PollID   int64 // Poll ID.
	AnswerID int64 // Answer ID.
	IsBoard  bool
}

func (req PollsDeleteVote) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PollID != 0 {
		params["poll_id"] = req.PollID
	}
	if req.AnswerID != 0 {
		params["answer_id"] = req.AnswerID
	}
	if req.IsBoard {
		params["is_board"] = req.IsBoard
	}
	return params
}

// PollsEdit.
//
// Edits created polls
//
// https://vk.com/dev/polls.edit
type PollsEdit struct {
	OwnerID       int64  // poll owner id
	PollID        int64  // edited poll's id
	Question      string // new question text
	AddAnswers    string // answers list, for example: , "["yes","no","maybe"]"
	EditAnswers   string // object containing answers that need to be edited,, key – answer id, value – new answer text. Example: {"382967099":"option1", "382967103":"option2"}"
	DeleteAnswers string // list of answer ids to be deleted. For example: "[382967099, 382967103]"
	EndDate       int64
	PhotoID       int64
	BackgroundID  string
}

func (req PollsEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PollID != 0 {
		params["poll_id"] = req.PollID
	}
	if req.Question != "" {
		params["question"] = req.Question
	}
	if req.AddAnswers != "" {
		params["add_answers"] = req.AddAnswers
	}
	if req.EditAnswers != "" {
		params["edit_answers"] = req.EditAnswers
	}
	if req.DeleteAnswers != "" {
		params["delete_answers"] = req.DeleteAnswers
	}
	if req.EndDate != 0 {
		params["end_date"] = req.EndDate
	}
	if req.PhotoID != 0 {
		params["photo_id"] = req.PhotoID
	}
	if req.BackgroundID != "" {
		params["background_id"] = req.BackgroundID
	}
	return params
}

// PollsGetByID.
//
// Returns detailed information about a poll by its ID.
//
// https://vk.com/dev/polls.getById
type PollsGetByID struct {
	OwnerID      int64 // ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	IsBoard      bool  // '1' – poll is in a board, '0' – poll is on a wall. '0' by default.
	PollID       int64 // Poll ID.
	Extended     bool
	FriendsCount int64
	Fields       []string
	NameCase     string
}

func (req PollsGetByID) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.IsBoard {
		params["is_board"] = req.IsBoard
	}
	if req.PollID != 0 {
		params["poll_id"] = req.PollID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.FriendsCount != 0 {
		params["friends_count"] = req.FriendsCount
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// PollsGetVoters.
//
// Returns a list of IDs of users who selected specific answers in the poll.
//
// https://vk.com/dev/polls.getVoters
type PollsGetVoters struct {
	OwnerID     int64   // ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	PollID      int64   // Poll ID.
	AnswerIDs   []int64 // Answer IDs.
	IsBoard     bool
	FriendsOnly bool          // '1' — to return only current user's friends, '0' — to return all users (default),
	Offset      int64         // Offset needed to return a specific subset of voters. '0' — (default)
	Count       int64         // Number of user IDs to return (if the 'friends_only' parameter is not set, maximum '1000', otherwise '10'). '100' — (default)
	Fields      []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate (birthdate)', 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'rate', 'contacts', 'education', 'online', 'counters'.
	NameCase    string        // Case for declension of user name and surname: , 'nom' — nominative (default) , 'gen' — genitive , 'dat' — dative , 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
}

func (req PollsGetVoters) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PollID != 0 {
		params["poll_id"] = req.PollID
	}
	if len(req.AnswerIDs) > 0 {
		params["answer_ids"] = req.AnswerIDs
	}
	if req.IsBoard {
		params["is_board"] = req.IsBoard
	}
	if req.FriendsOnly {
		params["friends_only"] = req.FriendsOnly
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// PrettyCardsCreate.
//
// https://vk.com/dev/prettyCards.create
type PrettyCardsCreate struct {
	OwnerID  int64
	Photo    string
	Title    string
	Link     string
	Price    string
	PriceOld string
	Button   string
}

func (req PrettyCardsCreate) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Link != "" {
		params["link"] = req.Link
	}
	if req.Price != "" {
		params["price"] = req.Price
	}
	if req.PriceOld != "" {
		params["price_old"] = req.PriceOld
	}
	if req.Button != "" {
		params["button"] = req.Button
	}
	return params
}

// PrettyCardsDelete.
//
// https://vk.com/dev/prettyCards.delete
type PrettyCardsDelete struct {
	OwnerID int64
	CardID  int64
}

func (req PrettyCardsDelete) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CardID != 0 {
		params["card_id"] = req.CardID
	}
	return params
}

// PrettyCardsEdit.
//
// https://vk.com/dev/prettyCards.edit
type PrettyCardsEdit struct {
	OwnerID  int64
	CardID   int64
	Photo    string
	Title    string
	Link     string
	Price    string
	PriceOld string
	Button   string
}

func (req PrettyCardsEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CardID != 0 {
		params["card_id"] = req.CardID
	}
	if req.Photo != "" {
		params["photo"] = req.Photo
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if req.Link != "" {
		params["link"] = req.Link
	}
	if req.Price != "" {
		params["price"] = req.Price
	}
	if req.PriceOld != "" {
		params["price_old"] = req.PriceOld
	}
	if req.Button != "" {
		params["button"] = req.Button
	}
	return params
}

// PrettyCardsGet.
//
// https://vk.com/dev/prettyCards.get
type PrettyCardsGet struct {
	OwnerID int64
	Offset  int64
	Count   int64
}

func (req PrettyCardsGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// PrettyCardsGetByID.
//
// https://vk.com/dev/prettyCards.getById
type PrettyCardsGetByID struct {
	OwnerID int64
	CardIDs []int64
}

func (req PrettyCardsGetByID) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if len(req.CardIDs) > 0 {
		params["card_ids"] = req.CardIDs
	}
	return params
}

// PrettyCardsGetUploadURL.
//
// https://vk.com/dev/prettyCards.getUploadURL
type PrettyCardsGetUploadURL struct {
}

func (req PrettyCardsGetUploadURL) params() Params {
	params := make(Params)
	return params
}

// SearchGetHints.
//
// Allows the programmer to do a quick search for any substring.
//
// https://vk.com/dev/search.getHints
type SearchGetHints struct {
	Q            string // Search query string.
	Offset       int64  // Offset for querying specific result subset
	Limit        int64  // Maximum number of results to return.
	Filters      []string
	Fields       []string
	SearchGlobal bool
}

func (req SearchGetHints) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	if len(req.Filters) > 0 {
		params["filters"] = req.Filters
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.SearchGlobal {
		params["search_global"] = req.SearchGlobal
	}
	return params
}

// SecureAddAppEvent.
//
// Adds user activity information to an application
//
// https://vk.com/dev/secure.addAppEvent
type SecureAddAppEvent struct {
	UserID     int64 // ID of a user to save the data
	ActivityID int64 // there are 2 default activities: , * 1 – level. Works similar to ,, * 2 – points, saves points amount, Any other value is for saving completed missions
	Value      int64 // depends on activity_id: * 1 – number, current level number,, * 2 – number, current user's points amount, , Any other value is ignored
}

func (req SecureAddAppEvent) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.ActivityID != 0 {
		params["activity_id"] = req.ActivityID
	}
	if req.Value != 0 {
		params["value"] = req.Value
	}
	return params
}

// SecureCheckToken.
//
// Checks the user authentication in 'IFrame' and 'Flash' apps using the 'access_token' parameter.
//
// https://vk.com/dev/secure.checkToken
type SecureCheckToken struct {
	Token string // client 'access_token'
	Ip    string // user 'ip address'. Note that user may access using the 'ipv6' address, in this case it is required to transmit the 'ipv6' address. If not transmitted, the address will not be checked.
}

func (req SecureCheckToken) params() Params {
	params := make(Params)
	if req.Token != "" {
		params["token"] = req.Token
	}
	if req.Ip != "" {
		params["ip"] = req.Ip
	}
	return params
}

// SecureGetAppBalance.
//
// Returns payment balance of the application in hundredth of a vote.
//
// https://vk.com/dev/secure.getAppBalance
type SecureGetAppBalance struct {
}

func (req SecureGetAppBalance) params() Params {
	params := make(Params)
	return params
}

// SecureGetSMSHistory.
//
// Shows a list of SMS notifications sent by the application using [vk.com/dev/secure.sendSMSNotification|secure.sendSMSNotification] method.
//
// https://vk.com/dev/secure.getSMSHistory
type SecureGetSMSHistory struct {
	UserID   int64
	DateFrom int64 // filter by start date. It is set as UNIX-time.
	DateTo   int64 // filter by end date. It is set as UNIX-time.
	Limit    int64 // number of returned posts. By default — 1000.
}

func (req SecureGetSMSHistory) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.DateFrom != 0 {
		params["date_from"] = req.DateFrom
	}
	if req.DateTo != 0 {
		params["date_to"] = req.DateTo
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	return params
}

// SecureGetTransactionsHistory.
//
// Shows history of votes transaction between users and the application.
//
// https://vk.com/dev/secure.getTransactionsHistory
type SecureGetTransactionsHistory struct {
	Type     int64
	UidFrom  int64
	UidTo    int64
	DateFrom int64
	DateTo   int64
	Limit    int64
}

func (req SecureGetTransactionsHistory) params() Params {
	params := make(Params)
	if req.Type != 0 {
		params["type"] = req.Type
	}
	if req.UidFrom != 0 {
		params["uid_from"] = req.UidFrom
	}
	if req.UidTo != 0 {
		params["uid_to"] = req.UidTo
	}
	if req.DateFrom != 0 {
		params["date_from"] = req.DateFrom
	}
	if req.DateTo != 0 {
		params["date_to"] = req.DateTo
	}
	if req.Limit != 0 {
		params["limit"] = req.Limit
	}
	return params
}

// SecureGetUserLevel.
//
// Returns one of the previously set game levels of one or more users in the application.
//
// https://vk.com/dev/secure.getUserLevel
type SecureGetUserLevel struct {
	UserIDs []int64
}

func (req SecureGetUserLevel) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	return params
}

// SecureGiveEventSticker.
//
// Opens the game achievement and gives the user a sticker
//
// https://vk.com/dev/secure.giveEventSticker
type SecureGiveEventSticker struct {
	UserIDs       []int64
	AchievementID int64
}

func (req SecureGiveEventSticker) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.AchievementID != 0 {
		params["achievement_id"] = req.AchievementID
	}
	return params
}

// SecureSendNotification.
//
// Sends notification to the user.
//
// https://vk.com/dev/secure.sendNotification
type SecureSendNotification struct {
	UserIDs []int64
	UserID  int64
	Message string // notification text which should be sent in 'UTF-8' encoding ('254' characters maximum).
}

func (req SecureSendNotification) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	return params
}

// SecureSendSMSNotification.
//
// Sends 'SMS' notification to a user's mobile device.
//
// https://vk.com/dev/secure.sendSMSNotification
type SecureSendSMSNotification struct {
	UserID  int64  // ID of the user to whom SMS notification is sent. The user shall allow the application to send him/her notifications (, +1).
	Message string // 'SMS' text to be sent in 'UTF-8' encoding. Only Latin letters and numbers are allowed. Maximum size is '160' characters.
}

func (req SecureSendSMSNotification) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	return params
}

// SecureSetCounter.
//
// Sets a counter which is shown to the user in bold in the left menu.
//
// https://vk.com/dev/secure.setCounter
type SecureSetCounter struct {
	Counters  []string
	UserID    int64
	Counter   int64 // counter value.
	Increment bool
}

func (req SecureSetCounter) params() Params {
	params := make(Params)
	if len(req.Counters) > 0 {
		params["counters"] = req.Counters
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Counter != 0 {
		params["counter"] = req.Counter
	}
	if req.Increment {
		params["increment"] = req.Increment
	}
	return params
}

// StatsGet.
//
// Returns statistics of a community or an application.
//
// https://vk.com/dev/stats.get
type StatsGet struct {
	GroupID        int64 // Community ID.
	AppID          int64 // Application ID.
	TimestampFrom  int64
	TimestampTo    int64
	Interval       string
	IntervalsCount int64
	Filters        []string
	StatsGroups    []string
	Extended       bool
}

func (req StatsGet) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.AppID != 0 {
		params["app_id"] = req.AppID
	}
	if req.TimestampFrom != 0 {
		params["timestamp_from"] = req.TimestampFrom
	}
	if req.TimestampTo != 0 {
		params["timestamp_to"] = req.TimestampTo
	}
	if req.Interval != "" {
		params["interval"] = req.Interval
	}
	if req.IntervalsCount != 0 {
		params["intervals_count"] = req.IntervalsCount
	}
	if len(req.Filters) > 0 {
		params["filters"] = req.Filters
	}
	if len(req.StatsGroups) > 0 {
		params["stats_groups"] = req.StatsGroups
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// StatsGetPostReach.
//
// Returns stats for a wall post.
//
// https://vk.com/dev/stats.getPostReach
type StatsGetPostReach struct {
	OwnerID string  // post owner community id. Specify with "-" sign.
	PostIDs []int64 // wall posts id
}

func (req StatsGetPostReach) params() Params {
	params := make(Params)
	if req.OwnerID != "" {
		params["owner_id"] = req.OwnerID
	}
	if len(req.PostIDs) > 0 {
		params["post_ids"] = req.PostIDs
	}
	return params
}

// StatsTrackVisitor.
//
// https://vk.com/dev/stats.trackVisitor
type StatsTrackVisitor struct {
	ID string
}

func (req StatsTrackVisitor) params() Params {
	params := make(Params)
	if req.ID != "" {
		params["id"] = req.ID
	}
	return params
}

// StatusGet.
//
// Returns data required to show the status of a user or community.
//
// https://vk.com/dev/status.get
type StatusGet struct {
	UserID  int64 // User ID or community ID. Use a negative value to designate a community ID.
	GroupID int64
}

func (req StatusGet) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// StatusSet.
//
// Sets a new status for the current user.
//
// https://vk.com/dev/status.set
type StatusSet struct {
	Text    string // Text of the new status.
	GroupID int64  // Identifier of a community to set a status in. If left blank the status is set to current user.
}

func (req StatusSet) params() Params {
	params := make(Params)
	if req.Text != "" {
		params["text"] = req.Text
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// StorageGet.
//
// Returns a value of variable with the name set by key parameter.
//
// https://vk.com/dev/storage.get
type StorageGet struct {
	Key    string
	Keys   []string
	UserID int64
}

func (req StorageGet) params() Params {
	params := make(Params)
	if req.Key != "" {
		params["key"] = req.Key
	}
	if len(req.Keys) > 0 {
		params["keys"] = req.Keys
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// StorageGetKeys.
//
// Returns the names of all variables.
//
// https://vk.com/dev/storage.getKeys
type StorageGetKeys struct {
	UserID int64 // user id, whose variables names are returned if they were requested with a server method.
	Offset int64
	Count  int64 // amount of variable names the info needs to be collected from.
}

func (req StorageGetKeys) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// StorageSet.
//
// Saves a value of variable with the name set by 'key' parameter.
//
// https://vk.com/dev/storage.set
type StorageSet struct {
	Key    string
	Value  string
	UserID int64
}

func (req StorageSet) params() Params {
	params := make(Params)
	if req.Key != "" {
		params["key"] = req.Key
	}
	if req.Value != "" {
		params["value"] = req.Value
	}
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	return params
}

// StoriesBanOwner.
//
// Allows to hide stories from chosen sources from current user's feed.
//
// https://vk.com/dev/stories.banOwner
type StoriesBanOwner struct {
	OwnersIDs []int64 // List of sources IDs
}

func (req StoriesBanOwner) params() Params {
	params := make(Params)
	if len(req.OwnersIDs) > 0 {
		params["owners_ids"] = req.OwnersIDs
	}
	return params
}

// StoriesDelete.
//
// Allows to delete story.
//
// https://vk.com/dev/stories.delete
type StoriesDelete struct {
	OwnerID int64 // Story owner's ID. Current user id is used by default.
	StoryID int64 // Story ID.
}

func (req StoriesDelete) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.StoryID != 0 {
		params["story_id"] = req.StoryID
	}
	return params
}

// StoriesGet.
//
// Returns stories available for current user.
//
// https://vk.com/dev/stories.get
type StoriesGet struct {
	OwnerID  int64 // Owner ID.
	Extended bool  // '1' — to return additional fields for users and communities. Default value is 0.
	Fields   []BaseUserGroupFields
}

func (req StoriesGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// StoriesGetBanned.
//
// Returns list of sources hidden from current user's feed.
//
// https://vk.com/dev/stories.getBanned
type StoriesGetBanned struct {
	Extended bool                  // '1' — to return additional fields for users and communities. Default value is 0.
	Fields   []BaseUserGroupFields // Additional fields to return
}

func (req StoriesGetBanned) params() Params {
	params := make(Params)
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// StoriesGetByID.
//
// Returns story by its ID.
//
// https://vk.com/dev/stories.getById
type StoriesGetByID struct {
	Stories  []string              // Stories IDs separated by commas. Use format {owner_id}+'_'+{story_id}, for example, 12345_54331.
	Extended bool                  // '1' — to return additional fields for users and communities. Default value is 0.
	Fields   []BaseUserGroupFields // Additional fields to return
}

func (req StoriesGetByID) params() Params {
	params := make(Params)
	if len(req.Stories) > 0 {
		params["stories"] = req.Stories
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// StoriesGetPhotoUploadServer.
//
// Returns URL for uploading a story with photo.
//
// https://vk.com/dev/stories.getPhotoUploadServer
type StoriesGetPhotoUploadServer struct {
	AddToNews         bool                   // 1 — to add the story to friend's feed.
	UserIDs           []int64                // List of users IDs who can see the story.
	ReplyToStory      string                 // ID of the story to reply with the current.
	LinkText          *StoriesUploadLinkText // Link text (for community's stories only).
	LinkURL           string                 // Link URL. Internal links on https://vk.com only.
	GroupID           int64                  // ID of the community to upload the story (should be verified or with the "fire" icon).
	ClickableStickers string
}

func (req StoriesGetPhotoUploadServer) params() Params {
	params := make(Params)
	if req.AddToNews {
		params["add_to_news"] = req.AddToNews
	}
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.ReplyToStory != "" {
		params["reply_to_story"] = req.ReplyToStory
	}
	if req.LinkText != nil {
		params["link_text"] = req.LinkText
	}
	if req.LinkURL != "" {
		params["link_url"] = req.LinkURL
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.ClickableStickers != "" {
		params["clickable_stickers"] = req.ClickableStickers
	}
	return params
}

// StoriesGetReplies.
//
// Returns replies to the story.
//
// https://vk.com/dev/stories.getReplies
type StoriesGetReplies struct {
	OwnerID   int64                 // Story owner ID.
	StoryID   int64                 // Story ID.
	AccessKey string                // Access key for the private object.
	Extended  bool                  // '1' — to return additional fields for users and communities. Default value is 0.
	Fields    []BaseUserGroupFields // Additional fields to return
}

func (req StoriesGetReplies) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.StoryID != 0 {
		params["story_id"] = req.StoryID
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// StoriesGetStats.
//
// Returns stories available for current user.
//
// https://vk.com/dev/stories.getStats
type StoriesGetStats struct {
	OwnerID int64 // Story owner ID.
	StoryID int64 // Story ID.
}

func (req StoriesGetStats) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.StoryID != 0 {
		params["story_id"] = req.StoryID
	}
	return params
}

// StoriesGetVideoUploadServer.
//
// Allows to receive URL for uploading story with video.
//
// https://vk.com/dev/stories.getVideoUploadServer
type StoriesGetVideoUploadServer struct {
	AddToNews         bool                   // 1 — to add the story to friend's feed.
	UserIDs           []int64                // List of users IDs who can see the story.
	ReplyToStory      string                 // ID of the story to reply with the current.
	LinkText          *StoriesUploadLinkText // Link text (for community's stories only).
	LinkURL           string                 // Link URL. Internal links on https://vk.com only.
	GroupID           int64                  // ID of the community to upload the story (should be verified or with the "fire" icon).
	ClickableStickers string
}

func (req StoriesGetVideoUploadServer) params() Params {
	params := make(Params)
	if req.AddToNews {
		params["add_to_news"] = req.AddToNews
	}
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if req.ReplyToStory != "" {
		params["reply_to_story"] = req.ReplyToStory
	}
	if req.LinkText != nil {
		params["link_text"] = req.LinkText
	}
	if req.LinkURL != "" {
		params["link_url"] = req.LinkURL
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.ClickableStickers != "" {
		params["clickable_stickers"] = req.ClickableStickers
	}
	return params
}

// StoriesGetViewers.
//
// Returns a list of story viewers.
//
// https://vk.com/dev/stories.getViewers
type StoriesGetViewers struct {
	OwnerID  int64 // Story owner ID.
	StoryID  int64 // Story ID.
	Count    int64 // Maximum number of results.
	Offset   int64 // Offset needed to return a specific subset of results.
	Extended bool  // '1' — to return detailed information about photos
}

func (req StoriesGetViewers) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.StoryID != 0 {
		params["story_id"] = req.StoryID
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// StoriesHideAllReplies.
//
// Hides all replies in the last 24 hours from the user to current user's stories.
//
// https://vk.com/dev/stories.hideAllReplies
type StoriesHideAllReplies struct {
	OwnerID int64 // ID of the user whose replies should be hidden.
	GroupID int64
}

func (req StoriesHideAllReplies) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	return params
}

// StoriesHideReply.
//
// Hides the reply to the current user's story.
//
// https://vk.com/dev/stories.hideReply
type StoriesHideReply struct {
	OwnerID int64 // ID of the user whose replies should be hidden.
	StoryID int64 // Story ID.
}

func (req StoriesHideReply) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.StoryID != 0 {
		params["story_id"] = req.StoryID
	}
	return params
}

// StoriesSearch.
//
// https://vk.com/dev/stories.search
type StoriesSearch struct {
	Q           string
	PlaceID     int64
	Latitude    float64
	Longitude   float64
	Radius      int64
	MentionedID int64
	Count       int64
	Extended    bool
	Fields      []string
}

func (req StoriesSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.PlaceID != 0 {
		params["place_id"] = req.PlaceID
	}
	if req.Latitude != 0 {
		params["latitude"] = req.Latitude
	}
	if req.Longitude != 0 {
		params["longitude"] = req.Longitude
	}
	if req.Radius != 0 {
		params["radius"] = req.Radius
	}
	if req.MentionedID != 0 {
		params["mentioned_id"] = req.MentionedID
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// StoriesUnbanOwner.
//
// Allows to show stories from hidden sources in current user's feed.
//
// https://vk.com/dev/stories.unbanOwner
type StoriesUnbanOwner struct {
	OwnersIDs []int64 // List of hidden sources to show stories from.
}

func (req StoriesUnbanOwner) params() Params {
	params := make(Params)
	if len(req.OwnersIDs) > 0 {
		params["owners_ids"] = req.OwnersIDs
	}
	return params
}

// StreamingGetServerURL.
//
// Allows to receive data for the connection to Streaming API.
//
// https://vk.com/dev/streaming.getServerUrl
type StreamingGetServerURL struct {
}

func (req StreamingGetServerURL) params() Params {
	params := make(Params)
	return params
}

// StreamingSetSettings.
//
// https://vk.com/dev/streaming.setSettings
type StreamingSetSettings struct {
	MonthlyTier string
}

func (req StreamingSetSettings) params() Params {
	params := make(Params)
	if req.MonthlyTier != "" {
		params["monthly_tier"] = req.MonthlyTier
	}
	return params
}

// UsersGet.
//
// Returns detailed information on users.
//
// https://vk.com/dev/users.get
type UsersGet struct {
	UserIDs  []string      // User IDs or screen names ('screen_name'). By default, current user ID.
	Fields   []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'contacts', 'education', 'online', 'counters', 'relation', 'last_seen', 'activity', 'can_write_private_message', 'can_see_all_posts', 'can_post', 'universities', 'can_invite_to_chats'
	NameCase string        // Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
}

func (req UsersGet) params() Params {
	params := make(Params)
	if len(req.UserIDs) > 0 {
		params["user_ids"] = req.UserIDs
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// UsersGetFollowers.
//
// Returns a list of IDs of followers of the user in question, sorted by date added, most recent first.
//
// https://vk.com/dev/users.getFollowers
type UsersGetFollowers struct {
	UserID   int64         // User ID.
	Offset   int64         // Offset needed to return a specific subset of followers.
	Count    int64         // Number of followers to return.
	Fields   []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'rate', 'contacts', 'education', 'online'.
	NameCase string        // Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
}

func (req UsersGetFollowers) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.NameCase != "" {
		params["name_case"] = req.NameCase
	}
	return params
}

// UsersGetSubscriptions.
//
// Returns a list of IDs of users and communities followed by the user.
//
// https://vk.com/dev/users.getSubscriptions
type UsersGetSubscriptions struct {
	UserID   int64 // User ID.
	Extended bool  // '1' — to return a combined list of users and communities, '0' — to return separate lists of users and communities (default)
	Offset   int64 // Offset needed to return a specific subset of subscriptions.
	Count    int64 // Number of users and communities to return.
	Fields   []UsersFields
}

func (req UsersGetSubscriptions) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// UsersReport.
//
// Reports (submits a complain about) a user.
//
// https://vk.com/dev/users.report
type UsersReport struct {
	UserID  int64  // ID of the user about whom a complaint is being made.
	Type    string // Type of complaint: 'porn' – pornography, 'spam' – spamming, 'insult' – abusive behavior, 'advertisement' – disruptive advertisements
	Comment string // Comment describing the complaint.
}

func (req UsersReport) params() Params {
	params := make(Params)
	if req.UserID != 0 {
		params["user_id"] = req.UserID
	}
	if req.Type != "" {
		params["type"] = req.Type
	}
	if req.Comment != "" {
		params["comment"] = req.Comment
	}
	return params
}

// UsersSearch.
//
// Returns a list of users matching the search criteria.
//
// https://vk.com/dev/users.search
type UsersSearch struct {
	Q                 string        // Search query string (e.g., 'Vasya Babich').
	Sort              int64         // Sort order: '1' — by date registered, '0' — by rating
	Offset            int64         // Offset needed to return a specific subset of users.
	Count             int64         // Number of users to return.
	Fields            []UsersFields // Profile fields to return. Sample values: 'nickname', 'screen_name', 'sex', 'bdate' (birthdate), 'city', 'country', 'timezone', 'photo', 'photo_medium', 'photo_big', 'has_mobile', 'rate', 'contacts', 'education', 'online',
	City              int64         // City ID.
	Country           int64         // Country ID.
	Hometown          string        // City name in a string.
	UniversityCountry int64         // ID of the country where the user graduated.
	University        int64         // ID of the institution of higher education.
	UniversityYear    int64         // Year of graduation from an institution of higher education.
	UniversityFaculty int64         // Faculty ID.
	UniversityChair   int64         // Chair ID.
	Sex               int64         // '1' — female, '2' — male, '0' — any (default)
	Status            int64         // Relationship status: '1' — Not married, '2' — In a relationship, '3' — Engaged, '4' — Married, '5' — It's complicated, '6' — Actively searching, '7' — In love
	AgeFrom           int64         // Minimum age.
	AgeTo             int64         // Maximum age.
	BirthDay          int64         // Day of birth.
	BirthMonth        int64         // Month of birth.
	BirthYear         int64         // Year of birth.
	Online            bool          // '1' — online only, '0' — all users
	HasPhoto          bool          // '1' — with photo only, '0' — all users
	SchoolCountry     int64         // ID of the country where users finished school.
	SchoolCity        int64         // ID of the city where users finished school.
	SchoolClass       int64
	School            int64  // ID of the school.
	SchoolYear        int64  // School graduation year.
	Religion          string // Users' religious affiliation.
	Company           string // Name of the company where users work.
	Position          string // Job position.
	GroupID           int64  // ID of a community to search in communities.
	FromList          []string
}

func (req UsersSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.City != 0 {
		params["city"] = req.City
	}
	if req.Country != 0 {
		params["country"] = req.Country
	}
	if req.Hometown != "" {
		params["hometown"] = req.Hometown
	}
	if req.UniversityCountry != 0 {
		params["university_country"] = req.UniversityCountry
	}
	if req.University != 0 {
		params["university"] = req.University
	}
	if req.UniversityYear != 0 {
		params["university_year"] = req.UniversityYear
	}
	if req.UniversityFaculty != 0 {
		params["university_faculty"] = req.UniversityFaculty
	}
	if req.UniversityChair != 0 {
		params["university_chair"] = req.UniversityChair
	}
	if req.Sex != 0 {
		params["sex"] = req.Sex
	}
	if req.Status != 0 {
		params["status"] = req.Status
	}
	if req.AgeFrom != 0 {
		params["age_from"] = req.AgeFrom
	}
	if req.AgeTo != 0 {
		params["age_to"] = req.AgeTo
	}
	if req.BirthDay != 0 {
		params["birth_day"] = req.BirthDay
	}
	if req.BirthMonth != 0 {
		params["birth_month"] = req.BirthMonth
	}
	if req.BirthYear != 0 {
		params["birth_year"] = req.BirthYear
	}
	if req.Online {
		params["online"] = req.Online
	}
	if req.HasPhoto {
		params["has_photo"] = req.HasPhoto
	}
	if req.SchoolCountry != 0 {
		params["school_country"] = req.SchoolCountry
	}
	if req.SchoolCity != 0 {
		params["school_city"] = req.SchoolCity
	}
	if req.SchoolClass != 0 {
		params["school_class"] = req.SchoolClass
	}
	if req.School != 0 {
		params["school"] = req.School
	}
	if req.SchoolYear != 0 {
		params["school_year"] = req.SchoolYear
	}
	if req.Religion != "" {
		params["religion"] = req.Religion
	}
	if req.Company != "" {
		params["company"] = req.Company
	}
	if req.Position != "" {
		params["position"] = req.Position
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if len(req.FromList) > 0 {
		params["from_list"] = req.FromList
	}
	return params
}

// UtilsCheckLink.
//
// Checks whether a link is blocked in VK.
//
// https://vk.com/dev/utils.checkLink
type UtilsCheckLink struct {
	URL string // Link to check (e.g., 'http://google.com').
}

func (req UtilsCheckLink) params() Params {
	params := make(Params)
	if req.URL != "" {
		params["url"] = req.URL
	}
	return params
}

// UtilsDeleteFromLastShortened.
//
// Deletes shortened link from user's list.
//
// https://vk.com/dev/utils.deleteFromLastShortened
type UtilsDeleteFromLastShortened struct {
	Key string // Link key (characters after vk.cc/).
}

func (req UtilsDeleteFromLastShortened) params() Params {
	params := make(Params)
	if req.Key != "" {
		params["key"] = req.Key
	}
	return params
}

// UtilsGetLastShortenedLinks.
//
// Returns a list of user's shortened links.
//
// https://vk.com/dev/utils.getLastShortenedLinks
type UtilsGetLastShortenedLinks struct {
	Count  int64 // Number of links to return.
	Offset int64 // Offset needed to return a specific subset of links.
}

func (req UtilsGetLastShortenedLinks) params() Params {
	params := make(Params)
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	return params
}

// UtilsGetLinkStats.
//
// Returns stats data for shortened link.
//
// https://vk.com/dev/utils.getLinkStats
type UtilsGetLinkStats struct {
	Key            string // Link key (characters after vk.cc/).
	Source         string // Source of scope
	AccessKey      string // Access key for private link stats.
	Interval       string // Interval.
	IntervalsCount int64  // Number of intervals to return.
	Extended       bool   // 1 — to return extended stats data (sex, age, geo). 0 — to return views number only.
}

func (req UtilsGetLinkStats) params() Params {
	params := make(Params)
	if req.Key != "" {
		params["key"] = req.Key
	}
	if req.Source != "" {
		params["source"] = req.Source
	}
	if req.AccessKey != "" {
		params["access_key"] = req.AccessKey
	}
	if req.Interval != "" {
		params["interval"] = req.Interval
	}
	if req.IntervalsCount != 0 {
		params["intervals_count"] = req.IntervalsCount
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// UtilsGetServerTime.
//
// Returns the current time of the VK server.
//
// https://vk.com/dev/utils.getServerTime
type UtilsGetServerTime struct {
}

func (req UtilsGetServerTime) params() Params {
	params := make(Params)
	return params
}

// UtilsGetShortLink.
//
// Allows to receive a link shortened via vk.cc.
//
// https://vk.com/dev/utils.getShortLink
type UtilsGetShortLink struct {
	URL     string // URL to be shortened.
	Private bool   // 1 — private stats, 0 — public stats.
}

func (req UtilsGetShortLink) params() Params {
	params := make(Params)
	if req.URL != "" {
		params["url"] = req.URL
	}
	if req.Private {
		params["private"] = req.Private
	}
	return params
}

// UtilsResolveScreenName.
//
// Detects a type of object (e.g., user, community, application) and its ID by screen name.
//
// https://vk.com/dev/utils.resolveScreenName
type UtilsResolveScreenName struct {
	ScreenName string // Screen name of the user, community (e.g., 'apiclub,' 'andrew', or 'rules_of_war'), or application.
}

func (req UtilsResolveScreenName) params() Params {
	params := make(Params)
	if req.ScreenName != "" {
		params["screen_name"] = req.ScreenName
	}
	return params
}

// VideoAdd.
//
// Adds a video to a user or community page.
//
// https://vk.com/dev/video.add
type VideoAdd struct {
	TargetID int64 // identifier of a user or community to add a video to. Use a negative value to designate a community ID.
	VideoID  int64 // Video ID.
	OwnerID  int64 // ID of the user or community that owns the video. Use a negative value to designate a community ID.
}

func (req VideoAdd) params() Params {
	params := make(Params)
	if req.TargetID != 0 {
		params["target_id"] = req.TargetID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// VideoAddAlbum.
//
// Creates an empty album for videos.
//
// https://vk.com/dev/video.addAlbum
type VideoAddAlbum struct {
	GroupID int64    // Community ID (if the album will be created in a community).
	Title   string   // Album title.
	Privacy []string // new access permissions for the album. Possible values: , *'0' – all users,, *'1' – friends only,, *'2' – friends and friends of friends,, *'3' – "only me".
}

func (req VideoAddAlbum) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if len(req.Privacy) > 0 {
		params["privacy"] = req.Privacy
	}
	return params
}

// VideoAddToAlbum.
//
// https://vk.com/dev/video.addToAlbum
type VideoAddToAlbum struct {
	TargetID int64
	AlbumID  int64
	AlbumIDs []int64
	OwnerID  int64
	VideoID  int64
}

func (req VideoAddToAlbum) params() Params {
	params := make(Params)
	if req.TargetID != 0 {
		params["target_id"] = req.TargetID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if len(req.AlbumIDs) > 0 {
		params["album_ids"] = req.AlbumIDs
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	return params
}

// VideoCreateComment.
//
// Adds a new comment on a video.
//
// https://vk.com/dev/video.createComment
type VideoCreateComment struct {
	OwnerID        int64    // ID of the user or community that owns the video.
	VideoID        int64    // Video ID.
	Message        string   // New comment text.
	Attachments    []string // List of objects attached to the comment, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media attachment owner. '<media_id>' — Media attachment ID. Example: "photo100172_166443618,photo66748_265827614"
	FromGroup      bool     // '1' — to post the comment from a community name (only if 'owner_id'<0)
	ReplyToComment int64
	StickerID      int64
	Guid           string
}

func (req VideoCreateComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.FromGroup {
		params["from_group"] = req.FromGroup
	}
	if req.ReplyToComment != 0 {
		params["reply_to_comment"] = req.ReplyToComment
	}
	if req.StickerID != 0 {
		params["sticker_id"] = req.StickerID
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	return params
}

// VideoDelete.
//
// Deletes a video from a user or community page.
//
// https://vk.com/dev/video.delete
type VideoDelete struct {
	VideoID  int64 // Video ID.
	OwnerID  int64 // ID of the user or community that owns the video.
	TargetID int64
}

func (req VideoDelete) params() Params {
	params := make(Params)
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.TargetID != 0 {
		params["target_id"] = req.TargetID
	}
	return params
}

// VideoDeleteAlbum.
//
// Deletes a video album.
//
// https://vk.com/dev/video.deleteAlbum
type VideoDeleteAlbum struct {
	GroupID int64 // Community ID (if the album is owned by a community).
	AlbumID int64 // Album ID.
}

func (req VideoDeleteAlbum) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	return params
}

// VideoDeleteComment.
//
// Deletes a comment on a video.
//
// https://vk.com/dev/video.deleteComment
type VideoDeleteComment struct {
	OwnerID   int64 // ID of the user or community that owns the video.
	CommentID int64 // ID of the comment to be deleted.
}

func (req VideoDeleteComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// VideoEdit.
//
// Edits information about a video on a user or community page.
//
// https://vk.com/dev/video.edit
type VideoEdit struct {
	OwnerID        int64    // ID of the user or community that owns the video.
	VideoID        int64    // Video ID.
	Name           string   // New video title.
	Desc           string   // New video description.
	PrivacyView    []string // Privacy settings in a [vk.com/dev/privacy_setting|special format]. Privacy setting is available for videos uploaded to own profile by user.
	PrivacyComment []string // Privacy settings for comments in a [vk.com/dev/privacy_setting|special format].
	NoComments     bool     // Disable comments for the group video.
	Repeat         bool     // '1' — to repeat the playback of the video, '0' — to play the video once,
}

func (req VideoEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Desc != "" {
		params["desc"] = req.Desc
	}
	if len(req.PrivacyView) > 0 {
		params["privacy_view"] = req.PrivacyView
	}
	if len(req.PrivacyComment) > 0 {
		params["privacy_comment"] = req.PrivacyComment
	}
	if req.NoComments {
		params["no_comments"] = req.NoComments
	}
	if req.Repeat {
		params["repeat"] = req.Repeat
	}
	return params
}

// VideoEditAlbum.
//
// Edits the title of a video album.
//
// https://vk.com/dev/video.editAlbum
type VideoEditAlbum struct {
	GroupID int64    // Community ID (if the album edited is owned by a community).
	AlbumID int64    // Album ID.
	Title   string   // New album title.
	Privacy []string // new access permissions for the album. Possible values: , *'0' – all users,, *'1' – friends only,, *'2' – friends and friends of friends,, *'3' – "only me".
}

func (req VideoEditAlbum) params() Params {
	params := make(Params)
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Title != "" {
		params["title"] = req.Title
	}
	if len(req.Privacy) > 0 {
		params["privacy"] = req.Privacy
	}
	return params
}

// VideoEditComment.
//
// Edits the text of a comment on a video.
//
// https://vk.com/dev/video.editComment
type VideoEditComment struct {
	OwnerID     int64    // ID of the user or community that owns the video.
	CommentID   int64    // Comment ID.
	Message     string   // New comment text.
	Attachments []string // List of objects attached to the comment, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media attachment owner. '<media_id>' — Media attachment ID. Example: "photo100172_166443618,photo66748_265827614"
}

func (req VideoEditComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	return params
}

// VideoGet.
//
// Returns detailed information about videos.
//
// https://vk.com/dev/video.get
type VideoGet struct {
	OwnerID  int64    // ID of the user or community that owns the video(s).
	Videos   []string // Video IDs, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", Use a negative value to designate a community ID. Example: "-4363_136089719,13245770_137352259"
	AlbumID  int64    // ID of the album containing the video(s).
	Count    int64    // Number of videos to return.
	Offset   int64    // Offset needed to return a specific subset of videos.
	Extended bool     // '1' — to return an extended response with additional fields
}

func (req VideoGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if len(req.Videos) > 0 {
		params["videos"] = req.Videos
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// VideoGetAlbumByID.
//
// Returns video album info
//
// https://vk.com/dev/video.getAlbumById
type VideoGetAlbumByID struct {
	OwnerID int64 // identifier of a user or community to add a video to. Use a negative value to designate a community ID.
	AlbumID int64 // Album ID.
}

func (req VideoGetAlbumByID) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	return params
}

// VideoGetAlbums.
//
// Returns a list of video albums owned by a user or community.
//
// https://vk.com/dev/video.getAlbums
type VideoGetAlbums struct {
	OwnerID    int64 // ID of the user or community that owns the video album(s).
	Offset     int64 // Offset needed to return a specific subset of video albums.
	Count      int64 // Number of video albums to return.
	Extended   bool  // '1' — to return additional information about album privacy settings for the current user
	NeedSystem bool
}

func (req VideoGetAlbums) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.NeedSystem {
		params["need_system"] = req.NeedSystem
	}
	return params
}

// VideoGetAlbumsByVideo.
//
// https://vk.com/dev/video.getAlbumsByVideo
type VideoGetAlbumsByVideo struct {
	TargetID int64
	OwnerID  int64
	VideoID  int64
	Extended bool
}

func (req VideoGetAlbumsByVideo) params() Params {
	params := make(Params)
	if req.TargetID != 0 {
		params["target_id"] = req.TargetID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// VideoGetComments.
//
// Returns a list of comments on a video.
//
// https://vk.com/dev/video.getComments
type VideoGetComments struct {
	OwnerID        int64 // ID of the user or community that owns the video.
	VideoID        int64 // Video ID.
	NeedLikes      bool  // '1' — to return an additional 'likes' field
	StartCommentID int64
	Offset         int64  // Offset needed to return a specific subset of comments.
	Count          int64  // Number of comments to return.
	Sort           string // Sort order: 'asc' — oldest comment first, 'desc' — newest comment first
	Extended       bool
	Fields         []string
}

func (req VideoGetComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.NeedLikes {
		params["need_likes"] = req.NeedLikes
	}
	if req.StartCommentID != 0 {
		params["start_comment_id"] = req.StartCommentID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// VideoRemoveFromAlbum.
//
// https://vk.com/dev/video.removeFromAlbum
type VideoRemoveFromAlbum struct {
	TargetID int64
	AlbumID  int64
	AlbumIDs []int64
	OwnerID  int64
	VideoID  int64
}

func (req VideoRemoveFromAlbum) params() Params {
	params := make(Params)
	if req.TargetID != 0 {
		params["target_id"] = req.TargetID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if len(req.AlbumIDs) > 0 {
		params["album_ids"] = req.AlbumIDs
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	return params
}

// VideoReorderAlbums.
//
// Reorders the album in the list of user video albums.
//
// https://vk.com/dev/video.reorderAlbums
type VideoReorderAlbums struct {
	OwnerID int64 // ID of the user or community that owns the albums..
	AlbumID int64 // Album ID.
	Before  int64 // ID of the album before which the album in question shall be placed.
	After   int64 // ID of the album after which the album in question shall be placed.
}

func (req VideoReorderAlbums) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.Before != 0 {
		params["before"] = req.Before
	}
	if req.After != 0 {
		params["after"] = req.After
	}
	return params
}

// VideoReorderVideos.
//
// Reorders the video in the video album.
//
// https://vk.com/dev/video.reorderVideos
type VideoReorderVideos struct {
	TargetID      int64 // ID of the user or community that owns the album with videos.
	AlbumID       int64 // ID of the video album.
	OwnerID       int64 // ID of the user or community that owns the video.
	VideoID       int64 // ID of the video.
	BeforeOwnerID int64 // ID of the user or community that owns the video before which the video in question shall be placed.
	BeforeVideoID int64 // ID of the video before which the video in question shall be placed.
	AfterOwnerID  int64 // ID of the user or community that owns the video after which the photo in question shall be placed.
	AfterVideoID  int64 // ID of the video after which the photo in question shall be placed.
}

func (req VideoReorderVideos) params() Params {
	params := make(Params)
	if req.TargetID != 0 {
		params["target_id"] = req.TargetID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.BeforeOwnerID != 0 {
		params["before_owner_id"] = req.BeforeOwnerID
	}
	if req.BeforeVideoID != 0 {
		params["before_video_id"] = req.BeforeVideoID
	}
	if req.AfterOwnerID != 0 {
		params["after_owner_id"] = req.AfterOwnerID
	}
	if req.AfterVideoID != 0 {
		params["after_video_id"] = req.AfterVideoID
	}
	return params
}

// VideoReport.
//
// Reports (submits a complaint about) a video.
//
// https://vk.com/dev/video.report
type VideoReport struct {
	OwnerID     int64  // ID of the user or community that owns the video.
	VideoID     int64  // Video ID.
	Reason      int64  // Reason for the complaint: '0' – spam, '1' – child pornography, '2' – extremism, '3' – violence, '4' – drug propaganda, '5' – adult material, '6' – insult, abuse
	Comment     string // Comment describing the complaint.
	SearchQuery string // (If the video was found in search results.) Search query string.
}

func (req VideoReport) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	if req.Comment != "" {
		params["comment"] = req.Comment
	}
	if req.SearchQuery != "" {
		params["search_query"] = req.SearchQuery
	}
	return params
}

// VideoReportComment.
//
// Reports (submits a complaint about) a comment on a video.
//
// https://vk.com/dev/video.reportComment
type VideoReportComment struct {
	OwnerID   int64 // ID of the user or community that owns the video.
	CommentID int64 // ID of the comment being reported.
	Reason    int64 // Reason for the complaint: , 0 – spam , 1 – child pornography , 2 – extremism , 3 – violence , 4 – drug propaganda , 5 – adult material , 6 – insult, abuse
}

func (req VideoReportComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// VideoRestore.
//
// Restores a previously deleted video.
//
// https://vk.com/dev/video.restore
type VideoRestore struct {
	VideoID int64 // Video ID.
	OwnerID int64 // ID of the user or community that owns the video.
}

func (req VideoRestore) params() Params {
	params := make(Params)
	if req.VideoID != 0 {
		params["video_id"] = req.VideoID
	}
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	return params
}

// VideoRestoreComment.
//
// Restores a previously deleted comment on a video.
//
// https://vk.com/dev/video.restoreComment
type VideoRestoreComment struct {
	OwnerID   int64 // ID of the user or community that owns the video.
	CommentID int64 // ID of the deleted comment.
}

func (req VideoRestoreComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// VideoSave.
//
// Returns a server address (required for upload) and video data.
//
// https://vk.com/dev/video.save
type VideoSave struct {
	Name           string // Name of the video.
	Description    string // Description of the video.
	IsPrivate      bool   // '1' — to designate the video as private (send it via a private message), the video will not appear on the user's video list and will not be available by ID for other users, '0' — not to designate the video as private
	Wallpost       bool   // '1' — to post the saved video on a user's wall, '0' — not to post the saved video on a user's wall
	Link           string // URL for embedding the video from an external website.
	GroupID        int64  // ID of the community in which the video will be saved. By default, the current user's page.
	AlbumID        int64  // ID of the album to which the saved video will be added.
	PrivacyView    []string
	PrivacyComment []string
	NoComments     bool
	Repeat         bool // '1' — to repeat the playback of the video, '0' — to play the video once,
	Compression    bool
}

func (req VideoSave) params() Params {
	params := make(Params)
	if req.Name != "" {
		params["name"] = req.Name
	}
	if req.Description != "" {
		params["description"] = req.Description
	}
	if req.IsPrivate {
		params["is_private"] = req.IsPrivate
	}
	if req.Wallpost {
		params["wallpost"] = req.Wallpost
	}
	if req.Link != "" {
		params["link"] = req.Link
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.AlbumID != 0 {
		params["album_id"] = req.AlbumID
	}
	if len(req.PrivacyView) > 0 {
		params["privacy_view"] = req.PrivacyView
	}
	if len(req.PrivacyComment) > 0 {
		params["privacy_comment"] = req.PrivacyComment
	}
	if req.NoComments {
		params["no_comments"] = req.NoComments
	}
	if req.Repeat {
		params["repeat"] = req.Repeat
	}
	if req.Compression {
		params["compression"] = req.Compression
	}
	return params
}

// VideoSearch.
//
// Returns a list of videos under the set search criterion.
//
// https://vk.com/dev/video.search
type VideoSearch struct {
	Q         string   // Search query string (e.g., 'The Beatles').
	Sort      int64    // Sort order: '1' — by duration, '2' — by relevance, '0' — by date added
	Hd        int64    // If not null, only searches for high-definition videos.
	Adult     bool     // '1' — to disable the Safe Search filter, '0' — to enable the Safe Search filter
	Filters   []string // Filters to apply: 'youtube' — return YouTube videos only, 'vimeo' — return Vimeo videos only, 'short' — return short videos only, 'long' — return long videos only
	SearchOwn bool
	Offset    int64 // Offset needed to return a specific subset of videos.
	Longer    int64
	Shorter   int64
	Count     int64 // Number of videos to return.
	Extended  bool
}

func (req VideoSearch) params() Params {
	params := make(Params)
	if req.Q != "" {
		params["q"] = req.Q
	}
	if req.Sort != 0 {
		params["sort"] = req.Sort
	}
	if req.Hd != 0 {
		params["hd"] = req.Hd
	}
	if req.Adult {
		params["adult"] = req.Adult
	}
	if len(req.Filters) > 0 {
		params["filters"] = req.Filters
	}
	if req.SearchOwn {
		params["search_own"] = req.SearchOwn
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Longer != 0 {
		params["longer"] = req.Longer
	}
	if req.Shorter != 0 {
		params["shorter"] = req.Shorter
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	return params
}

// WallCloseComments.
//
// https://vk.com/dev/wall.closeComments
type WallCloseComments struct {
	OwnerID int64
	PostID  int64
}

func (req WallCloseComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	return params
}

// WallCreateComment.
//
// Adds a comment to a post on a user wall or community wall.
//
// https://vk.com/dev/wall.createComment
type WallCreateComment struct {
	OwnerID        int64    // User ID or community ID. Use a negative value to designate a community ID.
	PostID         int64    // Post ID.
	FromGroup      int64    // Group ID.
	Message        string   // (Required if 'attachments' is not set.) Text of the comment.
	ReplyToComment int64    // ID of comment to reply.
	Attachments    []string // (Required if 'message' is not set.) List of media objects attached to the comment, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media ojbect: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media owner. '<media_id>' — Media ID. For example: "photo100172_166443618,photo66748_265827614"
	StickerID      int64    // Sticker ID.
	Guid           string   // Unique identifier to avoid repeated comments.
}

func (req WallCreateComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.FromGroup != 0 {
		params["from_group"] = req.FromGroup
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if req.ReplyToComment != 0 {
		params["reply_to_comment"] = req.ReplyToComment
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.StickerID != 0 {
		params["sticker_id"] = req.StickerID
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	return params
}

// WallDelete.
//
// Deletes a post from a user wall or community wall.
//
// https://vk.com/dev/wall.delete
type WallDelete struct {
	OwnerID int64 // User ID or community ID. Use a negative value to designate a community ID.
	PostID  int64 // ID of the post to be deleted.
}

func (req WallDelete) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	return params
}

// WallDeleteComment.
//
// Deletes a comment on a post on a user wall or community wall.
//
// https://vk.com/dev/wall.deleteComment
type WallDeleteComment struct {
	OwnerID   int64 // User ID or community ID. Use a negative value to designate a community ID.
	CommentID int64 // Comment ID.
}

func (req WallDeleteComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// WallEdit.
//
// Edits a post on a user wall or community wall.
//
// https://vk.com/dev/wall.edit
type WallEdit struct {
	OwnerID             int64 // User ID or community ID. Use a negative value to designate a community ID.
	PostID              int64
	FriendsOnly         bool
	Message             string   // (Required if 'attachments' is not set.) Text of the post.
	Attachments         []string // (Required if 'message' is not set.) List of objects attached to the post, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media application owner. '<media_id>' — Media application ID. Example: "photo100172_166443618,photo66748_265827614", May contain a link to an external page to include in the post. Example: "photo66748_265827614,http://habrahabr.ru", "NOTE: If more than one link is being attached, an error is thrown."
	Services            string
	Signed              bool
	PublishDate         int64
	Lat                 float64
	Long                float64
	PlaceID             int64
	MarkAsAds           bool
	CloseComments       bool
	PosterBkgID         int64
	PosterBkgOwnerID    int64
	PosterBkgAccessHash string
	Copyright           string
}

func (req WallEdit) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.FriendsOnly {
		params["friends_only"] = req.FriendsOnly
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.Services != "" {
		params["services"] = req.Services
	}
	if req.Signed {
		params["signed"] = req.Signed
	}
	if req.PublishDate != 0 {
		params["publish_date"] = req.PublishDate
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.PlaceID != 0 {
		params["place_id"] = req.PlaceID
	}
	if req.MarkAsAds {
		params["mark_as_ads"] = req.MarkAsAds
	}
	if req.CloseComments {
		params["close_comments"] = req.CloseComments
	}
	if req.PosterBkgID != 0 {
		params["poster_bkg_id"] = req.PosterBkgID
	}
	if req.PosterBkgOwnerID != 0 {
		params["poster_bkg_owner_id"] = req.PosterBkgOwnerID
	}
	if req.PosterBkgAccessHash != "" {
		params["poster_bkg_access_hash"] = req.PosterBkgAccessHash
	}
	if req.Copyright != "" {
		params["copyright"] = req.Copyright
	}
	return params
}

// WallEditAdsStealth.
//
// Allows to edit hidden post.
//
// https://vk.com/dev/wall.editAdsStealth
type WallEditAdsStealth struct {
	OwnerID     int64    // User ID or community ID. Use a negative value to designate a community ID.
	PostID      int64    // Post ID. Used for publishing of scheduled and suggested posts.
	Message     string   // (Required if 'attachments' is not set.) Text of the post.
	Attachments []string // (Required if 'message' is not set.) List of objects attached to the post, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'page' — wiki-page, 'note' — note, 'poll' — poll, 'album' — photo album, '<owner_id>' — ID of the media application owner. '<media_id>' — Media application ID. Example: "photo100172_166443618,photo66748_265827614", May contain a link to an external page to include in the post. Example: "photo66748_265827614,http://habrahabr.ru", "NOTE: If more than one link is being attached, an error will be thrown."
	Signed      bool     // Only for posts in communities with 'from_group' set to '1': '1' — post will be signed with the name of the posting user, '0' — post will not be signed (default)
	Lat         float64  // Geographical latitude of a check-in, in degrees (from -90 to 90).
	Long        float64  // Geographical longitude of a check-in, in degrees (from -180 to 180).
	PlaceID     int64    // ID of the location where the user was tagged.
	LinkButton  string   // Link button ID
	LinkTitle   string   // Link title
	LinkImage   string   // Link image url
	LinkVideo   string   // Link video ID in format "<owner_id>_<media_id>"
}

func (req WallEditAdsStealth) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.Signed {
		params["signed"] = req.Signed
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.PlaceID != 0 {
		params["place_id"] = req.PlaceID
	}
	if req.LinkButton != "" {
		params["link_button"] = req.LinkButton
	}
	if req.LinkTitle != "" {
		params["link_title"] = req.LinkTitle
	}
	if req.LinkImage != "" {
		params["link_image"] = req.LinkImage
	}
	if req.LinkVideo != "" {
		params["link_video"] = req.LinkVideo
	}
	return params
}

// WallEditComment.
//
// Edits a comment on a user wall or community wall.
//
// https://vk.com/dev/wall.editComment
type WallEditComment struct {
	OwnerID     int64    // User ID or community ID. Use a negative value to designate a community ID.
	CommentID   int64    // Comment ID.
	Message     string   // New comment text.
	Attachments []string // List of objects attached to the comment, in the following format: , "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, '<owner_id>' — ID of the media attachment owner. '<media_id>' — Media attachment ID. For example: "photo100172_166443618,photo66748_265827614"
}

func (req WallEditComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	return params
}

// WallGet.
//
// Returns a list of posts on a user wall or community wall.
//
// https://vk.com/dev/wall.get
type WallGet struct {
	OwnerID  int64  // ID of the user or community that owns the wall. By default, current user ID. Use a negative value to designate a community ID.
	Domain   string // User or community short address.
	Offset   int64  // Offset needed to return a specific subset of posts.
	Count    int64  // Number of posts to return (maximum 100).
	Filter   string // Filter to apply: 'owner' — posts by the wall owner, 'others' — posts by someone else, 'all' — posts by the wall owner and others (default), 'postponed' — timed posts (only available for calls with an 'access_token'), 'suggests' — suggested posts on a community wall
	Extended bool   // '1' — to return 'wall', 'profiles', and 'groups' fields, '0' — to return no additional fields (default)
	Fields   []BaseUserGroupFields
}

func (req WallGet) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Domain != "" {
		params["domain"] = req.Domain
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Filter != "" {
		params["filter"] = req.Filter
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// WallGetByID.
//
// Returns a list of posts from user or community walls by their IDs.
//
// https://vk.com/dev/wall.getById
type WallGetByID struct {
	Posts            []string // User or community IDs and post IDs, separated by underscores. Use a negative value to designate a community ID. Example: "93388_21539,93388_20904,2943_4276,-1_1"
	Extended         bool     // '1' — to return user and community objects needed to display posts, '0' — no additional fields are returned (default)
	CopyHistoryDepth int64    // Sets the number of parent elements to include in the array 'copy_history' that is returned if the post is a repost from another wall.
	Fields           []BaseUserGroupFields
}

func (req WallGetByID) params() Params {
	params := make(Params)
	if len(req.Posts) > 0 {
		params["posts"] = req.Posts
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if req.CopyHistoryDepth != 0 {
		params["copy_history_depth"] = req.CopyHistoryDepth
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// WallGetComment.
//
// Returns a comment on a post on a user wall or community wall.
//
// https://vk.com/dev/wall.getComment
type WallGetComment struct {
	OwnerID   int64 // User ID or community ID. Use a negative value to designate a community ID.
	CommentID int64 // Comment ID.
	Extended  bool
	Fields    []BaseUserGroupFields
}

func (req WallGetComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// WallGetComments.
//
// Returns a list of comments on a post on a user wall or community wall.
//
// https://vk.com/dev/wall.getComments
type WallGetComments struct {
	OwnerID          int64 // User ID or community ID. Use a negative value to designate a community ID.
	PostID           int64 // Post ID.
	NeedLikes        bool  // '1' — to return the 'likes' field, '0' — not to return the 'likes' field (default)
	StartCommentID   int64
	Offset           int64  // Offset needed to return a specific subset of comments.
	Count            int64  // Number of comments to return (maximum 100).
	Sort             string // Sort order: 'asc' — chronological, 'desc' — reverse chronological
	PreviewLength    int64  // Number of characters at which to truncate comments when previewed. By default, '90'. Specify '0' if you do not want to truncate comments.
	Extended         bool
	Fields           []BaseUserGroupFields
	CommentID        int64 // Comment ID.
	ThreadItemsCount int64 // Count items in threads.
}

func (req WallGetComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.NeedLikes {
		params["need_likes"] = req.NeedLikes
	}
	if req.StartCommentID != 0 {
		params["start_comment_id"] = req.StartCommentID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Sort != "" {
		params["sort"] = req.Sort
	}
	if req.PreviewLength != 0 {
		params["preview_length"] = req.PreviewLength
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.ThreadItemsCount != 0 {
		params["thread_items_count"] = req.ThreadItemsCount
	}
	return params
}

// WallGetReposts.
//
// Returns information about reposts of a post on user wall or community wall.
//
// https://vk.com/dev/wall.getReposts
type WallGetReposts struct {
	OwnerID int64 // User ID or community ID. By default, current user ID. Use a negative value to designate a community ID.
	PostID  int64 // Post ID.
	Offset  int64 // Offset needed to return a specific subset of reposts.
	Count   int64 // Number of reposts to return.
}

func (req WallGetReposts) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// WallOpenComments.
//
// https://vk.com/dev/wall.openComments
type WallOpenComments struct {
	OwnerID int64
	PostID  int64
}

func (req WallOpenComments) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	return params
}

// WallPin.
//
// Pins the post on wall.
//
// https://vk.com/dev/wall.pin
type WallPin struct {
	OwnerID int64 // ID of the user or community that owns the wall. By default, current user ID. Use a negative value to designate a community ID.
	PostID  int64 // Post ID.
}

func (req WallPin) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	return params
}

// WallPost.
//
// Adds a new post on a user wall or community wall. Can also be used to publish suggested or scheduled posts.
//
// https://vk.com/dev/wall.post
type WallPost struct {
	OwnerID           int64    // User ID or community ID. Use a negative value to designate a community ID.
	FriendsOnly       bool     // '1' — post will be available to friends only, '0' — post will be available to all users (default)
	FromGroup         bool     // For a community: '1' — post will be published by the community, '0' — post will be published by the user (default)
	Message           string   // (Required if 'attachments' is not set.) Text of the post.
	Attachments       []string // (Required if 'message' is not set.) List of objects attached to the post, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'page' — wiki-page, 'note' — note, 'poll' — poll, 'album' — photo album, '<owner_id>' — ID of the media application owner. '<media_id>' — Media application ID. Example: "photo100172_166443618,photo66748_265827614", May contain a link to an external page to include in the post. Example: "photo66748_265827614,http://habrahabr.ru", "NOTE: If more than one link is being attached, an error will be thrown."
	Services          string   // List of services or websites the update will be exported to, if the user has so requested. Sample values: 'twitter', 'facebook'.
	Signed            bool     // Only for posts in communities with 'from_group' set to '1': '1' — post will be signed with the name of the posting user, '0' — post will not be signed (default)
	PublishDate       int64    // Publication date (in Unix time). If used, posting will be delayed until the set time.
	Lat               float64  // Geographical latitude of a check-in, in degrees (from -90 to 90).
	Long              float64  // Geographical longitude of a check-in, in degrees (from -180 to 180).
	PlaceID           int64    // ID of the location where the user was tagged.
	PostID            int64    // Post ID. Used for publishing of scheduled and suggested posts.
	Guid              string
	MarkAsAds         bool
	CloseComments     bool
	MuteNotifications bool
	Copyright         string
}

func (req WallPost) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.FriendsOnly {
		params["friends_only"] = req.FriendsOnly
	}
	if req.FromGroup {
		params["from_group"] = req.FromGroup
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.Services != "" {
		params["services"] = req.Services
	}
	if req.Signed {
		params["signed"] = req.Signed
	}
	if req.PublishDate != 0 {
		params["publish_date"] = req.PublishDate
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.PlaceID != 0 {
		params["place_id"] = req.PlaceID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	if req.MarkAsAds {
		params["mark_as_ads"] = req.MarkAsAds
	}
	if req.CloseComments {
		params["close_comments"] = req.CloseComments
	}
	if req.MuteNotifications {
		params["mute_notifications"] = req.MuteNotifications
	}
	if req.Copyright != "" {
		params["copyright"] = req.Copyright
	}
	return params
}

// WallPostAdsStealth.
//
// Allows to create hidden post which will not be shown on the community's wall and can be used for creating an ad with type "Community post".
//
// https://vk.com/dev/wall.postAdsStealth
type WallPostAdsStealth struct {
	OwnerID     int64    // User ID or community ID. Use a negative value to designate a community ID.
	Message     string   // (Required if 'attachments' is not set.) Text of the post.
	Attachments []string // (Required if 'message' is not set.) List of objects attached to the post, in the following format: "<owner_id>_<media_id>,<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'page' — wiki-page, 'note' — note, 'poll' — poll, 'album' — photo album, '<owner_id>' — ID of the media application owner. '<media_id>' — Media application ID. Example: "photo100172_166443618,photo66748_265827614", May contain a link to an external page to include in the post. Example: "photo66748_265827614,http://habrahabr.ru", "NOTE: If more than one link is being attached, an error will be thrown."
	Signed      bool     // Only for posts in communities with 'from_group' set to '1': '1' — post will be signed with the name of the posting user, '0' — post will not be signed (default)
	Lat         float64  // Geographical latitude of a check-in, in degrees (from -90 to 90).
	Long        float64  // Geographical longitude of a check-in, in degrees (from -180 to 180).
	PlaceID     int64    // ID of the location where the user was tagged.
	Guid        string   // Unique identifier to avoid duplication the same post.
	LinkButton  string   // Link button ID
	LinkTitle   string   // Link title
	LinkImage   string   // Link image url
	LinkVideo   string   // Link video ID in format "<owner_id>_<media_id>"
}

func (req WallPostAdsStealth) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if len(req.Attachments) > 0 {
		params["attachments"] = req.Attachments
	}
	if req.Signed {
		params["signed"] = req.Signed
	}
	if req.Lat != 0 {
		params["lat"] = req.Lat
	}
	if req.Long != 0 {
		params["long"] = req.Long
	}
	if req.PlaceID != 0 {
		params["place_id"] = req.PlaceID
	}
	if req.Guid != "" {
		params["guid"] = req.Guid
	}
	if req.LinkButton != "" {
		params["link_button"] = req.LinkButton
	}
	if req.LinkTitle != "" {
		params["link_title"] = req.LinkTitle
	}
	if req.LinkImage != "" {
		params["link_image"] = req.LinkImage
	}
	if req.LinkVideo != "" {
		params["link_video"] = req.LinkVideo
	}
	return params
}

// WallReportComment.
//
// Reports (submits a complaint about) a comment on a post on a user wall or community wall.
//
// https://vk.com/dev/wall.reportComment
type WallReportComment struct {
	OwnerID   int64 // ID of the user or community that owns the wall.
	CommentID int64 // Comment ID.
	Reason    int64 // Reason for the complaint: '0' – spam, '1' – child pornography, '2' – extremism, '3' – violence, '4' – drug propaganda, '5' – adult material, '6' – insult, abuse
}

func (req WallReportComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// WallReportPost.
//
// Reports (submits a complaint about) a post on a user wall or community wall.
//
// https://vk.com/dev/wall.reportPost
type WallReportPost struct {
	OwnerID int64 // ID of the user or community that owns the wall.
	PostID  int64 // Post ID.
	Reason  int64 // Reason for the complaint: '0' – spam, '1' – child pornography, '2' – extremism, '3' – violence, '4' – drug propaganda, '5' – adult material, '6' – insult, abuse
}

func (req WallReportPost) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	if req.Reason != 0 {
		params["reason"] = req.Reason
	}
	return params
}

// WallRepost.
//
// Reposts (copies) an object to a user wall or community wall.
//
// https://vk.com/dev/wall.repost
type WallRepost struct {
	Object            string // ID of the object to be reposted on the wall. Example: "wall66748_3675"
	Message           string // Comment to be added along with the reposted object.
	GroupID           int64  // Target community ID when reposting to a community.
	MarkAsAds         bool
	MuteNotifications bool
}

func (req WallRepost) params() Params {
	params := make(Params)
	if req.Object != "" {
		params["object"] = req.Object
	}
	if req.Message != "" {
		params["message"] = req.Message
	}
	if req.GroupID != 0 {
		params["group_id"] = req.GroupID
	}
	if req.MarkAsAds {
		params["mark_as_ads"] = req.MarkAsAds
	}
	if req.MuteNotifications {
		params["mute_notifications"] = req.MuteNotifications
	}
	return params
}

// WallRestore.
//
// Restores a post deleted from a user wall or community wall.
//
// https://vk.com/dev/wall.restore
type WallRestore struct {
	OwnerID int64 // User ID or community ID from whose wall the post was deleted. Use a negative value to designate a community ID.
	PostID  int64 // ID of the post to be restored.
}

func (req WallRestore) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	return params
}

// WallRestoreComment.
//
// Restores a comment deleted from a user wall or community wall.
//
// https://vk.com/dev/wall.restoreComment
type WallRestoreComment struct {
	OwnerID   int64 // User ID or community ID. Use a negative value to designate a community ID.
	CommentID int64 // Comment ID.
}

func (req WallRestoreComment) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.CommentID != 0 {
		params["comment_id"] = req.CommentID
	}
	return params
}

// WallSearch.
//
// Allows to search posts on user or community walls.
//
// https://vk.com/dev/wall.search
type WallSearch struct {
	OwnerID    int64  // user or community id. "Remember that for a community 'owner_id' must be negative."
	Domain     string // user or community screen name.
	Query      string // search query string.
	OwnersOnly bool   // '1' – returns only page owner's posts.
	Count      int64  // count of posts to return.
	Offset     int64  // Offset needed to return a specific subset of posts.
	Extended   bool   // show extended post info.
	Fields     []BaseUserGroupFields
}

func (req WallSearch) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.Domain != "" {
		params["domain"] = req.Domain
	}
	if req.Query != "" {
		params["query"] = req.Query
	}
	if req.OwnersOnly {
		params["owners_only"] = req.OwnersOnly
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Extended {
		params["extended"] = req.Extended
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	return params
}

// WallUnpin.
//
// Unpins the post on wall.
//
// https://vk.com/dev/wall.unpin
type WallUnpin struct {
	OwnerID int64 // ID of the user or community that owns the wall. By default, current user ID. Use a negative value to designate a community ID.
	PostID  int64 // Post ID.
}

func (req WallUnpin) params() Params {
	params := make(Params)
	if req.OwnerID != 0 {
		params["owner_id"] = req.OwnerID
	}
	if req.PostID != 0 {
		params["post_id"] = req.PostID
	}
	return params
}

// WidgetsGetComments.
//
// Gets a list of comments for the page added through the [vk.com/dev/Comments|Comments widget].
//
// https://vk.com/dev/widgets.getComments
type WidgetsGetComments struct {
	WidgetApiID int64
	URL         string
	PageID      string
	Order       string
	Fields      []UsersFields
	Offset      int64
	Count       int64
}

func (req WidgetsGetComments) params() Params {
	params := make(Params)
	if req.WidgetApiID != 0 {
		params["widget_api_id"] = req.WidgetApiID
	}
	if req.URL != "" {
		params["url"] = req.URL
	}
	if req.PageID != "" {
		params["page_id"] = req.PageID
	}
	if req.Order != "" {
		params["order"] = req.Order
	}
	if len(req.Fields) > 0 {
		params["fields"] = req.Fields
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}

// WidgetsGetPages.
//
// Gets a list of application/site pages where the [vk.com/dev/Comments|Comments widget] or [vk.com/dev/Like|Like widget] is installed.
//
// https://vk.com/dev/widgets.getPages
type WidgetsGetPages struct {
	WidgetApiID int64
	Order       string
	Period      string
	Offset      int64
	Count       int64
}

func (req WidgetsGetPages) params() Params {
	params := make(Params)
	if req.WidgetApiID != 0 {
		params["widget_api_id"] = req.WidgetApiID
	}
	if req.Order != "" {
		params["order"] = req.Order
	}
	if req.Period != "" {
		params["period"] = req.Period
	}
	if req.Offset != 0 {
		params["offset"] = req.Offset
	}
	if req.Count != 0 {
		params["count"] = req.Count
	}
	return params
}
