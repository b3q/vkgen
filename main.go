package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"unicode"

	"go/format"

	"github.com/b3q/vkgen/schema"
	"github.com/tidwall/gjson"
)

const (
	genPrefix = "// Code generated by vkgen; DO NOT EDIT."
	pkgName   = "generated"
)

func main() {
	if _, err := os.Stat(pkgName); os.IsNotExist(err) {
		os.Mkdir(pkgName, os.ModePerm)
	}
	generateObjects()
	generateResponses()
	generateMethods()
}

func generateObjects() {
	objectsB, err := ioutil.ReadFile("objects.json")
	if err != nil {
		panic(err)
	}

	objects := gjson.ParseBytes(objectsB)
	parser := schema.NewParser()

	b := bytes.NewBuffer(nil)
	b.WriteString(genPrefix + "\n\npackage " + pkgName + "\n")
	objects.Get("definitions").ForEach(func(defName, definition gjson.Result) bool {
		def := parser.ParseDefinition(defName.String(), definition)
		b.WriteString(rootDefToString(def))
		return true
	})

	src, err := format.Source(b.Bytes())
	if err != nil {
		panic(err)
	}
	ioutil.WriteFile(pkgName+"/objects.gen.go", src, 0677)
}

func generateResponses() {
	responsesB, err := ioutil.ReadFile("responses.json")
	if err != nil {
		panic(err)
	}

	responses := gjson.ParseBytes(responsesB)
	parser := schema.NewParser()
	b := bytes.NewBuffer(nil)
	b.WriteString(genPrefix + "\n\npackage " + pkgName + "\n")
	responses.Get("definitions").ForEach(func(defName, definition gjson.Result) bool {
		def := parser.ParseDefinition(defName.String(), definition.Get("properties.response"))
		if req := definition.Get("properties.response.required"); req.Exists() && req.IsArray() {
			requiredFields := make(map[string]struct{})
			for _, field := range req.Array() {
				requiredFields[field.String()] = struct{}{}
			}

			for _, prop := range def.Properties {
				if _, found := requiredFields[*prop.Name]; !found {
					prop.IsOptional = true
				}
			}
		}
		b.WriteString(rootDefToString(def))
		return true
	})

	src, err := format.Source(b.Bytes())
	if err != nil {
		panic(err)
	}
	ioutil.WriteFile(pkgName+"/responses.gen.go", src, 0677)
}

func generateMethods() {
	methodsB, err := ioutil.ReadFile("methods.json")
	if err != nil {
		panic(err)
	}

	methods := gjson.ParseBytes(methodsB)
	parser := schema.NewParser()
	b := bytes.NewBuffer(nil)
	b.WriteString(genPrefix + "\n\npackage " + pkgName + "\n")
	for _, method := range methods.Get("methods").Array() {
		methodName := method.Get("name").String()
		if len(method.Get("responses").Map()) == 1 {
			def := parser.ParseDefinition(methodName, method.Get("responses.response"))
			if desc := method.Get("description"); desc.Exists() {
				b.WriteString("// " + desc.String())
			}
			b.WriteString(`
			func (vk *VK) ` + goify(methodName) + `(params Params) (response ` + defWithoutProps(def) + `, err error) {
				err = vk.RequestUnmarshal("` + methodName + `", params, &response)
				return
			}` + "\n\n")
			continue
		}

		fmt.Fprintln(b, `
			func (vk *VK) `+goify(methodName)+`Raw(params Params) ([]byte, error) {
				return vk.Request("`+methodName+`", params)
			}`)
	}

	src, err := format.Source(b.Bytes())
	if err != nil {
		panic(err)
	}
	ioutil.WriteFile(pkgName+"/methods.gen.go", src, 0677)
}

func goify(name string) string {
	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	for i, r := range runes {
		if r == '_' || r == ' ' || r == '.' {
			runes[i+1] = unicode.ToUpper(runes[i+1])
		}
	}

	str := strings.ReplaceAll(string(runes), "_", "")
	str = strings.ReplaceAll(str, " ", "")
	str = strings.ReplaceAll(str, ".", "")

	repl := map[string]string{
		"2fa":  "TwoFA",
		"json": "JSON",
		"Id":   "ID",
		"Ttl":  "TTL",
		"Sdk":  "SDK",
		"Vk":   "VK",
		"Tv":   "TV",
		"Url":  "URL",
	}
	for from, to := range repl {
		str = strings.ReplaceAll(str, from, to)
	}

	return str
}

func enumToString(enum schema.Enum) string {
	var sb strings.Builder
	if enum.Description != nil {
		sb.WriteString("\n// " + *enum.Description)
	}
	sb.WriteString("\ntype " + goify(enum.Name) + " ")
	switch enum.DataType {
	case schema.IntegerType:
		sb.WriteString("int64\n")
		if len(enum.IntegerValues) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, value := range enum.IntegerValues {
			s := strconv.FormatInt(value, 10)
			fieldName := enum.Name + "_" + s
			if len(enum.Names) > 0 {
				fieldName = enum.Name + "_" + enum.Names[idx]
			}
			sb.WriteString("\t" + goify(fieldName) + " " + goify(enum.Name) + " = " + s + "\n")
		}
		sb.WriteString(")\n")
	case schema.NumberType:
		sb.WriteString("float64\n")
		if len(enum.NumberValues) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, value := range enum.NumberValues {
			s := strconv.FormatFloat(value, 'g', 10, 64)
			fieldName := enum.Name + "_" + s
			if len(enum.Names) > 0 {
				fieldName = enum.Name + "_" + enum.Names[idx]
			}
			sb.WriteString("\t" + goify(fieldName) + " " + goify(enum.Name) + " = " + s + "\n")
		}
		sb.WriteString(")\n")
	case schema.StringType:
		sb.WriteString("string\n")
		if len(enum.StringValues) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, value := range enum.StringValues {
			fieldName := enum.Name + "_" + value
			if len(enum.Names) > 0 {
				fieldName = enum.Name + "_" + enum.Names[idx]
			}
			sb.WriteString("\t" + goify(fieldName) + " " + goify(enum.Name) + " = \"" + value + "\"\n")
		}
		sb.WriteString(")\n")
	case schema.BooleanType:
		sb.WriteString("boolXXX")
	case schema.ObjectType:
		sb.WriteString("interface{}\n")
	default:
		sb.WriteString("wtf " + string(enum.DataType))
	}

	return sb.String()
}

func arrayToString(array schema.Array) string {
	switch array.DataType {
	case schema.IntegerType:
		return "[]int64"
	case schema.NumberType:
		return "[]float64"
	case schema.BooleanType:
		return "[]bool"
	case schema.StringType:
		return "[]string"
	case schema.ArrayType:
		return "[]" + arrayToString(*array.Ref.Array)
	case schema.ReferenceType:
		return "[]" + goify(*array.Ref.Name)
	case schema.AllofType:
		str := "[]struct{\n"
		for _, item := range array.AllOf.PossibleValues {
			switch item.DataType {
			case schema.ReferenceType:
				str += "\t\t*" + goify(*item.Name) + "\n"
			case schema.NumberType:
				fallthrough
			case schema.IntegerType:
				fallthrough
			default:
				panic("unsupported array type: " + string(item.DataType))
			}
		}
		str += "\t}"
		return str
	default:
		return "[]interface{} //hz"
		//panic("unsupported array data type: " + string(array.DataType))
	}
}

func oneofToString(oneof schema.OneOf) string {
	var sb strings.Builder
	sb.WriteString("\n// oneof " + oneof.Name)
	sb.WriteString("\ntype " + goify(oneof.Name) + " struct{\n")

	for _, value := range oneof.PossibleValues {
		if value.Name != nil {
			jsonPrefix := "`json:\"" + *value.Name + ",omitempty\"`"
			sb.WriteString("\t*" + goify(*value.Name) + jsonPrefix + "\n")
			continue
		}

		//sb.WriteString("\t*struct{\n")
		for _, prop := range value.Properties {
			jsonPrefix := "`json:\"" + *prop.Name + ",omitempty\"`"
			sb.WriteString("\t" + goify(*prop.Name) + " ")
			switch prop.DataType {
			case schema.IntegerType:
				sb.WriteString("int64")
			case schema.NumberType:
				sb.WriteString("float64")
			case schema.StringType:
				sb.WriteString("string")
			case schema.BooleanType:
				sb.WriteString("bool")
			case schema.ReferenceType:
				sb.WriteString(goify(*prop.RefTo))
			default:
				sb.WriteString("unknown:" + string(prop.DataType))
			}
			sb.WriteString(jsonPrefix + "\n")
		}
		//sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func allofToString(allof schema.AllOf) string {
	var sb strings.Builder
	sb.WriteString("\n// allof " + allof.Name)
	sb.WriteString("\ntype " + goify(allof.Name) + " struct{\n")
	for _, value := range allof.PossibleValues {
		if value.Name != nil {
			jsonPrefix := "`json:\"" + *value.Name + ",omitempty\"`"
			sb.WriteString("\t*" + goify(*value.Name) + jsonPrefix + "\n")
			continue
		}

		//sb.WriteString("\t*struct{\n")
		for _, prop := range value.Properties {
			jsonPrefix := "`json:\"" + *prop.Name + ",omitempty\"`"
			sb.WriteString("\t" + goify(*prop.Name) + " ")
			switch prop.DataType {
			case schema.IntegerType:
				sb.WriteString("*int64")
			case schema.NumberType:
				sb.WriteString("*float64")
			case schema.StringType:
				sb.WriteString("*string")
			case schema.BooleanType:
				sb.WriteString("*bool")
			case schema.ReferenceType:
				sb.WriteString("*" + goify(*prop.RefTo))
			case schema.ArrayType:
				sb.WriteString("*" + arrayToString(*prop.Array))
			default:
				sb.WriteString("unknown:" + string(prop.DataType))
			}
			sb.WriteString(jsonPrefix + "\n")
		}
		//sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func rootDefToString(def *schema.Definition) string {
	if def.Enum != nil {
		return enumToString(*def.Enum)
	}

	if def.OneOf != nil {
		return oneofToString(*def.OneOf)
	}

	if def.AllOf != nil {
		return allofToString(*def.AllOf)
	}

	// если нет полей, походу это филд
	if len(def.Properties) == 0 {
		s := "\ntype " + goify(*def.Name) + " " + defWithoutProps(def) + "\n"
		if def.Description != nil {
			s = "\n// " + *def.Description + s
		}
		return s
	}

	if def.DataType != schema.ObjectType {
		panic("unexpected definition data type: " + string(def.DataType))
	}

	var sb strings.Builder
	if def.Description != nil {
		sb.WriteString("\n// " + *def.Description)
	}
	sb.WriteString("\ntype " + goify(*def.Name) + " struct{\n")
	for _, prop := range def.Properties {
		jsonTag := "`json:\"" + *prop.Name
		ptr := false
		if prop.IsOptional {
			jsonTag += ",omitempty"
			ptr = true
		}
		jsonTag += "\"`"
		propertyType := defWithoutProps(prop)

		if prop.DataType == schema.ReferenceType {
			if propertyType == goify(*def.Name) || ptr {
				propertyType = "*" + propertyType
			}
		}

		if prop.Description != nil {
			jsonTag += " // " + *prop.Description
		}

		sb.WriteString("\t" + goify(*prop.Name) + " " + propertyType + " " + jsonTag + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func defWithoutProps(def *schema.Definition) string {
	switch def.DataType {
	case schema.ReferenceType:
		return goify(*def.RefTo)
	case schema.ArrayType:
		return arrayToString(*def.Array)
	case schema.EnumType:
		return goify(def.Enum.Name)
	case schema.OneofType:
		return goify(def.OneOf.Name)
	case schema.AllofType:
		return goify(def.AllOf.Name)
	case schema.BooleanType:
		return "bool"
	case schema.IntegerType:
		return "int64"
	case schema.NumberType:
		return "float64"
	case schema.StringType:
		return "string"
	case schema.ObjectType:
		//sb.WriteString("interface{} //hz")
		//str := rootDefToString(prop)
		//fmt.Println("kek:" + str + ":kek")
		// sb.Reset()
		// sb.WriteString("\ntype " + goify(*def.Name) + " struct{\n")
		// for _, prop := range def.Properties {
		// 	sb.WriteString("\t" + rootDefToString(prop) + "\n")
		// }
		// sb.WriteString("}\n")
		fallthrough
	case schema.UnsupportedType:
		return "interface{}"
	default:
		panic("unsupported datatype: " + string(def.DataType))
	}
}

func methodResponseDefToString(def *schema.Definition) string {
	var sb strings.Builder
	sb.WriteString("\ntype " + goify(*def.Name) + " struct{\n")
	for _, prop := range def.Properties {
		ptr := false
		if prop.IsOptional {
			ptr = true
		}
		propertyType := defWithoutProps(prop)

		if prop.DataType == schema.ReferenceType {
			if propertyType == goify(*def.Name) || ptr {
				propertyType = "*" + propertyType
			}
		}

		sb.WriteString("\t*" + propertyType + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}
