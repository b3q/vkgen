package main

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"strconv"
	"strings"
	"unicode"

	"github.com/b3q/vkgen/schema"
)

const (
	genPrefix = "// Code generated by vkgen; DO NOT EDIT."
	pkgName   = "generated"
)

type Generator struct {
	nofmt         bool
	nogoify       bool
	debug         bool
	goifyReplacer *strings.Replacer
}

func NewGenerator(nofmt, nogoify, debug bool) Generator {
	repl := []string{
		"_", "",
		" ", "",
		".", "",
		"2fa", "TwoFA",
		"json", "JSON",
		"Id", "ID",
		"Ttl", "TTL",
		"Sdk", "SDK",
		"Vk", "VK",
		"Tv", "TV",
		"Url", "URL",
	}

	return Generator{
		nofmt:         nofmt,
		nogoify:       nogoify,
		debug:         debug,
		goifyReplacer: strings.NewReplacer(repl...),
	}
}

func (g Generator) Generate() (err error) {
	err = g.generateObjects()
	if err != nil {
		return err
	}

	err = g.generateResponses()
	if err != nil {
		return err
	}

	err = g.generateMethods()
	if err != nil {
		return err
	}

	err = g.generateBuilders()
	if err != nil {
		return err
	}

	return
}

func (g Generator) writeSource(name string, b *bytes.Buffer) error {
	if g.nofmt {
		return ioutil.WriteFile(name, b.Bytes(), 0677)
	}

	src, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}

	return ioutil.WriteFile(name, src, 0677)
}

type callback = func(b *bytes.Buffer, schema []byte) error

func (g Generator) generate(schemaFile, outputName string, cb callback) error {
	sch, err := ioutil.ReadFile(schemaFile)
	if err != nil {
		return err
	}

	b := bytes.NewBuffer(nil)
	b.WriteString(genPrefix + "\n\npackage " + pkgName + "\n")

	err = cb(b, sch)
	if err != nil {
		return err
	}

	return g.writeSource(outputName, b)
}

func (g Generator) generateObjects() error {
	return g.generate("objects.json", pkgName+"/objects.gen.go",
		func(b *bytes.Buffer, objectsSchema []byte) error {
			objects, err := schema.ParseObjects(objectsSchema)
			if err != nil {
				return err
			}

			for _, object := range objects {
				b.WriteString(g.ObjectDefinitionToGolang(object) + "\n")
			}

			return nil
		})
}

func (g Generator) generateResponses() error {
	return g.generate("responses.json", pkgName+"/responses.gen.go",
		func(b *bytes.Buffer, responsesSchema []byte) error {
			responses, err := schema.ParseResponses(responsesSchema)
			if err != nil {
				return err
			}

			for _, response := range responses {
				b.WriteString(g.ResponseDefinitionToGolang(response) + "\n")
			}
			return nil
		})
}

func (g Generator) generateMethods() error {
	return g.generate("methods.json", pkgName+"/methods.gen.go",
		func(b *bytes.Buffer, methodsSchema []byte) error {
			methods, err := schema.ParseMethods(methodsSchema)
			if err != nil {
				return err
			}

			for _, method := range methods {
				b.WriteString(g.MethodDefinitionToGolang(method) + "\n\n")
			}
			return nil
		})
}

func (g Generator) generateBuilders() error {
	return g.generate("methods.json", pkgName+"/builders.gen.go",
		func(b *bytes.Buffer, methodsSchema []byte) error {
			methods, err := schema.ParseMethods(methodsSchema)
			if err != nil {
				return err
			}

			for _, method := range methods {
				// define struct
				builderName := g.goify(method.Name) + `Builder`
				b.WriteString("// " + builderName + " builder.\n")
				b.WriteString("// \n")
				if method.Description != nil {
					b.WriteString("// " + *method.Description + "\n")
					b.WriteString("// \n")
				}

				b.WriteString("// https://vk.com/dev/" + method.Name + "\n")
				b.WriteString(`type ` + builderName + ` struct {` + "\n")
				b.WriteString("\tapi.Params\n")
				b.WriteString("}\n\n")

				// define constructor
				b.WriteString("// " + builderName + " func.\n")
				b.WriteString("func New" + builderName + "() *" + builderName + " {\n")
				b.WriteString("\treturn &" + builderName + "{api.Params{}}\n")
				b.WriteString("}\n\n")

				for _, parameter := range method.Parameters {
					if parameter.Description != nil {
						b.WriteString("// " + *parameter.Description + "\n")
					}

					b.WriteString("func (b *" + builderName + ") " + g.goify(parameter.Name) + "(v " + g.objectExprToGolang(parameter.ObjectExpr) + ") *" + builderName + " {\n")
					b.WriteString("\tb.Params[\"" + parameter.Name + "\"] = v\n")
					b.WriteString("\treturn b\n")
					b.WriteString("}\n\n")
				}
			}
			return nil
		})
}

func (g Generator) goify(name string) string {
	if g.nogoify {
		return name
	}

	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	for i, r := range runes {
		if r == '_' || r == ' ' || r == '.' {
			runes[i+1] = unicode.ToUpper(runes[i+1])
		}
	}

	return g.goifyReplacer.Replace(string(runes))
}

func (g Generator) ObjectDefinitionToGolang(obj schema.ObjectDefinition) string {
	var sb strings.Builder
	if obj.Expr.Description != nil {
		sb.WriteString("// " + *obj.Expr.Description + "\n")
	}

	if obj.Expr.IsBaseType || obj.Expr.IsReference {
		sb.WriteString("type " + g.goify(obj.Name) + " " + g.objectExprToGolang(obj.Expr) + "\n")
		return sb.String()
	}

	if obj.Expr.IsEnum {
		// if obj.Expr.Description == nil{
		// 	sb.WriteString("// enum " + obj.Name + "\n")
		// }
		sb.WriteString("type " + g.goify(obj.Name) + " " + g.objectExprToGolang(obj.Expr) + "\n")
		if len(obj.Expr.Enum) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, item := range obj.Expr.Enum {
			val := "undefined"
			isString := false
			switch obj.Expr.Type {
			case "number":
				val = strconv.FormatFloat(item.(float64), 'g', 10, 64)
			case "integer":
				val = strconv.FormatInt(item.(int64), 10)
			case "string":
				val = item.(string)
				isString = true
			default:
				panic("unsupported enum type")
			}

			fieldNamePostfix := val
			if len(obj.Expr.EnumNames) > 0 {
				fieldNamePostfix = obj.Expr.EnumNames[idx]
			}

			if isString {
				val = `"` + val + `"`
			}

			fieldName := g.goify(obj.Name) + g.goify(fieldNamePostfix)
			sb.WriteString("\t" + fieldName + " " + g.goify(obj.Name) + " = " + val + "\n")
		}
		sb.WriteString(")\n")
		return sb.String()
	}

	if obj.Expr.IsAllOf || obj.Expr.IsOneOf {
		var values []schema.ObjectExpr
		if obj.Expr.IsAllOf {
			if obj.Expr.Description == nil {
				sb.WriteString("// allof " + obj.Name + "\n")
			}
			values = obj.Expr.AllOf
		}
		if obj.Expr.IsOneOf {
			if obj.Expr.Description == nil {
				sb.WriteString("// oneof " + obj.Name + "\n")
			}
			values = obj.Expr.OneOf
		}

		sb.WriteString("type " + g.goify(obj.Name) + " struct {\n")
		for _, val := range values {
			if val.IsReference {
				jtag := "`json:\"" + *val.RefTo + ",omitempty\"`"
				sb.WriteString("\t*" + g.objectExprToGolang(val) + " " + jtag + "\n")
				continue
			}

			for _, prop := range val.Properties {
				jtag := "`json:\"" + prop.Name + ",omitempty\"`"
				sb.WriteString("\t" + g.goify(prop.Name) + "*" + g.objectExprToGolang(prop.Expr) + " " + jtag + "\n")
			}
		}
		sb.WriteString("}\n")
		return sb.String()
	}

	sb.WriteString("type " + g.goify(obj.Name) + " struct {\n")
	for _, prop := range obj.Expr.Properties {
		jsonTag := "`json:\"" + prop.Name
		jsonTag += "\"`"
		goType := g.objectExprToGolang(prop.Expr)

		if prop.Expr.IsReference {
			if obj.Name == *prop.Expr.RefTo {
				goType = "*" + goType
			}
		}

		if prop.Expr.Description != nil {
			jsonTag += " // " + *prop.Expr.Description
		}

		sb.WriteString("\t" + g.goify(prop.Name) + " " + goType + " " + jsonTag + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) objectExprToGolang(expr schema.ObjectExpr) string {
	if expr.IsReference {
		return g.goify(*expr.RefTo)
	}

	if expr.IsAllOf {
		if len(expr.AllOf) > 0 {
			var sb strings.Builder
			sb.WriteString("struct{\n")
			for _, val := range expr.AllOf {
				if val.IsReference {
					sb.WriteString("\t*" + g.goify(*val.RefTo) + "\n")
					continue
				}

				if len(val.Properties) == 0 {
					panic("wtf")
				}

				sb.WriteString("*struct{\n")
				for _, prop := range val.Properties {
					sb.WriteString("\t*" + g.goify(prop.Name) + "\n")
				}
				sb.WriteString("}\n")
			}
			sb.WriteString("}")
			return sb.String()
		}
	}

	switch expr.Type {
	case "integer":
		return "int64"
	case "number":
		return "float64"
	case "string":
		return "string"
	case "boolean":
		return "bool"
	case "array":
		return "[]" + g.objectExprToGolang(*expr.ArrayOf)
	case "object":
		if len(expr.Properties) > 0 {
			var sb strings.Builder
			sb.WriteString("struct{\n")
			for _, prop := range expr.Properties {
				jtag := "`json:\"" + prop.Name + "\"`"
				sb.WriteString("\t" + g.goify(prop.Name) + " " + g.objectExprToGolang(prop.Expr) + " " + jtag + "\n")
			}
			sb.WriteString("}\n")
			return sb.String()
		}
		fallthrough
	default:
		return "interface{}"
	}
}

var responseRules = map[string]string{
	"messages_delete_response": "map[string]int64",
}

func (g Generator) ResponseDefinitionToGolang(resp schema.ResponseDefinition) string {
	var sb strings.Builder
	if resp.Expr.Description != nil {
		sb.WriteString("// " + *resp.Expr.Description + "\n")
	}

	if forcedType, ok := responseRules[resp.Name]; ok {
		sb.WriteString("type " + g.goify(resp.Name) + " " + forcedType + "\n")
		return sb.String()
	}

	if resp.Expr.IsBaseType || resp.Expr.IsReference {
		sb.WriteString("type " + g.goify(resp.Name) + " " + g.objectExprToGolang(resp.Expr.ObjectExpr) + "\n")
		return sb.String()
	}

	if resp.Expr.IsEnum {
		// if obj.Expr.Description == nil{
		// 	sb.WriteString("// enum " + obj.Name + "\n")
		// }
		sb.WriteString("type " + g.goify(resp.Name) + " " + g.objectExprToGolang(resp.Expr.ObjectExpr) + "\n")
		if len(resp.Expr.Enum) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, item := range resp.Expr.Enum {
			val := "undefined"
			isString := false
			switch resp.Expr.ObjectExpr.Type {
			case "number":
				val = strconv.FormatFloat(item.(float64), 'g', 10, 64)
			case "integer":
				val = strconv.FormatInt(item.(int64), 10)
			case "string":
				val = item.(string)
				isString = true
			default:
				panic("unsupported enum type")
			}

			fieldNamePostfix := val
			if len(resp.Expr.EnumNames) > 0 {
				fieldNamePostfix = resp.Expr.EnumNames[idx]
			}

			if isString {
				val = `"` + val + `"`
			}

			fieldName := g.goify(resp.Name) + g.goify(fieldNamePostfix)
			sb.WriteString("\t" + fieldName + " " + g.goify(resp.Name) + " = " + val + "\n")
		}
		sb.WriteString(")\n")
		return sb.String()
	}

	if resp.Expr.IsAllOf || resp.Expr.IsOneOf {
		var values []schema.ObjectExpr
		if resp.Expr.IsAllOf {
			// if obj.Expr.Description == nil{
			// 	sb.WriteString("// allof " + obj.Name + "\n")
			// }
			values = resp.Expr.AllOf
		}
		if resp.Expr.IsOneOf {
			// if obj.Expr.Description == nil{
			// 	sb.WriteString("// oneof " + obj.Name + "\n")
			// }
			values = resp.Expr.OneOf
		}

		sb.WriteString("type " + g.goify(resp.Name) + " struct {\n")
		for _, val := range values {
			if val.IsReference {
				jtag := "`json:\"" + *val.RefTo + ",omitempty\"`"
				sb.WriteString("\t*" + g.objectExprToGolang(val) + " " + jtag + "\n")
				continue
			}

			for _, prop := range val.Properties {
				jtag := "`json:\"" + prop.Name + ",omitempty\"`"
				sb.WriteString("\t" + g.goify(prop.Name) + "*" + g.objectExprToGolang(prop.Expr) + " " + jtag + "\n")
			}
		}
		sb.WriteString("}\n")
		return sb.String()
	}

	requiredFields := make(map[string]struct{})
	for _, field := range resp.Expr.Required {
		requiredFields[field] = struct{}{}
	}
	allFieldsRequired := len(requiredFields) == 0
	sb.WriteString("type " + g.goify(resp.Name) + " struct {\n")
	for _, prop := range resp.Expr.Properties {
		jsonTag := "`json:\"" + prop.Name
		ptr := false
		if _, required := requiredFields[prop.Name]; !required && !allFieldsRequired {
			jsonTag += ",omitempty"
			ptr = true
		}
		jsonTag += "\"`"
		goType := g.objectExprToGolang(prop.Expr)

		if prop.Expr.IsReference {
			if resp.Name == *prop.Expr.RefTo || ptr {
				goType = "*" + goType
			}
		}

		if prop.Expr.Description != nil {
			jsonTag += " // " + *prop.Expr.Description
		}

		sb.WriteString("\t" + g.goify(prop.Name) + " " + goType + " " + jsonTag + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) MethodDefinitionToGolang(method schema.MethodDefinition) string {
	var b strings.Builder
	if method.Description != nil {
		b.WriteString("// " + *method.Description + "\n")
	}

	if len(method.Responses) == 1 {
		resp := method.Responses[0]
		b.WriteString("func (vk *VK) " + g.goify(method.Name) + "(params Params) (response " + g.objectExprToGolang(resp.Expr) + ", err error) {\n")
		b.WriteString("\terr = vk.RequestUnmarshal(\"" + method.Name + "\", params, &response)\n")
		b.WriteString("\treturn\n")
		b.WriteString("}")
		return b.String()
	}

	b.WriteString("func (vk *VK) " + g.goify(method.Name) + "Raw(params Params) ([]byte, error) {\n")
	b.WriteString("\treturn vk.Request(\"" + method.Name + "\", params)\n")
	b.WriteString("}")
	return b.String()
}
