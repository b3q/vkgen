package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"strconv"
	"strings"
	"unicode"

	"github.com/cqln/vkgen/schema"
)

const (
	genPrefix = "// Code generated by vkgen; DO NOT EDIT."
	pkgName   = "generated"
)

type Generator struct {
	parser        *schema.Parser
	nofmt         bool
	nogoify       bool
	debug         bool
	goifyReplacer *strings.Replacer
}

func NewGenerator(nofmt, nogoify, debug bool, objectsSchema []byte) Generator {
	repl := []string{
		"_", "",
		" ", "",
		".", "",
		"2fa", "TwoFA",
		"json", "JSON",
		"Id", "ID",
		"Ttl", "TTL",
		"Sdk", "SDK",
		"Vk", "VK",
		"Tv", "TV",
		"Url", "URL",
	}

	return Generator{
		parser:        schema.NewParser(objectsSchema),
		nofmt:         nofmt,
		nogoify:       nogoify,
		debug:         debug,
		goifyReplacer: strings.NewReplacer(repl...),
	}
}

func (g Generator) Generate() (err error) {
	err = g.generateObjects()
	if err != nil {
		return err
	}

	err = g.generateResponses()
	if err != nil {
		return fmt.Errorf("responses: %w", err)
	}

	err = g.generateMethods()
	if err != nil {
		return fmt.Errorf("methods: %w", err)
	}

	err = g.generateMethodsTypeSafe()
	if err != nil {
		return fmt.Errorf("methods type-safe: %w", err)
	}

	err = g.generateBuilders()
	if err != nil {
		return fmt.Errorf("builders: %w", err)
	}

	err = g.generateRequests()
	if err != nil {
		return fmt.Errorf("requests: %w", err)
	}

	return
}

func (g Generator) writeSource(name string, b *bytes.Buffer) error {
	if g.nofmt {
		return ioutil.WriteFile(name, b.Bytes(), 0677)
	}

	src, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}

	return ioutil.WriteFile(name, src, 0677)
}

type callback = func(b *bytes.Buffer, schema []byte) error

func (g Generator) generate(schemaFile, outputName string, cb callback) error {
	sch, err := ioutil.ReadFile(schemaFile)
	if err != nil {
		return err
	}

	b := bytes.NewBuffer(nil)
	b.WriteString(genPrefix + "\n\npackage " + pkgName + "\n")

	err = cb(b, sch)
	if err != nil {
		return err
	}

	return g.writeSource(outputName, b)
}

func (g Generator) generateObjects() error {
	return g.generate("objects.json", pkgName+"/objects.gen.go",
		func(b *bytes.Buffer, objectsSchema []byte) error {
			objects, err := g.parser.ParseObjects(objectsSchema)
			if err != nil {
				return err
			}
			for _, object := range objects {
				b.WriteString(g.ObjectDefinitionToGolang(object) + "\n")
			}

			return nil
		})
}

func (g Generator) generateResponses() error {
	return g.generate("responses.json", pkgName+"/responses.gen.go",
		func(b *bytes.Buffer, responsesSchema []byte) error {
			responses, err := g.parser.ParseResponses(responsesSchema)
			if err != nil {
				return err
			}

			for _, response := range responses {
				typ := g.ResponseDefinitionToGolang(response)
				b.WriteString(typ + "\n")
			}
			return nil
		})
}

func (g Generator) generateMethods() error {
	return g.generate("methods.json", pkgName+"/methods.gen.go",
		func(b *bytes.Buffer, methodsSchema []byte) error {
			methods, err := g.parser.ParseMethods(methodsSchema)
			if err != nil {
				return err
			}

			for _, method := range methods {
				for _, response := range method.Responses {
					extended := strings.Contains(strings.ToLower(response.Name), "extended")
					if method.Description != nil {
						b.WriteString("// " + *method.Description + "\n")
					}
					methodPostfix := g.goify(response.Name)
					if len(method.Responses) == 1 || response.Name == "response" {
						methodPostfix = ""
					}
					if strings.HasSuffix(response.Name, "Response") {
						repl := strings.ReplaceAll(response.Name, "Response", "")
						if repl != "" {
							methodPostfix = g.goify(repl)
						}
					}

					gresponse := g.objectExprToGolang(response.Expr)
					if gresponse == "StorageGetWithKeysResponse" {
						methodPostfix = "With" + methodPostfix
					}
					b.WriteString("func (vk *VK) " + g.goify(method.Name) + methodPostfix + "(params Params) (response " + gresponse + ", err error) {\n")
					if extended {
						b.WriteString("\tparams[\"extended\"] = true\n")
					}
					b.WriteString("\terr = vk.RequestUnmarshal(\"" + method.Name + "\", params, &response)\n")
					b.WriteString("\treturn\n")
					b.WriteString("}")
					b.WriteString("\n\n")
				}
			}
			return nil
		})
}

func (g Generator) generateMethodsTypeSafe() error {
	return g.generate("methods.json", pkgName+"/methods_safe.gen.go",
		func(b *bytes.Buffer, methodsSchema []byte) error {
			methods, err := g.parser.ParseMethods(methodsSchema)
			if err != nil {
				return err
			}

			for _, method := range methods {
				for _, response := range method.Responses {
					extended := strings.Contains(strings.ToLower(response.Name), "extended")
					if method.Description != nil {
						b.WriteString("// " + *method.Description + "\n")
					}
					methodPostfix := g.goify(response.Name)
					if len(method.Responses) == 1 || response.Name == "response" {
						methodPostfix = ""
					}
					if strings.HasSuffix(response.Name, "Response") {
						repl := strings.ReplaceAll(response.Name, "Response", "")
						if repl != "" {
							methodPostfix = g.goify(repl)
						}
					}
					gresponse := g.objectExprToGolang(response.Expr)
					if gresponse == "StorageGetWithKeysResponse" {
						methodPostfix = "With" + methodPostfix
					}
					b.WriteString("func (vk *VK) " + g.goify(method.Name) + methodPostfix + "Safe(req " + g.goify(method.Name) + ") (response " + gresponse + ", err error) {\n")
					if extended {
						b.WriteString("\tparams := req.params()\n")
						b.WriteString("\tparams[\"extended\"] = true\n")
						b.WriteString("\terr = vk.RequestUnmarshal(\"" + method.Name + "\", params, &response)\n")
					} else {
						b.WriteString("\terr = vk.RequestUnmarshal(\"" + method.Name + "\", req.params(), &response)\n")
					}

					b.WriteString("\treturn\n")
					b.WriteString("}")
					b.WriteString("\n\n")
				}
			}
			return nil
		})
}

func (g Generator) generateBuilders() error {
	return g.generate("methods.json", pkgName+"/builders.gen.go",
		func(b *bytes.Buffer, methodsSchema []byte) error {
			b.WriteString("import \"github.com/SevereCloud/vksdk/api\"\n\n")
			methods, err := g.parser.ParseMethods(methodsSchema)
			if err != nil {
				return err
			}

			for _, method := range methods {
				// define struct
				builderName := g.goify(method.Name) + `Builder`
				b.WriteString("// " + builderName + " builder.\n")
				b.WriteString("// \n")
				if method.Description != nil {
					b.WriteString("// " + *method.Description + "\n")
					b.WriteString("// \n")
				}

				b.WriteString("// https://vk.com/dev/" + method.Name + "\n")
				b.WriteString(`type ` + builderName + ` struct {` + "\n")
				b.WriteString("\tapi.Params\n")
				b.WriteString("}\n\n")

				// define constructor
				b.WriteString("// " + builderName + " func.\n")
				b.WriteString("func New" + builderName + "() *" + builderName + " {\n")
				b.WriteString("\treturn &" + builderName + "{api.Params{}}\n")
				b.WriteString("}\n\n")

				for _, parameter := range method.Parameters {
					if parameter.Description != nil {
						b.WriteString("// " + *parameter.Description + "\n")
					}

					gparam := g.objectExprToGolang(parameter.ObjectExpr)
					aLevel := strings.Count(gparam, "[]")
					gparam = strings.ReplaceAll(gparam, "[]", "")
					_, isBuiltin := builtinTypes[gparam]
					if !isBuiltin {
						gparam = "api." + gparam
					}
					if aLevel == 1 {
						gparam = "..." + gparam
					} else {
						for i := 0; i < aLevel; i++ {
							gparam = "[]" + gparam
						}
					}
					b.WriteString("func (b *" + builderName + ") " + g.goify(parameter.Name) + "(v " + gparam + ") *" + builderName + " {\n")
					b.WriteString("\tb.Params[\"" + parameter.Name + "\"] = v\n")
					b.WriteString("\treturn b\n")
					b.WriteString("}\n\n")
				}
			}
			return nil
		})
}

func (g Generator) generateRequests() error {
	return g.generate("methods.json", pkgName+"/requests.gen.go",
		func(b *bytes.Buffer, methodsSchema []byte) error {
			methods, err := g.parser.ParseMethods(methodsSchema)
			if err != nil {
				return err
			}

			for _, method := range methods {
				// define struct
				requestName := g.goify(method.Name)
				b.WriteString("// " + requestName + ".\n")
				b.WriteString("// \n")
				if method.Description != nil {
					b.WriteString("// " + *method.Description + "\n")
					b.WriteString("// \n")
				}

				b.WriteString("// https://vk.com/dev/" + method.Name + "\n")
				b.WriteString("type " + requestName + " struct{\n")
				for _, parameter := range method.Parameters {
					paramName := g.goify(parameter.Name)
					paramType := g.objectExprToGolang(parameter.ObjectExpr)
					if _, isBuiltin := builtinTypes[paramType]; !isBuiltin && !strings.HasPrefix(paramType, "[]") {
						paramType = "*" + paramType
					}
					b.WriteString("\t" + paramName + " " + paramType)
					if parameter.Description != nil {
						b.WriteString("// " + *parameter.Description)
					}
					b.WriteString("\n")
				}
				b.WriteString("}\n\n")

				b.WriteString("func (req " + requestName + ") params() Params {\n")
				b.WriteString("\tparams := make(Params)\n")
				for _, parameter := range method.Parameters {
					pname := g.goify(parameter.Name)
					ptype := g.objectExprToGolang(parameter.ObjectExpr)
					b.WriteString("\tif ")
					if strings.HasPrefix(ptype, "[]") {
						b.WriteString("len(req." + pname + ") > 0")
					} else if ptype == "bool" {
						b.WriteString("req." + pname)
					} else if ptype == "string" {
						b.WriteString("req." + pname + " != \"\"")
					} else if ptype == "int64" || ptype == "float64" {
						b.WriteString("req." + pname + " != 0")
					} else {
						b.WriteString("req." + pname + " != nil")
					}

					b.WriteString(" {\n")
					b.WriteString("\t\tparams[\"" + parameter.Name + "\"] = req." + g.goify(parameter.Name) + "\n")
					b.WriteString("\t}\n")
				}
				b.WriteString("\treturn params\n")
				b.WriteString("}\n\n")

			}
			return nil
		})
}

func (g Generator) goify(name string) string {
	if g.nogoify {
		return name
	}

	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	for i, r := range runes {
		if r == '_' || r == ' ' || r == '.' {
			if i+1 == len(runes) {
				break
			}
			runes[i+1] = unicode.ToUpper(runes[i+1])
		}
	}

	return g.goifyReplacer.Replace(string(runes))
}

func (g Generator) ObjectDefinitionToGolang(obj schema.ObjectDefinition) string {
	var sb strings.Builder
	if obj.Expr.Description != nil {
		sb.WriteString("// " + *obj.Expr.Description + "\n")
	}

	gname := g.goify(obj.Name)
	if gname == "LeadsComplete" || gname == "LeadsStart" {
		gname += "Object"
	}
	if obj.Expr.IsBaseType || obj.Expr.IsReference {
		gtype := g.objectExprToGolang(obj.Expr)
		// alias
		if isBuiltin(gtype) {
			sb.WriteString("type " + gname + " = " + gtype + "\n")
			return sb.String()
		}
		sb.WriteString("type " + gname + " " + gtype + "\n")
		return sb.String()
	}

	if obj.Expr.IsEnum {
		sb.WriteString("type " + gname + " " + g.objectExprToGolang(obj.Expr) + "\n")
		if len(obj.Expr.Enum) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, item := range obj.Expr.Enum {
			val := "undefined"
			isString := false
			switch obj.Expr.Type {
			case "number":
				val = strconv.FormatFloat(item.(float64), 'g', 10, 64)
			case "integer":
				val = strconv.FormatInt(item.(int64), 10)
			case "string":
				val = item.(string)
				isString = true
			default:
				panic("unsupported enum type")
			}

			fieldNamePostfix := val
			if len(obj.Expr.EnumNames) > 0 {
				fieldNamePostfix = obj.Expr.EnumNames[idx]
			}

			if isString {
				val = `"` + val + `"`
			}

			fieldName := gname + g.goify(fieldNamePostfix)
			sb.WriteString("\t" + fieldName + " " + gname + " = " + val + "\n")
		}
		sb.WriteString(")\n")
		return sb.String()
	}

	if obj.Expr.IsAllOf {
		s := "// allof " + obj.Name
		s = "type " + g.goify(obj.Name) + " " + g.allofExprToGolang(obj.Expr)
		return s
	}

	if obj.Expr.IsOneOf {
		var values []schema.ObjectExpr = obj.Expr.OneOf

		sb.WriteString("type " + gname + " struct {\n")
		for _, val := range values {
			if val.IsReference {
				ref, err := val.Ref()
				if err != nil {
					panic(err)
				}
				jtag := "`json:\"" + *&ref.Name + ",omitempty\"`"
				sb.WriteString("\t*" + g.objectExprToGolang(val) + " " + jtag + "\n")
				continue
			}

			for _, prop := range val.Properties {
				jtag := "`json:\"" + prop.Name + ",omitempty\"`"
				sb.WriteString("\t" + g.goify(prop.Name) + "*" + g.objectExprToGolang(prop.Expr) + " " + jtag + "\n")
			}
		}
		sb.WriteString("}\n")
		return sb.String()
	}

	sb.WriteString("type " + gname + " struct {\n")
	for _, prop := range obj.Expr.Properties {
		jsonTag := "`json:\"" + prop.Name
		jsonTag += "\"`"
		goType := g.objectExprToGolang(prop.Expr)

		if prop.Expr.IsReference {
			ref, err := prop.Expr.Ref()
			if err != nil {
				panic(err)
			}
			if obj.Name == *&ref.Name {
				goType = "*" + goType
			}
		}

		if prop.Expr.Description != nil {
			jsonTag += " // " + *prop.Expr.Description
		}

		sb.WriteString("\t" + g.goify(prop.Name) + " " + goType + " " + jsonTag + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) objectExprToGolang(expr schema.ObjectExpr) string {
	if expr.IsReference {
		ref, err := expr.Ref()
		if err != nil {
			panic(err)
		}
		return g.goify(*&ref.Name)
	}

	if expr.IsAllOf {
		return g.allofExprToGolang(expr)
	}

	switch expr.Type {
	case "integer":
		return "int64"
	case "number":
		return "float64"
	case "string":
		return "string"
	case "boolean":
		return "bool"
	case "array":
		return "[]" + g.objectExprToGolang(*expr.ArrayOf)
	case "object":
		if len(expr.Properties) > 0 {
			var sb strings.Builder
			sb.WriteString("struct{\n")
			for _, prop := range expr.Properties {
				jtag := "`json:\"" + prop.Name + "\"`"
				sb.WriteString("\t" + g.goify(prop.Name) + " " + g.objectExprToGolang(prop.Expr) + " " + jtag + "\n")
			}
			sb.WriteString("}\n")
			return sb.String()
		}
		fallthrough
	default:
		return "interface{}"
	}
}

var responseRules = map[string]string{
	"messages_delete_response": "map[string]int64",
}

func (g Generator) ResponseDefinitionToGolang(resp schema.ResponseDefinition) string {
	var sb strings.Builder
	if resp.Expr.Description != nil {
		sb.WriteString("// " + *resp.Expr.Description + "\n")
	}
	gname := g.goify(resp.Name)
	if !strings.HasSuffix(gname, "Response") {
		gname = gname + "Response"
	}
	if forcedType, ok := responseRules[resp.Name]; ok {
		sb.WriteString("type " + gname + " " + forcedType + "\n")
		return sb.String()
	}

	if resp.Expr.IsBaseType || resp.Expr.IsReference {
		gtype := g.objectExprToGolang(resp.Expr.ObjectExpr)
		// alias
		if isBuiltin(gtype) {
			sb.WriteString("type " + gname + " = " + gtype + "\n")
			return sb.String()
		}
		sb.WriteString("type " + gname + " " + gtype + "\n")
		return sb.String()
	}

	if resp.Expr.IsEnum {
		if resp.Expr.Description != nil {
			sb.WriteString("// " + *resp.Expr.Description + "\n")
		}
		sb.WriteString("type " + gname + " " + g.objectExprToGolang(resp.Expr.ObjectExpr) + "\n")
		if len(resp.Expr.Enum) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, item := range resp.Expr.Enum {
			val := "undefined"
			isString := false
			switch resp.Expr.ObjectExpr.Type {
			case "number":
				val = strconv.FormatFloat(item.(float64), 'g', 10, 64)
			case "integer":
				val = strconv.FormatInt(item.(int64), 10)
			case "string":
				val = item.(string)
				isString = true
			default:
				panic("unsupported enum type")
			}

			fieldNamePostfix := val
			if len(resp.Expr.EnumNames) > 0 {
				fieldNamePostfix = resp.Expr.EnumNames[idx]
			}

			if isString {
				val = `"` + val + `"`
			}

			fieldName := gname + g.goify(fieldNamePostfix)
			sb.WriteString("\t" + fieldName + " " + gname + " = " + val + "\n")
		}
		sb.WriteString(")\n")
		return sb.String()
	}

	if resp.Expr.IsAllOf {
		s := "// allof" + resp.Name
		s = "type" + g.goify(resp.Name) + " " + g.allofExprToGolang(resp.Expr.ObjectExpr)
		return s
	}

	if resp.Expr.IsOneOf {
		var values []schema.ObjectExpr = resp.Expr.OneOf

		sb.WriteString("type " + gname + " struct {\n")
		for _, val := range values {
			if val.IsReference {
				ref, err := val.Ref()
				if err != nil {
					panic(err)
				}
				jtag := "`json:\"" + *&ref.Name + ",omitempty\"`"
				sb.WriteString("\t*" + g.objectExprToGolang(val) + " " + jtag + "\n")
				continue
			}

			for _, prop := range val.Properties {
				jtag := "`json:\"" + prop.Name + ",omitempty\"`"
				sb.WriteString("\t" + g.goify(prop.Name) + "*" + g.objectExprToGolang(prop.Expr) + " " + jtag + "\n")
			}
		}
		sb.WriteString("}\n")
		return sb.String()
	}

	requiredFields := make(map[string]struct{})
	for _, field := range resp.Expr.Required {
		requiredFields[field] = struct{}{}
	}
	allFieldsRequired := len(requiredFields) == 0
	sb.WriteString("type " + gname + " struct {\n")
	for _, prop := range resp.Expr.Properties {
		jsonTag := "`json:\"" + prop.Name
		ptr := false
		if _, required := requiredFields[prop.Name]; !required && !allFieldsRequired {
			jsonTag += ",omitempty"
			ptr = true
		}
		jsonTag += "\"`"
		goType := g.objectExprToGolang(prop.Expr)

		if prop.Expr.IsReference {
			ref, err := prop.Expr.Ref()
			if err != nil {
				panic(err)
			}
			if resp.Name == *&ref.Name || ptr {
				goType = "*" + goType
			}
		}

		if prop.Expr.Description != nil {
			jsonTag += " // " + *prop.Expr.Description
		}

		sb.WriteString("\t" + g.goify(prop.Name) + " " + goType + " " + jsonTag + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) allofExtractFields(expr schema.ObjectExpr) map[string][]schema.ObjectExpr {
	if !expr.IsAllOf {
		panic("expr is not allof")
	}
	if len(expr.AllOf) == 0 {
		panic("empty allof")
	}

	fields := make(map[string][]schema.ObjectExpr)
	for _, val := range expr.AllOf {
		if val.IsReference {
			ref, err := val.Ref()
			if err != nil {
				panic(err)
			}
			if ref.Expr.IsAllOf {
				for name, allofFields := range g.allofExtractFields(ref.Expr) {
					tmp, ok := fields[name]
					if !ok {
						tmp = make([]schema.ObjectExpr, 0)
					}
					tmp = append(tmp, allofFields...)
					fields[name] = tmp
				}
				continue
			}

			if ref.Expr.IsReference {
				panic("reference extr. unimplemented")
			}

			for _, prop := range ref.Expr.Properties {
				tmp, ok := fields[prop.Name]
				if !ok {
					tmp = make([]schema.ObjectExpr, 0)
				}
				tmp = append(tmp, prop.Expr)
				fields[prop.Name] = tmp
			}
			continue
		}

		if len(val.Properties) == 0 {
			panic("allof no props")
		}
		for _, prop := range val.Properties {
			tmp, ok := fields[prop.Name]
			if !ok {
				tmp = make([]schema.ObjectExpr, 0)
			}
			tmp = append(tmp, prop.Expr)
			fields[prop.Name] = tmp
		}
	}
	return fields
}

func (g Generator) allofExprToGolang(expr schema.ObjectExpr) string {
	var sb strings.Builder
	fields := g.allofExtractFields(expr)
	sb.WriteString("struct{\n")
	for propName, fields := range fields {
		if len(fields) == 0 {
			panic("no fields")
		}
		if len(fields) == 1 {
			sb.WriteString("\t" + g.goify(propName) + " " + g.objectExprToGolang(fields[0]) + "`json:\"" + propName + "\"`\n")
			continue
		}
		equal := true
		for i := 1; i < len(fields); i++ {
			if isDifferentExprs(fields[i-1], fields[i]) {
				equal = false
				break
			}
		}
		if equal {
			sb.WriteString("\t" + g.goify(propName) + " " + g.objectExprToGolang(fields[0]) + "`json:\"" + propName + "\"`\n")
			continue
		}
		sb.WriteString("\t" + g.goify(propName) + " json.RawMessage `json:\"" + propName + "\"`\n")
	}

	if sb.Len() == 0 {
		panic("allof empty code")
	}
	sb.WriteString("}")
	return sb.String()
}

func isDifferentExprs(expr1, expr2 schema.ObjectExpr) bool {
	if expr1.Type != expr2.Type {
		return true
	}

	if expr1.IsBaseType && expr2.IsBaseType {
		return false
	}

	if expr1.IsReference && expr2.IsReference {
		ref1, err := expr1.Ref()
		if err != nil {
			panic("gfg")
		}

		ref2, err := expr2.Ref()
		if err != nil {
			panic("gfg2")
		}
		return isDifferentDefs(ref1, ref2)
	} else if expr1.IsReference && !expr2.IsReference ||
		!expr1.IsReference && expr2.IsReference {
		return true
	}

	if len(expr1.Properties) != len(expr2.Properties) {
		return true
	}
	for i := 0; i < len(expr1.Properties); i++ {
		p1 := expr1.Properties[i]
		p2 := expr2.Properties[i]
		if isDifferentDefs(p1, p2) {
			return true
		}
	}

	if expr1.IsEnum && expr2.IsEnum {
		if !testEqStrings(expr1.EnumNames, expr2.EnumNames) {
			return true
		}
	} else if expr1.IsEnum && !expr2.IsEnum ||
		!expr1.IsEnum && expr2.IsEnum {
		return true
	}

	if expr1.IsAllOf && expr2.IsAllOf {
		if len(expr1.AllOf) != len(expr2.AllOf) {
			return true
		}
		for i := 0; i < len(expr1.AllOf); i++ {
			a1 := expr1.AllOf[i]
			a2 := expr2.AllOf[i]
			if isDifferentExprs(a1, a2) {
				return true
			}
		}
	} else if expr1.IsAllOf && !expr2.IsAllOf ||
		!expr1.IsAllOf && expr2.IsAllOf {
		return true
	}

	if expr1.IsOneOf && expr2.IsOneOf {
		if len(expr1.OneOf) != len(expr2.OneOf) {
			return true
		}
		for i := 0; i < len(expr1.OneOf); i++ {
			a1 := expr1.OneOf[i]
			a2 := expr2.OneOf[i]
			if isDifferentExprs(a1, a2) {
				return true
			}
		}
	} else if expr1.IsOneOf && !expr2.IsOneOf ||
		!expr1.IsOneOf && expr2.IsOneOf {
		return true
	}

	if expr1.ArrayOf != nil && expr2.ArrayOf != nil {
		if isDifferentExprs(*expr1.ArrayOf, *expr2.ArrayOf) {
			return true
		}
	} else if expr1.ArrayOf != nil && expr2.ArrayOf == nil ||
		expr1.ArrayOf == nil && expr2.ArrayOf != nil {
		return true
	}

	return false
}

func isDifferentDefs(def1, def2 schema.ObjectDefinition) bool {
	if def1.Name != def2.Name {
		return true
	}
	return isDifferentExprs(def1.Expr, def2.Expr)
}

func testEqStrings(a, b []string) bool {

	// If one is nil, the other must also be nil.
	if (a == nil) != (b == nil) {
		return false
	}

	if len(a) != len(b) {
		return false
	}

	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}

	return true
}

var builtinTypes = map[string]struct{}{
	"int64":   {},
	"float64": {},
	"string":  {},
	"bool":    {},
}

func isBuiltin(s string) bool {
	s = strings.ReplaceAll(s, "[]", "")
	_, ok := builtinTypes[s]
	return ok
}
