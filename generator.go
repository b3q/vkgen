package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"strconv"
	"strings"
	"unicode"

	"github.com/b3q/vkgen/schema"
	"github.com/tidwall/gjson"
)

const (
	genPrefix = "// Code generated by vkgen; DO NOT EDIT."
	pkgName   = "generated"
)

type Generator struct {
	goifyReplacer *strings.Replacer
}

func NewGenerator() Generator {
	repl := []string{
		"_", "",
		" ", "",
		".", "",
		"2fa", "TwoFA",
		"json", "JSON",
		"Id", "ID",
		"Ttl", "TTL",
		"Sdk", "SDK",
		"Vk", "VK",
		"Tv", "TV",
		"Url", "URL",
	}

	return Generator{
		goifyReplacer: strings.NewReplacer(repl...),
	}
}

func (g Generator) Generate() (err error) {
	err = g.generateObjects()
	if err != nil {
		return err
	}

	err = g.generateResponses()
	if err != nil {
		return err
	}

	err = g.generateMethods()
	if err != nil {
		return err
	}

	err = g.generateBuilders()
	if err != nil {
		return err
	}

	return
}

func (g Generator) writeSource(name string, b *bytes.Buffer) error {
	src, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}

	return ioutil.WriteFile(name, src, 0677)
}

type callback = func(b *bytes.Buffer, parser *schema.Parser, values gjson.Result) error

func (g Generator) generate(schemaFile, outputName string, cb callback) error {
	sch, err := ioutil.ReadFile(schemaFile)
	if err != nil {
		return err
	}

	objects := gjson.ParseBytes(sch)
	parser := schema.NewParser()
	b := bytes.NewBuffer(nil)
	b.WriteString(genPrefix + "\n\npackage " + pkgName + "\n")

	err = cb(b, parser, objects)
	if err != nil {
		return err
	}

	return g.writeSource(outputName, b)
}

func (g Generator) generateObjects() error {
	return g.generate("objects.json", pkgName+"/objects.gen.go",
		func(b *bytes.Buffer, parser *schema.Parser, objects gjson.Result) error {
			objects.Get("definitions").ForEach(func(defName, definition gjson.Result) bool {
				def := parser.ParseDefinition(defName.String(), definition)
				b.WriteString(g.rootDefToString(def))
				return true
			})

			return nil
		})
}

func (g Generator) generateResponses() error {
	return g.generate("responses.json", pkgName+"/responses.gen.go",
		func(b *bytes.Buffer, parser *schema.Parser, responses gjson.Result) error {
			responses.Get("definitions").ForEach(func(defName, definition gjson.Result) bool {
				def := parser.ParseDefinition(defName.String(), definition.Get("properties.response"))
				if req := definition.Get("properties.response.required"); req.Exists() && req.IsArray() {
					requiredFields := make(map[string]struct{})
					for _, field := range req.Array() {
						requiredFields[field.String()] = struct{}{}
					}

					for _, prop := range def.Properties {
						if _, found := requiredFields[*prop.Name]; !found {
							prop.IsOptional = true
						}
					}
				}
				b.WriteString(g.rootDefToString(def))
				return true
			})

			return nil
		})
}

func (g Generator) generateMethods() error {
	return g.generate("methods.json", pkgName+"/methods.gen.go",
		func(b *bytes.Buffer, parser *schema.Parser, methods gjson.Result) error {
			for _, method := range methods.Get("methods").Array() {
				methodName := method.Get("name").String()
				if len(method.Get("responses").Map()) == 1 {
					def := parser.ParseDefinition(methodName, method.Get("responses.response"))
					if desc := method.Get("description"); desc.Exists() {
						b.WriteString("// " + desc.String())
					}
					b.WriteString(`
			func (vk *VK) ` + g.goify(methodName) + `(params Params) (response ` + g.defWithoutProps(def) + `, err error) {
				err = vk.RequestUnmarshal("` + methodName + `", params, &response)
				return
			}` + "\n\n")
					continue
				}

				fmt.Fprintln(b, `
			func (vk *VK) `+g.goify(methodName)+`Raw(params Params) ([]byte, error) {
				return vk.Request("`+methodName+`", params)
			}`)
			}

			return nil
		})
}

func (g Generator) generateBuilders() error {
	return g.generate("methods.json", pkgName+"/builders.gen.go",
		func(b *bytes.Buffer, parser *schema.Parser, methods gjson.Result) error {
			for _, method := range methods.Get("methods").Array() {
				methodName := method.Get("name").String()

				// define struct
				builderName := g.goify(methodName) + `Builder`
				b.WriteString("// " + builderName + " builder.\n")
				b.WriteString("// \n")
				if desc := method.Get("description"); desc.Exists() {
					b.WriteString("// " + desc.String() + "\n")
				}
				b.WriteString("// \n")
				b.WriteString("// https://vk.com/dev/" + methodName + "\n")
				b.WriteString(`type ` + builderName + ` struct {` + "\n")
				b.WriteString("\tapi.Params\n")
				b.WriteString("}\n\n")

				// define constructor
				b.WriteString("// " + builderName + " func.\n")
				b.WriteString("func New" + builderName + "() *" + builderName + " {\n")
				b.WriteString("\treturn &" + builderName + "{api.Params{}}\n")
				b.WriteString("}\n\n")

				for _, parameter := range method.Get("parameters").Array() {
					parameterName := g.goify(parameter.Get("name").String())
					def := parser.ParseDefinition(parameterName, parameter)

					if desc := parameter.Get("description"); desc.Exists() {
						b.WriteString("// " + desc.String() + "\n")
					}
					b.WriteString("func (b *" + builderName + ") " + parameterName + "(v " + g.defWithoutProps(def) + ") *" + builderName + " {\n")
					b.WriteString("\tb.Params[\"" + parameter.Get("name").String() + "\"] = v\n")
					b.WriteString("\treturn b\n")
					b.WriteString("}\n\n")
				}
			}
			return nil
		})
}

func (g Generator) goify(name string) string {
	runes := []rune(name)
	runes[0] = unicode.ToUpper(runes[0])
	for i, r := range runes {
		if r == '_' || r == ' ' || r == '.' {
			runes[i+1] = unicode.ToUpper(runes[i+1])
		}
	}

	return g.goifyReplacer.Replace(string(runes))
}

func (g Generator) enumToString(enum schema.Enum) string {
	var sb strings.Builder
	if enum.Description != nil {
		sb.WriteString("\n// " + *enum.Description)
	}
	sb.WriteString("\ntype " + g.goify(enum.Name) + " ")
	switch enum.DataType {
	case schema.IntegerType:
		sb.WriteString("int64\n")
		if len(enum.IntegerValues) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, value := range enum.IntegerValues {
			s := strconv.FormatInt(value, 10)
			fieldName := enum.Name + "_" + s
			if len(enum.Names) > 0 {
				fieldName = enum.Name + "_" + enum.Names[idx]
			}
			sb.WriteString("\t" + g.goify(fieldName) + " " + g.goify(enum.Name) + " = " + s + "\n")
		}
		sb.WriteString(")\n")
	case schema.NumberType:
		sb.WriteString("float64\n")
		if len(enum.NumberValues) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, value := range enum.NumberValues {
			s := strconv.FormatFloat(value, 'g', 10, 64)
			fieldName := enum.Name + "_" + s
			if len(enum.Names) > 0 {
				fieldName = enum.Name + "_" + enum.Names[idx]
			}
			sb.WriteString("\t" + g.goify(fieldName) + " " + g.goify(enum.Name) + " = " + s + "\n")
		}
		sb.WriteString(")\n")
	case schema.StringType:
		sb.WriteString("string\n")
		if len(enum.StringValues) == 0 {
			return sb.String()
		}

		sb.WriteString("\nconst (\n")
		for idx, value := range enum.StringValues {
			fieldName := enum.Name + "_" + value
			if len(enum.Names) > 0 {
				fieldName = enum.Name + "_" + enum.Names[idx]
			}
			sb.WriteString("\t" + g.goify(fieldName) + " " + g.goify(enum.Name) + " = \"" + value + "\"\n")
		}
		sb.WriteString(")\n")
	case schema.BooleanType:
		sb.WriteString("boolXXX")
	case schema.ObjectType:
		sb.WriteString("interface{}\n")
	default:
		sb.WriteString("wtf " + string(enum.DataType))
	}

	return sb.String()
}

func (g Generator) arrayToString(array schema.Array) string {
	switch array.DataType {
	case schema.IntegerType:
		fallthrough
	case schema.NumberType:
		return "[]int64"
	case schema.BooleanType:
		return "[]bool"
	case schema.StringType:
		return "[]string"
	case schema.ArrayType:
		return "[]" + g.arrayToString(*array.Ref.Array)
	case schema.ReferenceType:
		return "[]" + g.goify(*array.Ref.Name)
	case schema.AllofType:
		str := "[]struct{\n"
		for _, item := range array.AllOf.PossibleValues {
			switch item.DataType {
			case schema.ReferenceType:
				str += "\t\t*" + g.goify(*item.Name) + "\n"
			case schema.NumberType:
				fallthrough
			case schema.IntegerType:
				fallthrough
			default:
				panic("unsupported array type: " + string(item.DataType))
			}
		}
		str += "\t}"
		return str
	default:
		return "[]interface{} //hz"
		//panic("unsupported array data type: " + string(array.DataType))
	}
}

func (g Generator) oneofToString(oneof schema.OneOf) string {
	var sb strings.Builder
	sb.WriteString("\n// oneof " + oneof.Name)
	sb.WriteString("\ntype " + g.goify(oneof.Name) + " struct{\n")

	for _, value := range oneof.PossibleValues {
		if value.Name != nil {
			jsonPrefix := "`json:\"" + *value.Name + ",omitempty\"`"
			sb.WriteString("\t*" + g.goify(*value.Name) + jsonPrefix + "\n")
			continue
		}

		//sb.WriteString("\t*struct{\n")
		for _, prop := range value.Properties {
			jsonPrefix := "`json:\"" + *prop.Name + ",omitempty\"`"
			sb.WriteString("\t" + g.goify(*prop.Name) + " ")
			switch prop.DataType {
			case schema.IntegerType:
				sb.WriteString("int64")
			case schema.NumberType:
				sb.WriteString("float64")
			case schema.StringType:
				sb.WriteString("string")
			case schema.BooleanType:
				sb.WriteString("bool")
			case schema.ReferenceType:
				sb.WriteString(g.goify(*prop.RefTo))
			default:
				sb.WriteString("unknown:" + string(prop.DataType))
			}
			sb.WriteString(jsonPrefix + "\n")
		}
		//sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) allofToString(allof schema.AllOf) string {
	var sb strings.Builder
	sb.WriteString("\n// allof " + allof.Name)
	sb.WriteString("\ntype " + g.goify(allof.Name) + " struct{\n")
	for _, value := range allof.PossibleValues {
		if value.Name != nil {
			jsonPrefix := "`json:\"" + *value.Name + ",omitempty\"`"
			sb.WriteString("\t*" + g.goify(*value.Name) + jsonPrefix + "\n")
			continue
		}

		//sb.WriteString("\t*struct{\n")
		for _, prop := range value.Properties {
			jsonPrefix := "`json:\"" + *prop.Name + ",omitempty\"`"
			sb.WriteString("\t" + g.goify(*prop.Name) + " ")
			switch prop.DataType {
			case schema.IntegerType:
				sb.WriteString("*int64")
			case schema.NumberType:
				sb.WriteString("*float64")
			case schema.StringType:
				sb.WriteString("*string")
			case schema.BooleanType:
				sb.WriteString("*bool")
			case schema.ReferenceType:
				sb.WriteString("*" + g.goify(*prop.RefTo))
			case schema.ArrayType:
				sb.WriteString("*" + g.arrayToString(*prop.Array))
			default:
				sb.WriteString("unknown:" + string(prop.DataType))
			}
			sb.WriteString(jsonPrefix + "\n")
		}
		//sb.WriteString("\t}\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) rootDefToString(def *schema.Definition) string {
	if def.Enum != nil {
		return g.enumToString(*def.Enum)
	}

	if def.OneOf != nil {
		return g.oneofToString(*def.OneOf)
	}

	if def.AllOf != nil {
		return g.allofToString(*def.AllOf)
	}

	// если нет полей, походу это филд
	if len(def.Properties) == 0 {
		s := "\ntype " + g.goify(*def.Name) + " " + g.defWithoutProps(def) + "\n"
		if def.Description != nil {
			s = "\n// " + *def.Description + s
		}
		return s
	}

	if def.DataType != schema.ObjectType {
		panic("unexpected definition data type: " + string(def.DataType))
	}

	var sb strings.Builder
	if def.Description != nil {
		sb.WriteString("\n// " + *def.Description)
	}
	sb.WriteString("\ntype " + g.goify(*def.Name) + " struct{\n")
	for _, prop := range def.Properties {
		jsonTag := "`json:\"" + *prop.Name
		ptr := false
		if prop.IsOptional {
			jsonTag += ",omitempty"
			ptr = true
		}
		jsonTag += "\"`"
		propertyType := g.defWithoutProps(prop)

		if prop.DataType == schema.ReferenceType {
			if propertyType == g.goify(*def.Name) || ptr {
				propertyType = "*" + propertyType
			}
		}

		if prop.Description != nil {
			jsonTag += " // " + *prop.Description
		}

		sb.WriteString("\t" + g.goify(*prop.Name) + " " + propertyType + " " + jsonTag + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}

func (g Generator) defWithoutProps(def *schema.Definition) string {
	switch def.DataType {
	case schema.ReferenceType:
		return g.goify(*def.RefTo)
	case schema.ArrayType:
		return g.arrayToString(*def.Array)
	case schema.EnumType:
		return g.goify(def.Enum.Name)
	case schema.OneofType:
		return g.goify(def.OneOf.Name)
	case schema.AllofType:
		return g.goify(def.AllOf.Name)
	case schema.BooleanType:
		return "bool"
	case schema.IntegerType:
		return "int64"
	case schema.NumberType:
		return "float64"
	case schema.StringType:
		return "string"
	case schema.ObjectType:
		//sb.WriteString("interface{} //hz")
		//str := rootDefToString(prop)
		//fmt.Println("kek:" + str + ":kek")
		// sb.Reset()
		// sb.WriteString("\ntype " + g.goify(*def.Name) + " struct{\n")
		// for _, prop := range def.Properties {
		// 	sb.WriteString("\t" + rootDefToString(prop) + "\n")
		// }
		// sb.WriteString("}\n")
		fallthrough
	case schema.UnsupportedType:
		return "interface{}"
	default:
		panic("unsupported datatype: " + string(def.DataType))
	}
}

func (g Generator) methodResponseDefToString(def *schema.Definition) string {
	var sb strings.Builder
	sb.WriteString("\ntype " + g.goify(*def.Name) + " struct{\n")
	for _, prop := range def.Properties {
		ptr := false
		if prop.IsOptional {
			ptr = true
		}
		propertyType := g.defWithoutProps(prop)

		if prop.DataType == schema.ReferenceType {
			if propertyType == g.goify(*def.Name) || ptr {
				propertyType = "*" + propertyType
			}
		}

		sb.WriteString("\t*" + propertyType + "\n")
	}

	sb.WriteString("}\n")
	return sb.String()
}
